# 类和对象的基本数据结构

由于 OC 中 `NSObject` 是基类，我们可以从它的实现来看一下类和对象的数据结构是怎么实现的。

我们可以在源码中找到 `NSObject.h` 和 `NSObject.mm` 这两个文件。`NSObject` 的定义如下。

```
// NSObject.h line 53
@interface NSObject <NSObject> {
    Class isa  OBJC_ISA_AVAILABILITY;
}
```

我们可以看出它只有一个 `Class` 成员变量 `isa`。

通过查看 `Class` 定义如下

```
// Object.mm line 33
typedef struct objc_class *Class;
typedef struct objc_object *id;
```

在这里我们看到了 `Class` 就是一个指向 `objc_class` 类型结构体的指针，同时我们经常用可以修饰任意 OC 对象的 `id` 是一个指向 `objc_object` 类型结构体的指针。

因此 `objc_class` 和 `objc_object` 就是类和对象对应的数据结构。

## `objc_class` 和 `objc_object` 

我们在网上看到最多的就是 `runtime.h` 中的定义。

```
// runtime.h line 41
#if !OBJC_TYPES_DEFINED
// line 55
struct objc_class {
    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;

#if !__OBJC2__
    Class _Nullable super_class                              OBJC2_UNAVAILABLE;
    const char * _Nonnull name                               OBJC2_UNAVAILABLE;
    long version                                             OBJC2_UNAVAILABLE;
    long info                                                OBJC2_UNAVAILABLE;
    long instance_size                                       OBJC2_UNAVAILABLE;
    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;
    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;
    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;
    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;
#endif

} OBJC2_UNAVAILABLE;
/* Use `Class` instead of `struct objc_class *` */

#endif
```

但是仔细看代码就会发现 `OBJC_TYPES_DEFINED` 这个宏，它定义在 `objc-private.h` 文件中

```
// objc-private.h line 41
#define OBJC_TYPES_DEFINED 1
```

因此这个定义是早已过期的。我们接着找。

会发现项目中存在 `objc-runtime-new.h` `objc-runtime-new.mm` 和 `objc-runtime-old.h` `objc-runtime-old.mm` 这些文件。结合上一节的 `runtime` 的介绍和代码注释我们可以看出来这些就是 Objective-C 以及 Objective-C 2.0 两种实现。

```
// objc-runtime-old.h line 183
struct objc_class : objc_object {
    Class superclass;
    const char *name;
    uint32_t version;
    uint32_t info;
    uint32_t instance_size;
    struct old_ivar_list *ivars;
    struct old_method_list **methodLists;
    Cache cache;
    struct old_protocol_list *protocols;
    // CLS_EXT only
    const uint8_t *ivar_layout;
    struct old_class_ext *ext;
    ...
    // 下面都是一些函数
}
```

```
// objc-runtime-new.h line 1111
struct objc_class : objc_object {
    // Class ISA;
    Class superclass;
    cache_t cache;             // formerly cache pointer and vtable
    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags

    class_rw_t *data() { 
        return bits.data();
    }
    ...
}
```

```
// objc-private.h line 75
struct objc_object {
    isa_t isa;
    ...
}
```

老版本的实现就没必要在仔细看了，但是有一点需要注意的就是 `ivars`（属性列表）、`methodLists`（方法列表）。

```
struct old_ivar_list *ivars;
struct old_method_list **methodLists;
```

`ivars` 是指向 `old_ivar_list` 的指针。
`methodLists` 是指向 `old_method_list` 的指针。
`*methodLists` 是指向指向方法列表的指针。
因此可以通过修改 `*methodLists` 的值来改变方法列表。

我们可以看出 `objc_class` 都继承自 `objc_object` 。这也说明了在 **OC 中类也是对象**。而且所有的对象（继承自 `NSObject`）都包含了一个类型为 `isa_t` 的 结构体。

## `isa` 和 `Meta Class`

### `isa` 的实现

在老版本中 `isa` 是一个当前对象指向当前对象对应的类的指针。`isa_t` 也实现了这个功能，而且添加了一些其他的信息。

```
// objc-private.h line 61
union isa_t {
    isa_t() { }
    isa_t(uintptr_t value) : bits(value) { }

    Class cls;
    uintptr_t bits;
#if defined(ISA_BITFIELD)
    struct {
        ISA_BITFIELD;  // defined in isa.h
    };
#endif
};

// isa.h line 78
#   define ISA_BITFIELD                                                        \
      uintptr_t nonpointer        : 1;                                         \
      uintptr_t has_assoc         : 1;                                         \
      uintptr_t has_cxx_dtor      : 1;                                         \
      uintptr_t shiftcls          : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \
      uintptr_t magic             : 6;                                         \
      uintptr_t weakly_referenced : 1;                                         \
      uintptr_t deallocating      : 1;                                         \
      uintptr_t has_sidetable_rc  : 1;                                         \
      uintptr_t extra_rc          : 8
```

通过代码你会发现这是一个相当复杂的结构体，具体为什么这样设计可以参考下面这段文字。

> 使用整个指针大小的内存来存储 isa 指针有些浪费，尤其在 64 位的 CPU 上。在 ARM64 运行的 iOS 只使用了 33 位作为指针(与结构体中的 33 位无关，Mac OS 上为 47 位)，而剩下的 31 位用于其它目的。类的指针也同样根据字节对齐了，每一个类指针的地址都能够被 8 整除，也就是使最后 3 bits 为 0，为 isa 留下 34 位用于性能的优化。

更多的内容可以看 draveness 大神的 [文章](https://github.com/draveness/analyze/blob/master/contents/objc/%E4%BB%8E%20NSObject%20%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%86%E8%A7%A3%20isa.md)。

我们在这里就把 `isa` 简单的当做指针来进行分析。

### `Meta Class`

我们通过上面的 `objc_object` 的实现代码看出来，OC 中对象并没有存储方法。（这其实很好理解，如果每个对象都存储着自己能执行的方法，那么同一个类的多个对象的方法就会重复存在，这样无疑会造成冗余的空间占用）。

当一个对象的实例方法调用的时候，会通过 `isa` 查找它对应的类，然后在该类的 `class_data_bits_t` 中查找方法（具体查找过程后面会有）。当该类中无法找到方法的时候会通过 `super_class` 这个指针去父类中查找。

对于类来说我们通过上面的源码知道了它也是一种对象，可以称之为类对象。那类对象的方法就要去它对应的类中查找，这个类就称之为元类（`Meta Class`）。

下面这个图片中大家可以很清晰的看到 *对象*、*类*、*元类* 之间的关系。

![](./image/23.png)

上图中的关系已经很清晰了，有几个需要注意的点。

- 所有 `meta class` 的 `isa` 指向 `Root class`(也就是`NSObject`) 的 `meta class`。包括 `NSObject` 的 `meta class`。
- `NSObject` 的 `meta class` 的 `super_class` 是 `NSObject` 的类。

更多信息可以查看 [ What is a meta-class in Objective-C?](http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html)

## `cache_t`

下面是 `cache_t` 的定义简化后的代码

```
// objc-runtime-new.h line 59
struct cache_t {
    struct bucket_t *_buckets;
    mask_t _mask;
    mask_t _occupied;
}

// objc-runtime-new.h line 37
struct bucket_t {
    cache_key_t _key;
    MethodCacheIMP _imp; // using MethodCacheIMP = IMP;
}

// objc-runtime-new.h line 28
typedef uint32_t mask_t; // unsigned int

// objc-runtime-new.h line 32
typedef uintptr_t cache_key_t; // unsigned long
```

通过源码(objc-cache.mm line 243-637)可以看出 

- `cache_t`： 其实是一个散列表，以 `SEL` 为 `key` 储存 `SEL+IMP`。
- `_buckets`： 是一个数组，它里面放的是 `bucket_t`。会随着加入数据的增多而进行扩容。
- `_mask`： 已经分配内存空间 `_buckets` 的总数减一。用于 hash 计算。
- `_occupied`： 表示是已经缓存的 `buckets` 数量。

下面我们来看一下两个关键函数。

```
// objc-cache.mm line 524 
// 根据 key 查找对应的 bucket_t
bucket_t * cache_t::find(cache_key_t k, id receiver)
{
    assert(k != 0);

    // 找到 _buckets
    bucket_t *b = buckets();
    // 找到 _mask
    mask_t m = mask();

    // 获取 k 对应的 hash 值
    mask_t begin = cache_hash(k, m);
    // 下面是通过线性探测的方法来查找,所以该方法会返回找到的 key 对应的 bucket_t，找不到就返回数组中最后为空的那个位置。
    mask_t i = begin;
    do {
        if (b[i].key() == 0  ||  b[i].key() == k) {
            return &b[i];
        }
    } while ((i = cache_next(i, m)) != begin);

    // 报错
    // hack
    Class cls = (Class)((uintptr_t)this - offsetof(objc_class, cache));
    cache_t::bad_cache(receiver, (SEL)k, cls);
}
```

```
// objc-cache.mm line 561 
// 这是存数据的方法，需要传入 cls 类、sel 方法名、imp 方法实现、receiver 方法接收者
static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)
{
    cacheUpdateLock.assertLocked();

    // Never cache before +initialize is done
    if (!cls->isInitialized()) return;

    // 先看一下是否已经存在缓存
    // Make sure the entry wasn't added to the cache by some other thread 
    // before we grabbed the cacheUpdateLock.
    if (cache_getImp(cls, sel)) return;

    cache_t *cache = getCache(cls);
    cache_key_t key = getKey(sel);

    // hash 表的装载因子小于 3/4 的时候存入，否则进行扩容
    // Use the cache as-is if it is less than 3/4 full
    mask_t newOccupied = cache->occupied() + 1;
    mask_t capacity = cache->capacity();
    if (cache->isConstantEmptyCache()) {
        // Cache is read-only. Replace it.
        cache->reallocate(capacity, capacity ?: INIT_CACHE_SIZE);
    }
    else if (newOccupied <= capacity / 4 * 3) {
        // Cache is less than 3/4 full. Use it as-is.
    }
    else {
        // Cache is too full. Expand it.
        cache->expand();
    }

    // 来到这里能保证装载因子小于 3/4.
    // Scan for the first unused slot and insert there.
    // There is guaranteed to be an empty slot because the 
    // minimum size is 4 and we resized at 3/4 full.
    bucket_t *bucket = cache->find(key, receiver);
    // 根据上面 find 函数的分析可以看出这个 bucket 里的内容是可能为空的。这就是找不到当前 key 对应的值，这种情况下返回一个空白的 bucket，因此这时候需要添加 _occupied 数量，然后将其存入散列表中
    if (bucket->key() == 0) cache->incrementOccupied();
    bucket->set(key, imp);
}
```

上面分析了 `cache_t` 的实现，其实 `cache` 的作用就是缓存调用过的方法，这样以来查找方法的时候先去 `cache` 中查找，找不到了再去方法列表找，这样就提高查找方法的效率。

## `class_data_bits_t` 和 `class_rw_t *data()`

通过对比新旧两版的 `objc_class` 的实现，可以看出来 `isa`、`superclass`、`cache` 这些基本是相同的。但是旧版本中的 `ivars`、`methodLists` 都找不到了，那我们猜测可以通过 `class_data_bits_t` 和 `class_rw_t *data()` 函数找到他们。

```
// objc-runtime-new.h line 869
struct class_data_bits_t {
    // Values are the FAST_ flags above.
    uintptr_t bits;

    // line 922
    class_rw_t* data() {
        return (class_rw_t *)(bits & FAST_DATA_MASK);
    }
}
```

可以看出 `class_data_bits_t` 结构体中只包含一个 `unsigned long` 类型的 `bits`。它占有 64 位空间。将 `bits` 与 `FAST_DATA_MASK` 做位运算后，转化为 `class_rw_t *` 返回。

`FAST_DATA_MASK` 是个 16 进制的数，转化为二进制就是`11111111111111111111111111111111111111111111000` 长度为 47 位。因此返回的信息就是 [3 47]之间的数据。

> 在 x86_64 架构上，Mac OS 只使用了其中的 47 位来为对象分配地址。而且由于地址要按字节在内存中按字节对齐，所以掩码的后三位都是 0。
> 因为 class_rw_t * 指针只存于第 [3, 47] 位，所以可以使用最后三位来存储关于当前类的其他信息

| 63-48 | 47-3            | 2            | 1             | 0             |
| ----- | --------------- | ------------ | ------------- | ------------- |
| extra | class_rw_t data | hasDefaultRR | isSwiftStable | isSwiftLegacy |

我们看一下 `FAST_DATA_MASK` 的定义。

(在查找 `FAST_DATA_MASK` 定义的时候，你会发现它的周围有很多类似的定义，根据宏 `__LP64__` 来判断到底编译哪个。关于 `__LP64__` 的更多信息可以看[这里](https://stackoverflow.com/questions/6721037/where-is-lp64-defined-for-default-builds-of-c-applications-on-osx-10-6)。你可以通过在终端中通过 `cpp -dM /dev/null` 命令来查看宏定义的列表。我看了一下是`#define _LP64 1`。 毕竟是64位的机器。。)

```
// objc-runtime-new.h line 485 
// Leaks-compatible version that steals low bits only.

// class or superclass has .cxx_construct implementation
#define RW_HAS_CXX_CTOR       (1<<18)
// class or superclass has .cxx_destruct implementation
#define RW_HAS_CXX_DTOR       (1<<17)
// class or superclass has default alloc/allocWithZone: implementation
// Note this is is stored in the metaclass.
#define RW_HAS_DEFAULT_AWZ    (1<<16)
// class's instances requires raw isa
#define RW_REQUIRES_RAW_ISA   (1<<15)

// class is a Swift class from the pre-stable Swift ABI
#define FAST_IS_SWIFT_LEGACY    (1UL<<0)
// class is a Swift class from the stable Swift ABI
#define FAST_IS_SWIFT_STABLE    (1UL<<1)
// class or superclass has default retain/release/autorelease/retainCount/
//   _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference
#define FAST_HAS_DEFAULT_RR     (1UL<<2)
// data pointer
#define FAST_DATA_MASK          0x00007ffffffffff8UL
```

这些都是标志位，利用空闲的空间来存储关于当前类的一些信息。比如下面这些是 与 `bits` 进行按位与运算来获取。其他的则通过与 `class_rw_t` 中的 `flags` 按位与运算获取。

```
// FAST_DATA_MASK
0000 0000 0000 0000 0111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1000
// FAST_IS_SWIFT_LEGACY
0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001
// FAST_IS_SWIFT_STABLE
0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0010
// FAST_HAS_DEFAULT_RR
0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0100
```

综合上面的内容我们可以看出来 `class_data_bits_t` 结构体主要作用就是存储 `class_rw_t` 的地址及一些当前类的信息。更多的信息还是在 `class_rw_t` 中。

## `class_rw_t` 和 `class_ro_t`

```
// objc-runtime-new.h lina 826
struct class_rw_t {
    // Be warned that Symbolication knows the layout of this structure.
    uint32_t flags; // 一些类相关的标志位，更多的内容可以看 line 390
    uint32_t version;

    const class_ro_t *ro;

    method_array_t methods;
    property_array_t properties;
    protocol_array_t protocols;

    Class firstSubclass;
    Class nextSiblingClass;

    char *demangledName;
}
```

```
// objc-runtime-new.h lina 553
struct class_ro_t {
    uint32_t flags;
    uint32_t instanceStart;
    uint32_t instanceSize;
    uint32_t reserved;

    const uint8_t * ivarLayout;
    
    const char * name;
    method_list_t * baseMethodList;
    protocol_list_t * baseProtocols;
    const ivar_list_t * ivars;

    const uint8_t * weakIvarLayout;
    property_list_t *baseProperties;

    method_list_t *baseMethods() const {
        return baseMethodList;
    }
};
```
