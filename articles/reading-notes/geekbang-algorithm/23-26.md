# 23 二叉树基础 | 上

## 树的概念

                                   ↑高度    ↓深度    →层
                   A                3       0       1
               ╱       ╲
              B         C           2       1       2
           ╱  |  ╲     ╱ ╲
          D   E   F   G   H         1       2       3
         ╱   ╱ ╲   ╲
        I   J   K   L               0       3       4

- 节点：树中的每个元素，如 A, B, C, D...
- 父子关系：相邻节点的关系，如 A - B, A - C
- 父节点：A 节点就是 B、C 的父节点
- 子节点：B、C 就是 A 的子节点
- 兄弟节点：D、E、F 之间称为兄弟节点，F 和 G 就不是兄弟节点
- 根节点：没有父节点的节点，如 A
- 叶子节点：没有子节点的节点，如 G、I、J
- **节点高度**：节点到叶子节点的最长路径，如 A 节点的高度就是 A 到 I 的长度，为 3
- **节点深度**：根节点到该节点所经历的边的个数，如 E 节点的深度就是 E 到 A 的边的个数，为 2
- **节点层**：节点的深度 +1
- **树的高度**：根节点的高度

## 二叉树

每个节点最多有两个子节点，分别称为**左节点**和**右节点**

- **满二叉树**：除了叶子节点外，每个节点都有左右节点的二叉树
- **完全二叉树**：如下所示，叶子节点都在最下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数要达到最大

完全二叉树

                A
             ╱     ╲
            B       C
          ╱   ╲    ╱ ╲
         D     E  F   G
        ╱ ╲   ╱
       H   I J

### 二叉树的存储
- **链式存储法**：通过类似链表的结构存储，每个节点有三个字段
  - data：存储数据
  - left：左侧子节点的指针
  - right：右侧子节点的指针
- 基于数组的**顺序存储法**：按照层数将一层数据从左到右存入数组后接着存储下一层
  - 根节点存储在数组中 1 的位置
  - 第 i 层 第 k 个节点存储在 (i - 1) * 2 + (k - 1) 的位置
  - 如果某个节点存储在 j 的位置，则其左子节点存储位置就是 j * 2，右节点存储的位置就是 j * 2 + 1，父节点就在 j / 2 的位置。

由于完全二叉树的特性，它可以使用数组存储而不浪费空间。

## 二叉树遍历
            A
          ╱   ╲
         B     C
        ╱ ╲   ╱ ╲
       D   E F   G

- 前序遍历
  - 对于树的任意节点来说，先打印这个节点，然后在再印它的左子树，最后打印它的右子树
  - 如：A -> B -> D -> E -> C -> F -> G
- 中序遍历
  - 对于树的任意节点来说，先打印它的左子树，然后再打印这个节点，最后打印它的右子树
  - 如：D -> B -> E -> A -> F -> C -> G
- 后续遍历
  - 对于树的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点
  - 如：D -> E -> B -> F -> G -> C -> A

```
void preOrder(Node* root) {
  if (root == null) return;
  print root // 此处为伪代码，表示打印 root 节点
  preOrder(root->left);
  preOrder(root->right);
}

void inOrder(Node* root) {
  if (root == null) return;
  inOrder(root->left);
  print root // 此处为伪代码，表示打印 root 节点
  inOrder(root->right);
}

void postOrder(Node* root) {
  if (root == null) return;
  postOrder(root->left);
  postOrder(root->right);
  print root // 此处为伪代码，表示打印 root 节点
}
```

遍历二叉树的时间复杂度就是 O(n).

# 24 二叉树基础 | 下

## 二叉查找树

**二叉查找树中，任意一个节点，其左子树的每个节点的值都小于该节点，而右子树的值都大于这个节点**

                13
             ╱      ╲
            10       16
          ╱    ╲    ╱ 
         9     11  14 

### 二叉查找树的查找操作

- 查找的值小于当前节点就在左子树中查找
- 查找的值大于当前节点就在右子树中查找
- 否则说明当前查找的就是当前节点

### 二叉查找树的插入操作

- 从根节点开始，依次比较要插入的数据和节点的大小关系
- 如果要插入的数据比节点的数据大
  - 节点的右子树为空，就将新数据直接插到右子节点的位置
  - 节点的右子树不为空，就再递归遍历右子树，查找插入位置。
- 如果要插入的数据比节点数值小，
  - 节点的左子树为空，就将新数据插入到左子节点的位置
  - 节点的左子树不为空，就再递归遍历左子树，查找插入位置。

### 二叉查找树的删除操作

- 如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null
- 如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了
- 如果要删除的节点有两个子节点，这就比较复杂了。
  - 我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上
  - 然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了）

LeetCode 450

```
struct TreeNode* deleteNode(struct TreeNode* root, int key) {
    // 首先查找要删除的节点和他的父节点
    struct TreeNode *node = root;
    struct TreeNode *parentNode = NULL;
    while (node != NULL) {
        if (node->val < key) {
            parentNode = node;
            node = node->right;
        } else if (node->val > key) {
            parentNode = node;
            node = node->left;
        } else {
            break;
        }
    }
    // 没有找到，直接返回
    if (node == NULL) return root;
    
    // 查找的节点左右子节点都不为空
    if (node->left != NULL && node->right != NULL) {
        // 查找右子树中的最小值和它的父节点
        struct TreeNode *minNode = node->right;
        struct TreeNode *minParentNode = node;
        while (minNode->left != NULL) {
            minParentNode = minNode;
            minNode = minParentNode->left;
        }
        // 将最小值赋值给要删除的节点
        node->val = minNode->val;
        // 标记要删除的节点为最小值的节点，由于最小值节点一定是叶子节点，这样以来要删除的节点就被换到了叶子节点上
        node = minNode;
        parentNode = minParentNode;
    } 
    
    // 获取要删除节点的子节点，由于上面节点左右子节点都不为空的节点被替换到了叶子节点上，因此左右子节点最多只会有一个不为空
    struct TreeNode *child = NULL;
    if (node->left != NULL) {
        child = node->left;
    } else if (node->right != NULL) {
        child = node->right;
    }
    
    // 父节点为空，说明是根结点
    if (parentNode == NULL) {
        root = child;
    } else if (parentNode->left == node) {
        parentNode->left = child;
    } else {
        parentNode->right = child;
    }
    
    return root;
}
```

### 二叉查找树的其他操作

- 快速地查找最大节点和最小节点、前驱节点和后继节点。
- 中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效

## 支持重复数据的二叉查找树

有以下两种处理方式
- 二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。
- 每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。

## 二叉查找树的时间复杂度分析

**时间复杂度其实都跟树的高度成正比，也就是 O(height)**

最坏情况下二叉树退化为链表，因此查找的时间复杂度就为 O(n)
最好情况下二叉树是完全二叉树或者满二叉树，这时候高度最小，查找的时间复杂度最低

### 如何求 n 个节点的完全二叉树的高度

第 k 层满二叉树节点个数为 2^(k - 1)

对于完全二叉树来说，假设最大层数是 L，最后一层节点的个数大于等于 1，小于等于 2^(L - 1),根据等差数列求和公式可以得到以下关系

```
n >= 1+2+4+8+...+2^(L-2)+1
n <= 1+2+4+8+...+2^(L-2)+2^(L-1)
```
这样可以求出 L 的取值范围是 [log2(n+1), log2n +1]。

因此可以看出完全二叉树的高度小于等于 log2n。

## 散列表与二叉树的优缺点

> 第一，散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。
>
>第二，散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。
>
>第三，笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。
>
>第四，散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。
>
>最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。
>
>综合这几点，平衡二叉查找树在某些方面还是优于散列表的，所以，这两者的存在并不冲突。我们在实际的开发过程中，需要结合具体的需求来选择使用哪一个。

## 计算二叉树的高度

LeetCode 104

```
int maxDepth(struct TreeNode* root) {
    if (root == NULL) return 0;
    int leftD = maxDepth(root->left);
    int rightD = maxDepth(root->right);
    return (leftD > rightD ? leftD : rightD) + 1;
}
```

# 25 红黑树 | 上

## 平衡二叉查找树

- 严格定义：**二叉树中任意节点的左右子树的高度相差不大于1**
- 完全二叉树、满二叉树都是平衡二叉树。
- 平衡的概念：**整棵树的左右子树都比较平衡，不会出现一边高很多，一边矮很多**。这样以来整个树的高度会更低，查找、删除、插入的效率会更高。

## 红黑树定义

- 节点分为红色和黑色
- 根节点是黑色
- 每个叶子节点都是黑色的空节点，不存储数据
- 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
- 从每个节点到达其叶子节点的路径上都包含相同的黑色节点

## 红黑树的高度

1. 首先将红色节点去除，红色节点的子节点以其祖父节点的作为父节点
2. 去掉之后形成一个四叉树
3. 由于红黑树上从每个节点到达其叶子节点的路径上都包含相同的黑色节点，这样将这个四叉树上的大于两个的节点取出来，放到叶子节点上就形成了完全二叉树
4. 因此上面的四叉树的高度一定低于这个完全二叉树
5. 因为完全二叉树的高度近似 log2n ,因此四叉树的高度小于 log2n
6. 由于红色节点被黑色节点隔离，因此加上红色节点的红黑树的高度不会大于 2 * log2n

## 红黑树的优点

红黑树是一个近似平衡的二叉树，维护成本相较于严格平衡定义的 AVL 树低了很多。所以，红黑树的插入、删除、查找各种操作性能都比较稳定。

**红黑树的高度近似 log2n，所以它是近似平衡，插入、删除、查找操作的时间复杂度都是 O(logn)。**

## 动态数据结构

> 动态数据结构是支持动态的更新操作，里面存储的数据是时刻在变化的，通俗一点讲，它不仅仅支持查询，还支持删除、插入数据。而且，这些操作都非常高效。如果不高效，也就算不上是有效的动态数据结构了。所以，这里的红黑树算一个，支持动态的插入、删除、查找，而且效率都很高。链表、队列、栈实际上算不上，因为操作非常有限，查询效率不高。

>- 散列表：插入删除查找都是O(1), 是最常用的，但其缺点是不能顺序遍历以及扩容缩容的性能损耗。适用于那些不需要顺序遍历，数据更新不那么频繁的。
>- 跳表：插入删除查找都是O(logn), 并且能顺序遍历。缺点是空间复杂度O(n)。适用于不那么在意内存空间的，其顺序遍历和区间查找非常方便。
>- 红黑树：插入删除查找都是O(logn), 中序遍历即是顺序遍历，稳定。缺点是难以实现，去查找不方便。其实跳表更佳，但红黑树已经用于很多地方了。

# 26 红黑树 | 下
                |                             |
                X                             Y
             ╱     ╲         左旋           ╱     ╲
            a       Y         ->          X       r
                   ╱ ╲                   ╱ ╲
                  b   r                 a   b


                |                             |
                X                             Y
             ╱     ╲         右旋           ╱     ╲
            Y       r         ->          a       X
           ╱ ╲                                   ╱ ╲
          a   b                                 b   r