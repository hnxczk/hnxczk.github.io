# 23 二叉树基础 | 上

## 树的概念

                                   ↑高度    ↓深度    →层
                   A                3       0       1
               ╱       ╲
              B         C           2       1       2
           ╱  |  ╲     ╱ ╲
          D   E   F   G   H         1       2       3
         ╱   ╱ ╲   ╲
        I   J   K   L               0       3       4

- 节点：树中的每个元素，如 A, B, C, D...
- 父子关系：相邻节点的关系，如 A - B, A - C
- 父节点：A 节点就是 B、C 的父节点
- 子节点：B、C 就是 A 的子节点
- 兄弟节点：D、E、F 之间称为兄弟节点，F 和 G 就不是兄弟节点
- 根节点：没有父节点的节点，如 A
- 叶子节点：没有子节点的节点，如 G、I、J
- **节点高度**：节点到叶子节点的最长路径，如 A 节点的高度就是 A 到 I 的长度，为 3
- **节点深度**：根节点到该节点所经历的边的个数，如 E 节点的深度就是 E 到 A 的边的个数，为 2
- **节点层**：节点的深度 +1
- **树的高度**：根节点的高度

## 二叉树

每个节点最多有两个子节点，分别称为**左节点**和**右节点**

- 满二叉树：除了叶子节点外，每个节点都有左右节点的二叉树
- 完全二叉树：如下所示，叶子节点都在最下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数要达到最大

完全二叉树

                A
             ╱     ╲
            B       C
          ╱   ╲    ╱ ╲
         D     E  F   G
        ╱ ╲   ╱
       H   I J

### 二叉树的存储
- 链式存储法：通过类似链表的结构存储，每个节点有三个字段
  - data：存储数据
  - left：左侧子节点的指针
  - right：右侧子节点的指针
- 基于数组的顺序存储法：按照层数将一层数据从左到右存入数组后接着存储下一层
  - 根节点存储在数组中 1 的位置
  - 第 i 层 第 k 个节点存储在 (i - 1) * 2 + (k - 1) 的位置
  - 如果某个节点存储在 j 的位置，则其左子节点存储位置就是 j * 2，右节点存储的位置就是 j * 2 + 1，父节点就在 j / 2 的位置。

由于完全二叉树的特性，它可以使用数组存储而不浪费空间。

## 二叉树遍历
            A
          ╱   ╲
         B     C
        ╱ ╲   ╱ ╲
       D   E F   G

- 前序遍历
  - 对于树的任意节点来说，先打印这个节点，然后在再印它的左子树，最后打印它的右子树
  - 如：A -> B -> D -> E -> C -> F -> G
- 中序遍历
  - 对于树的任意节点来说，先打印它的左子树，然后再打印这个节点，最后打印它的右子树
  - 如：D -> B -> E -> A -> F -> C -> G
- 后续遍历
  - 对于树的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点
  - 如：D -> E -> B -> F -> G -> C -> A

```
void preOrder(Node* root) {
  if (root == null) return;
  print root // 此处为伪代码，表示打印 root 节点
  preOrder(root->left);
  preOrder(root->right);
}

void inOrder(Node* root) {
  if (root == null) return;
  inOrder(root->left);
  print root // 此处为伪代码，表示打印 root 节点
  inOrder(root->right);
}

void postOrder(Node* root) {
  if (root == null) return;
  postOrder(root->left);
  postOrder(root->right);
  print root // 此处为伪代码，表示打印 root 节点
}
```

遍历二叉树的时间复杂度就是 O(n).



