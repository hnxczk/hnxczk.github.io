## 18 散列表（上）

### 定义

#### 键 
用来标识元素
#### 散列函数
将键转化为数组下标的映射方法
#### 散列值
通过散列函数获取的值
#### 散列表
散列表是数组的一种扩展，通过使用散列函数将键值映射为下标，然后将数据存储在数组中对应下标的位置，这样就能使用数组支持随机访问数据的特性来实现快速查找删除等操作。

### 散列函数

基本要求

1. 散列函数计算得到的散列值是一个非负整数
2. 如果 key1 = key2，那 hash(key1) == hash(key2)
3. 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)

### 散列冲突
当 key1 ≠ key2，hash(key1) = hash(key2) 这种情况就称为散列冲突

#### 开放寻址法
开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。

##### 线性探测
当插入数据的时候，如果通过散列函数得到的位置上已经被占用，就从当前位置开始，依次往后查找，如果查到尾部还没有就从头部查找，直到查到空闲位置为止。

查找数据的时候，先通过散列函数获取下标，然后从下标开始依次往后查找，直到查到空闲位置，则说明没有要查找的元素。

删除数据的时候，找到数据后删除数据并标识为已经删除，这样在查找的时候找到标记删除的空白空间还是继续向下查找。

#### 二次探测
线性探测是依次往下查找，二次探测的步长是二次方

hash(key)+0，hash(key)+1^2，hash(key)+2^2 ......

#### 双重散列

使用一组散列函数，第一个得到的位置被占用则用第二个散列函数计算位置，依次类推，直到查到空闲的位置

### 装载因子

> 散列表的装载因子 = 填入表中的元素个数 / 散列表的长度

装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降.

#### 链表法

这个时候数组中存放的不再是简单的值了，而是一条链表，相同散列值的元素都存放到链表中。

插入数据的时候，直接插入到对应链表即可，时间复杂度是 O(1).

查找删除元素的时候，事件复杂度跟链表的长度 k 成正比，也就是 O(k).

## 19 散列表（中）
### 工业级散列表要求
1. 支持快速的查询、插入、删除操作；
2. 内存占用合理，不能浪费过多空间；
3. 性能稳定，在极端情况下，散列表的性能也不会退化到无法接受的情况。

### 如何设计散列表

1. 设计一个合适的散列函数；
2. 定义装载因子阈值，并且设计动态扩容策略；
3. 选择合适的散列冲突解决方法。

### 如何设计散列函数
1. 要尽可能让散列后的值随机且均匀分布，这样会尽可能减少散列冲突，即便冲突之后，分配到每个槽内的数据也比较均匀。
2. 除此之外，散列函数的设计也不能太复杂，太复杂就会太耗时间，也会影响到散列表的性能。
3. 常见的散列函数设计方法：直接寻址法、平方取中法、折叠法、随机数法等。

### 如何根据装载因子动态扩容

#### 确定合适的装载因子阈值
装载因子阈值的设置要权衡时间、空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值；相反空间紧张，对执行效率要求不高则可以增加负载因子，甚至可以大于 1。

#### 避免低效的扩容
通过分批扩容进行优化

- 分批扩容的插入操作：当有新数据要插入时，我们将数据插入新的散列表，并且从老的散列表中拿出一个数据放入新散列表。每次插入都重复上面的过程。这样插入操作就变得很快了。
- 分批扩容的查询操作：先查新散列表，再查老散列表。
- 通过分批扩容这种均摊的方式，将一次扩容的代价均摊到多次插入操作中，避免了一次扩容耗时过多的情景，这样以来任何情况下，插入一个数据的时间复杂度都是O(1)。

### 如何选择冲突解决方法

#### 开放寻址法
当数据比较小，装载因子小的时候，适用开放寻址法
#### 链表法
基于链表的散列冲突处理方法比较适存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。


