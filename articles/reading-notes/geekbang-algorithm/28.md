# 堆和堆排序

## 堆

### 定义
- 堆是一种特殊的树
- **堆是一个完全二叉树**
- **堆中的每个节点的值必须大于（小于）等于其子树中每个节点的值**
- 大顶堆：每个节点的值大于等于其子节点的值
- 小顶堆：每个节点的值小于等于其子节点的值

### 堆的实现

由于堆是完全二叉树因此适合用数组来存储

数组中下标为 i 的节点的左子节点就是下标为 ix2 的节点，右子节点就是下标为 ix2 + 1 的节点，父节点就是下标为 i/2 的节点。

### 堆的操作

#### 插入（大顶堆）

1. 将要插入的元素放到存储堆的数组的末尾
2. 进行堆化（从下往上）
   1. 将插入的 i 节点与其父节点 i/2 对比大小
   2. 如果 i 节点大于父节点的值就交换两个节点
   3. 重复上面的比较操作直到父子关系满足大顶堆的要求

#### 删除堆顶元素（大顶堆）

1. 删除堆顶元素
2. 将最后一个节点放到堆顶
3. 进行堆化（从上到下）
   1. 定义 i = 1，表明是堆顶
   2. 比较 i 节点与子节点的大小，如果子节点全都小于 i 节点，说明堆化完成
   3. 否则将 i 节点与其子节点中较大的那个交换
   4. 让 i 等于子节点中较大的那个，继续 2，3 操作

#### 复杂度分析

由于上面主要的操作就在于堆化，而堆化就是顺着节点的路径进行比较和替换，因此堆化的复杂度取决于树的高度，因此插入和删除堆顶元素的时间复杂度就是 O(logn)。

## 堆排序

堆排序不是稳定排序算法，时间复杂度是 O(nlogn)，并且是原地算法。

### 步骤

#### 1. 建堆

- 思路 1 ：在堆中插入元素
    1. 起始的时候将数组中的第一个元素看成是一个起始堆
    2. 将下标从 2 到 n 的数据依次插入堆中
- 思路 2 ：从后往前处理数据，挨个进行堆化
    1. 由于叶子节点不能往下堆化，因此略过
    2. 从第一个非叶子节点 n/2（也就是最后一个元素 n 的父节点）开始堆化
    3. 然后依次对 n/2 到 1 的数据进行堆化

##### 思路 2 的时间复杂度

1. 每个节点堆化的过程跟需要比较和交换的节点个数相关，而这个个数又跟节点的高度 k 成正比
2. 对于堆来说
   - 第 1 层节点个数为 1， 高度为 k
   - 第 2 层节点个数为 2， 高度为 k-1
   - 第 3 层节点个数为 2^2， 高度为 k-2
   - ...
   - 第 i-1 层节点个数为 2^i， 高度为 k-i
   - ...
   - 第 k 层节点个数为 2^k-1， 高度为 1

    综上可以看出所有堆化需要进行的比较和交换个数就是
    
    ```
    s = 1*k + 2*(k-1) + 2^2*(k-2) + ... + 2^i*(k-i) + ... + 2^(k-1)*1
    ```
3. 经过求解上面的公式得出
    
    ```
    s = 2^(k+1) - k - 2
    ```
4. 高度 k = log2n， 因此可以看出 s = O(n)
5. 因此建堆的复杂度就是 O（n）

#### 排序

1. 建堆结束后，数组中的数据就是大顶堆了，堆顶元素就是最大值
2. 将堆顶元素与最后一个元素交换，代表已经排好一个位置
3. 对剩余的元素进行堆化，然后继续 2 操作
4. 当堆中元素个数为 1，代表已经完成排序

##### 复杂度分析

我们可以看出耗时的操作主要是进行堆化的操作，因此每次堆化的复杂度就是 O(logn)，又由于需要每个元素排好后都需要进行堆化，因此整体复杂度就是 O(nlogn).

### 堆排序复杂度

由上可以看出堆排序主要分为两步：建堆（复杂度为 O(n)）、排序（复杂度为 O(nlogn)）。因此排序整体复杂度就是 O(nlogn)。

## QA

1. 堆排序性能为什么低于快排

    1. 堆排序的数据是跳动访问的，相较于快排中局部顺序访问的情况，不利于 CPU 的缓存。
    2. 同样的数据，堆排序交换次数要多于快排，尤其是当要排序的数据的有序度较高的情况下。

2. 为什么对于完全二叉树，下标从 n/2+1 到 n 都是叶子节点

    如果最后一个元素的下标是 n ，则其父节点的下标就是 n/2。因此 n/2+1 到 n 都是叶子节点。

