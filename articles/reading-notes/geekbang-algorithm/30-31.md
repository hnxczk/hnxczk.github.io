# 图的表示

## 图的定义

- 顶点：图中的每个元素
- 边：图中顶点之间的连接关系
- 度：某个顶点相连接的边的条数
- 方向：两个顶点的指向
- 有向图和无向图：顶点之间有方向的就是有向图，否则就是无向图
- 入度：（有向图才有）指向某个顶点的边的个数
- 出度：（有向图才有）以某个顶点为起点的边的个数
- 带权图：每条边都有权重的图就是带权图

## 图的存储

### 邻接矩阵存储

邻接矩阵的底层是一个二维数组。

1. 无向图：如果图中顶点 i 和 j 之间有边，则在 A[i][j] 和 A[j][i] 标记为 1
2. 有向图：若顶点 i 有 指向 顶点 j 的边，则在 A[i][j] 标记为 1
3. 带权无向图和带权有向图：与上面情况类似，不过标记的是边的权重

#### 优点

1. 存储方式简单，读取高效
2. 方便计算，可以将计算转换成矩阵的运算

#### 缺点

1. 耗费空间

### 邻接表存储

邻接表与散列表类似

1. 将所有顶点依次存储于数组中，每个顶点都有一个链表与之对应。
2. 链表中存储的是与这个顶点连接的其他顶点。
   1. 有向图：链表中存储的是以该顶点为起点指向的顶点
   2. 无向图；链表中存储的是与该顶点连接的顶点

#### 优点

1. 节省空间

#### 缺点

1. 由于是靠链表存储顶点之间的关系，对缓存不友好
2. 查询两个顶点之间的关系效率较低

#### 改进

可以通过将链表替换成平衡二叉树、红黑树，以及跳表等动态数据结构提高性能

## QA 如何存储社交平台好友关系

### 微博用户关系支持的操作

- 判断用户 A 是否关注了用户 B
- 判断 A 是否是 B 的粉丝
- A 关注 B
- A 取消关注 B
- 根据用户名的首字母排序，分页获取用户的粉丝列表
- 根据用户名的首字母排序，分页获取用户的关注列表

### 实现思路

1. 通过上面可以看出来用户关系是一个有向图
2. 使用邻接表存储用户的关注关系，记录的是该顶点指向的顶点。可以查出用户关注列表
3. 使用逆邻接表存储用户的被关注关系，记录的是指向该顶点的顶点。可以查出用户的被关注列表

### 改进

#### 1. 使用跳表替代基础的邻接表

- 基础邻接表在查找用户之间关注关系的时候较为低效
- 跳表插入删除查找等操作都非常高效
- 又由于跳表本身存储的就是有序数据，因此在分页获取关注粉丝数据的时候就十分高效

#### 2. 对于较大规模的数据通过使用哈希算法将数据分片

# 深度和广度优先搜索


