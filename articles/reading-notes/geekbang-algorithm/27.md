# 递归树

递归的思想就是将大的问题分解成小的问题，直到分解到递归基础。如果将分解的过程画出来就是一颗树型结构，称之为**递归树**。

## 使用递归树来分析递归的时间复杂度

1. 根据递推公式画出分解过程
2. 计算每一层的时间消耗
3. 计算递归树的高度
4. 整体时间复杂度就是每一层的时间消耗的和

## 时间复杂度分析实例

### 1. 归并排序

1. 递归树

                 m(n)
             ╱         ╲
         m(n/2)         m(n/2)
          ╱   ╲         ╱    ╲
       m(n/4) m(n/4)  m(n/4) m(n/4) 
        ....

2. 每层时间消耗

    由于归并排序最耗时的就是归并操作，因此每层的时间消耗就是归并操作的个数。由于每一层需要进行归并操作的个数都是一样的都记为 n

3. 递归树高度

    归并排序的递归树是一颗满二叉树，其高度约为 log2n

4. 计算复杂度

    由以上两步可以得出时间复杂度等于：O(nlogn)

### 2. 快速排序

1. 递归树

    由于快速排序的时间复杂度与分区点的选择有很大关系。最好情况下每次分区都能一分为二，这样就类似于归并排序，时间复杂度就是 O(nlogn)。

    我们假设平均情况下每次分区后分区的大小比例为 1：k， k = 9 的情况下

                         q(n)
                ╱                     ╲
             q(n/10)                 q(9n/10)
           ╱         ╲              ╱        ╲
       q(n/10^2)  q(9n/10^2)  q(9n/10^2)   q(9^2n/10^2)
        ....

2. 每层时间消耗

    由于快速排序中每层都需要遍历分区的所有数据，因此每层的时间消耗就是 n

3. 递归树高度

    - 最短路径：从根节点 n 到叶子节点 1，递归树每次乘以 1/10，因此最短路径 h = log10 n
    - 最长路径：从根节点 n 到叶子节点 1，递归树每次乘以 9/10, 因此最长路径 h = log(10/9) n

    我们知道对于对数来说不管是多少为底都统一算做 logn，因此递归树的高度近似于 logn

4. 计算复杂度

    由以上两步可以得出时间复杂度等于：O(nlogn)

### 3. 斐波那契数列

    f(n) = f(n-1) + f(n-2)

1. 递归树

                         f(n)
                ╱                     ╲
             f(n-1)                   q(n-2)
           ╱         ╲              ╱        ╲
       f(n-2)      f(n-3)       f(n-3)      f(n-4)
        ....

2. 每层时间消耗

    - 第 1 层到第 2 层                1
    - 第 2 层到第 3 层                2
    - 第 3 层到第 4 层                4
    - ...
    - 第 n-1 层到第 n 层              2^(n-1)

3. 递归树高度

    - 最长路径：从根节点 n 到叶子节点 1，递归树每次 -1，因此最短路径 h = n
    - 最短路径：从根节点 n 到叶子节点 1，递归树每次 -2, 因此最长路径 h = n/2

4. 计算复杂度

    - 所有路径都是最长路径，则根据等比数列求和公式，时间复杂度就是 2^n - 1
    - 所有路径都是最短路径，则根据等比数列求和公式，时间复杂度就是 2^(n/2) - 1

    这个算法的时间复杂度就介于 O(2n) 到 O(2^(n/2) - 1) 之间。是指数级的。

### 4. 完全排列（如何把 n 个数据的所有排列都找出来）

1. 递归树

    f(n) = n * f(n-1)

                          f(n)
                ╱          ...          ╲
             f(n-1)        ...         q(n-1)
           ╱        ╲      ...       ╱        ╲
       f(n-2)      f(n-2)  ...   f(n-2)      f(n-2)
        ....

2. 每层时间消耗

    - 第 1 层到第 2 层                n
    - 第 2 层到第 3 层                n(n-1)
    - 第 3 层到第 4 层                n(n-1)(n-2)
    - ...
    - 第 n-1 层到第 n 层              (n)!

3. 递归树高度

    - 最长路径：从根节点 n 到叶子节点 1，递归树每次 -1，因此最短路径 h = n
    - 最短路径：从根节点 n 到叶子节点 1，递归树每次 -2, 因此最长路径 h = n/2

4. 计算复杂度

    - 所有路径都是最长路径，则根据等比数列求和公式，时间复杂度就是 2^n - 1
    - 所有路径都是最短路径，则根据等比数列求和公式，时间复杂度就是 2^(n/2) - 1

    这个算法的时间复杂度就介于 O(2n) 到 O(2^(n/2) - 1) 之间。是指数级的。

### 5. 细胞分裂：1 个细胞的生命周期是 3 个小时， 1 小时分裂一次。求 n 小时后容器内有多少细胞

1. 递归树

    f(n) = 2 * f(n-1) - f(n-3)

                          f(n)
                ╱          |          ╲
              f(n-1)     f(n-1)        f(n-3)
           ╱    |    ╲      ...       
       f(n-2) f(n-2) f(n-4) ...  
        ....

2. 每层时间消耗

    - 第 1 层到第 2 层                1
    - 第 2 层到第 3 层                3
    - 第 3 层到第 4 层                9
    - ...
    - 第 n-1 层到第 n 层              3^(n-1)

3. 递归树高度

    - 从根节点 n 到叶子节点 1，递归树每次 -1，因此路径 h = n

4. 计算复杂度

    根据等比数列求和公式可以得出其时间复杂度为 O(3^n)
