# 数组

## 05 数组

### 定义

**数组是一种_线性表_数据结构。它用一组_连续的内存空间_来存储一组具有_相同类型_的数据。**

### 随机访问

数组支持随机访问，根据下标随机访问的时间复杂度是 O(1)。

#### 如何实现根据下标随机访问数组元素？

通过寻址公式，计算出该元素存储的内存地址：
```
a[i]_address = base_address + i * data_type_size
```

### 低效的“插入”和“删除”

#### 插入：
若有一元素想往 int[n] 的第 k 个位置插入数据，需要在 k-n 的位置往后移。

最好情况时间复杂度 O(1)
最坏情况复杂度为 O(n)
平均负责度为 O(n)

如果数组中的数据不是有序的，也就是无规律的情况下，可以直接把第 k 个位置上的数据移到最后，然后将插入的数据直接放在第 k 个位置上。这样时间复杂度就将为 O（1）了。

#### 删除：
与插入类似，为了保持内存的连续性。

最好情况时间复杂度 O(1)
最坏情况复杂度为 O(n)
平均负责度为 O(n)

提高效率：将多次删除操作中集中在一起执行，可以先记录已经删除的数据，但是不进行数据迁移，而仅仅是记录，当发现没有更多空间存储时，再执行真正的删除操作。这也是 JVM 标记清除垃圾回收算法的核心思想。

### 警惕数组的访问越界问题

数组越界在 C 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。 不同的语言对数组访问越界的处理方式不同，即便是同一种语言，不同的编译器处理的方式也不同。

### 容器与数组的选择

1. 存储基本数据类型，或者更关注性能可以使用数组
2. 数据大小已知，并且对数据的操作简单，可以使用数组
3. 多维数组的时候，数组更加直观
4. 业务开发，使用容器足够，开发框架，追求性能，首先数组

### 为什么大多数数组从 0 开始编号

1. 数组的根据下标访问元素是根据计算公式来计算内存偏移，从 0 开始更合理
2. 习惯问题

### JVM 标记清除算法
在标记阶段会标记所有的可访问的对象，在清除阶段会遍历堆，回收那些没有被标记的对象。现在想想，和「如果数组中的数据不是有序的，也就是无规律的情况下，可以直接把第k个位置上的数据移到最后，然后将插入的数据直接放在第k个位置上。」思想类似。

### 二维数组内存寻址

对于 `m * n` 的数组，`a [ i ][ j ] (i < m,j < n)`的地址为：
```
address = base_address + ( i * n + j) * type_size
```
