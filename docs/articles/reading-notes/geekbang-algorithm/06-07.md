# 链表

## 06 链表（上）

### 定义

通过指针将一组零散的内存块串联起来就构成了链表。

其中这些内存块称为**节点**，节点中记录链表下个节点地址的指针称为**后继指针**。

两个特殊节点：第一个节点称为**头结点**，最后一个节点称为**尾节点**，尾节点的后继节点是一个**空地址 NULL**

### 分类
1. 单链表 单链表的节点只包含一个存储数据的内存空间和后继指针 next
2. 双向链表 双向链表的节点包含一个存储数据的内存空间以及前驱指针 prev 和后继指针 next
3. 循环链表 尾节点的后继指针指向头节点的链表就是循环链表

### 双向链表的优点
链表遍历的时间复杂度是 O(n),在实际使用中双向链表可以减少链表的遍历操作。

### 链表与数组性能对比
#### 数组
- 随机访问 O(1) 插入删除 O(n)
- 实际使用中由于数组使用的是连续内存空间，可以借助 CPU 的缓存机制预读数组中的数据，因此访问效率更高。
- 数组扩容非常耗时
#### 链表
- 随机访问 O(n) 插入删除 O(1)
- 由于不是连续内存，对 CPU 缓存不太友好。
- 更容易造成内存碎片
- 对于 Java 来说还会导致频繁的垃圾回收。

### 基于链表实现 LRU 缓存淘汰算法

1. 当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。
2. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
3. 如果此数据没有在缓存链表中，又可以分为两种情况：
    * 如果此时缓存未满，则将此结点直接插入到链表的头部；
    * 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。


## 07 链表（下）

### 写链表代码的技巧

1. 理解指针或引用的含义

    将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。
2. 警惕指针丢失和内存泄漏
    - 插入结点时，一定要注意操作的顺序
    - 删除链表结点时，也一定要记得手动释放内存空间（自动管理内存的语言除外）
3. 利用哨兵简化实现难度

    链表中的“哨兵”节点是解决边界问题的，不参与业务逻辑。如果我们引入“哨兵”节点，则不管链表是否为空，head指针都会指向这个“哨兵”节点。
    
    我们把这种有“哨兵”节点的链表称为带头链表，相反，没有“哨兵”节点的链表就称为不带头链表。
4. 重点留意边界条件处理
    * 如果链表为空时，代码是否能正常工作？
    * 如果链表只包含一个结点时，代码是否能正常工作？
    * 如果链表只包含两个结点时，代码是否能正常工作？
    * 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？
5. 举例画图，辅助思考

6. 多写多练，没有捷径

### 常见链表题

* 单链表反转
* 链表中环的检测
* 两个有序的链表合并
* 删除链表倒数第 n 个结点
* 求链表的中间结点

### tips
- 利用 LeetCode 刷题

    LeetCode上的测试用例往往很全，能测试出特殊情况下的 bug
- 不用太纠结

    在一定时间内实在想不出来就去搜一下答案，没必要一直纠结。有些巧妙的解题思路确实不是很好想出来的。
