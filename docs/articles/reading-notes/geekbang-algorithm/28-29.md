# 堆和堆排序

## 堆

### 定义
- 堆是一种特殊的树
- **堆是一个完全二叉树**
- **堆中的每个节点的值必须大于（小于）等于其子树中每个节点的值**
- 大顶堆：每个节点的值大于等于其子节点的值
- 小顶堆：每个节点的值小于等于其子节点的值

### 堆的实现

由于堆是完全二叉树因此适合用数组来存储

数组中下标为 i 的节点的左子节点就是下标为 ix2 的节点，右子节点就是下标为 ix2 + 1 的节点，父节点就是下标为 i/2 的节点。

### 堆的操作

#### 插入（大顶堆）

1. 将要插入的元素放到存储堆的数组的末尾
2. 进行堆化（从下往上）
   1. 将插入的 i 节点与其父节点 i/2 对比大小
   2. 如果 i 节点大于父节点的值就交换两个节点
   3. 重复上面的比较操作直到父子关系满足大顶堆的要求

#### 删除堆顶元素（大顶堆）

1. 删除堆顶元素
2. 将最后一个节点放到堆顶
3. 进行堆化（从上到下）
   1. 定义 i = 1，表明是堆顶
   2. 比较 i 节点与子节点的大小，如果子节点全都小于 i 节点，说明堆化完成
   3. 否则将 i 节点与其子节点中较大的那个交换
   4. 让 i 等于子节点中较大的那个，继续 2，3 操作

#### 复杂度分析

由于上面主要的操作就在于堆化，而堆化就是顺着节点的路径进行比较和替换，因此堆化的复杂度取决于树的高度，因此插入和删除堆顶元素的时间复杂度就是 O(logn)。

## 堆排序

堆排序不是稳定排序算法，时间复杂度是 O(nlogn)，并且是原地算法。

### 步骤

#### 1. 建堆

- 思路 1 ：在堆中插入元素
    1. 起始的时候将数组中的第一个元素看成是一个起始堆
    2. 将下标从 2 到 n 的数据依次插入堆中
- 思路 2 ：从后往前处理数据，挨个进行堆化
    1. 由于叶子节点不能往下堆化，因此略过
    2. 从第一个非叶子节点 n/2（也就是最后一个元素 n 的父节点）开始堆化
    3. 然后依次对 n/2 到 1 的数据进行堆化

##### 思路 2 的时间复杂度

1. 每个节点堆化的过程跟需要比较和交换的节点个数相关，而这个个数又跟节点的高度 k 成正比
2. 对于堆来说
   - 第 1 层节点个数为 1， 高度为 k
   - 第 2 层节点个数为 2， 高度为 k-1
   - 第 3 层节点个数为 2^2， 高度为 k-2
   - ...
   - 第 i-1 层节点个数为 2^i， 高度为 k-i
   - ...
   - 第 k 层节点个数为 2^k-1， 高度为 1

    综上可以看出所有堆化需要进行的比较和交换个数就是
    
    ```
    s = 1*k + 2*(k-1) + 2^2*(k-2) + ... + 2^i*(k-i) + ... + 2^(k-1)*1
    ```
3. 经过求解上面的公式得出
    
    ```
    s = 2^(k+1) - k - 2
    ```
4. 高度 k = log2n， 因此可以看出 s = O(n)
5. 因此建堆的复杂度就是 O（n）

#### 排序

1. 建堆结束后，数组中的数据就是大顶堆了，堆顶元素就是最大值
2. 将堆顶元素与最后一个元素交换，代表已经排好一个位置
3. 对剩余的元素进行堆化，然后继续 2 操作
4. 当堆中元素个数为 1，代表已经完成排序

##### 复杂度分析

我们可以看出耗时的操作主要是进行堆化的操作，因此每次堆化的复杂度就是 O(logn)，又由于需要每个元素排好后都需要进行堆化，因此整体复杂度就是 O(nlogn).

### 堆排序复杂度

由上可以看出堆排序主要分为两步：建堆（复杂度为 O(n)）、排序（复杂度为 O(nlogn)）。因此排序整体复杂度就是 O(nlogn)。

## QA

1. 堆排序性能为什么低于快排

    1. 堆排序的数据是跳动访问的，相较于快排中局部顺序访问的情况，不利于 CPU 的缓存。
    2. 同样的数据，堆排序交换次数要多于快排，尤其是当要排序的数据的有序度较高的情况下。

2. 为什么对于完全二叉树，下标从 n/2+1 到 n 都是叶子节点

    如果最后一个元素的下标是 n ，则其父节点的下标就是 n/2。因此 n/2+1 到 n 都是叶子节点。

# 堆的应用

## 优先级队列

### 定义

优先级队列也是一个队列，出队的时候，优先级高的先出队，低的后出队。

利用堆来实现优先队列是最直接和高效的。

### 应用

#### 1. 合并有序小文件

假设有 100 个小文件，每个文件都是存储着 100MB 大小的有序字符串，如何合并。

1. 每个文件取首个字符串，构建一个小顶堆
2. 小顶堆的堆顶元素就是最小元素，取出将其存入数组
3. 将堆顶删除后，把它所在的文件中的下一个字符串取出，放入堆中
4. 堆化后继续 2、3 操作，直到所有的处理完成

#### 2. 高性能定时器

一个定时器维护了很多定时任务，每个任务都设定了触发的时间点。如何高效实现定时器的功能

1. 按照任务的触发时间，将任务置于优先队列中，这样以来小顶堆的堆顶就是最先要执行的任务
2. 根据当前时间与堆顶任务触发时间的间隔，间隔时间到了就去执行堆顶任务
3. 执行任务后删除堆顶元素，从新堆化
4. 继续 2、3 操作

## 利用堆求 Top K

### 静态数据（已经给定，不会再添加）

1. 维护一个 K 大小的小顶堆
2. 遍历数据
   1. 数据大于堆顶元素的时候，删除堆顶元素，将数据插入堆中
   2. 数据小于堆顶元素，不做处理
3. 继续 2 的操作直到全部遍历完后，堆中的数据就是 Top K 的元素了

### 动态数据（未确定，还会再添加）

1. 首先对已给定的数据进行上面的处理，得到其 Top K 的堆
2. 插入数据的时候
   1. 数据大于堆顶元素的时候，删除堆顶元素，将数据插入堆中
   2. 数据小于堆顶元素，不做处理
3. 每次插入都进行 2 操作，堆中的元素就一直是 Top K 的元素了

## 利用堆求中位数

### 中位数

- 数据数量是奇数：第 n/2+1 个数就是中位数
- 数据数量是偶数：第 n/2 和第 n/2+1 个数都是是中位数

### 求中位数

1. 维护两个堆。
   1. 一个是大顶堆，存储前半部分数据。奇数情况下存储 n/2+1 个数据，偶数情况下存储 n/2 个数据
   2. 一个是小顶堆，存储后半部分数据。奇数偶数情况下都存储 n/2 个数据
2. 插入数据的时候
   1. 数据小于等于大顶堆堆顶元素的大小的时候，将其插入到大顶堆
   2. 数据大于等于小顶堆堆顶元素的大小的时候，将其插入到小顶堆
3. 插入结束后检查是否满足条件 1 ，不满足的情况下移动堆顶元素使其满足
4. 这样的话中位数就是两个堆的堆顶元素

### 求 99% 相应时间

与求中位数的操作相同，不同的就是两个堆存储数据的多少。

大顶堆存储前 99% 的数据
小顶堆存储后 1% 的数据

## QA 假设现在有包含 10 亿个搜索关键词的日志文件，快速获取热门榜 Top 10 的关键词

1. 通过散列表存储搜索关键词的出现次数
2. 建一个大小为 10 的小顶堆
3. 遍历散列表
   1. 如果关键词的次数大于堆顶的次数，就删除堆顶元素，将关键词插入堆中
   2. 否则跳过
4. 遍历完成后，堆中的数据就是所求数据

### 优化

通过关键词的哈希值取模，将所有的关键词分片到小文件中，然后分别对小文件中的关键词求其 Top 10 。最后将所有的 Top 10 放到一起后取他们的 Top 10 就是所有关键词的 Top 10了。
