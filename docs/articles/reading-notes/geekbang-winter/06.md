# 作用域链与闭包

了解作用域链之前需要先了解下作用域是什么。

## 作用域

几乎所有的语言都有作用域的概念。这是因为它们都有变量这一概念。而程序代码中所用到的变量并不总是有效或者可用的，因此需要限定变量的可用性范围，这就是作用域。

也就是说作用域规定了当前执行代码对变量的访问权限，在变量作用域之外是没有访问权限的。

### 静态作用域与动态作用域

不同的语言在设计的时候规定的作用域是不同的，一般分为静态作用域和动态作用域。

1. 静态作用域
   
静态作用域是指声明的作用域是根据程序正文在编译时就确定的，有时也称为词法作用域。

**静态作用域关注函数在何处声明**。

2. 动态作用域

动态作用域是在运行时根据程序的流程信息来动态确定的。

**动态作用域关注函数从何处调用**，其作用域链是基于运行时的调用栈的。

事实上大部分语言都是基于静态作用域的，JavaScript 也是这样。比如下面的例子。

```javascript
var value = 1;

function foo() {
    console.log(value);
}

function bar() {
    var value = 2;
    foo();
}

bar();

// 结果是 ???
```

分下一下执行过程。

1. 执行 bar 函数
2. 进入到 bar 函数体内
3. 调用 foo 函数
4. 进入 foo 函数体内
5. 打印 value 的值的时候要先去查找 value 的值
6. foo 函数体内部没有 value 变量
7. 因此需要去上一级代码查找，由于 JavaScript 是静态作用域，需要去 foo 声明的地方查找
8. 找到了 value 的值等于 1
9. 输出 1

总结一下就是**作用域范围是在函数定义的时候就确定下来的**，理解这一点非常重要。

## 作用域链

在上篇文章 [《执行上下文和执行栈》](./05md) 中讲到函数执行的时候会创建执行上下文，在执行上下文生成的过程中，会分别确定变量对象，作用域链，以及this的值。

而且我们知道了，函数的执行上下文在创建的时候会扫描**当前上下文中**声明的变量和函数，并将其初始化并保存到上下文对应的 VO 变量对象中。

那么当函数中访问到当前执行上下文中没有声明的变量的时候该怎么办呢？

简单来说如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。

可以用下面的公式来总结 

```
Scope = VO + All Parent VOs
```

我们通过下面代码从函数的创建和激活两个时期来讲解作用域链是如何构建出来的。

```javascript
function foo() {
    function bar() {
        ...
    }
}
```

### 函数创建阶段

在介绍作用域的时候我们知道了函数的作用域在它定义的时候就决定了。这是因为函数也是对象，它有一个属性 `[[scope]]`(内部属性,只有JS引擎可以访问, 但FireFox 的几个引擎( SpiderMonkey 和 Rhino )提供了私有属性 `__parent__` 来访问它)。

函数在创建的时候会将 `[[scope]]` 属性链接到它父级作用域的作用域链上。

foo 函数创建阶段

```
[[scope]] = [
    globalContext.VO
]
```

bar 函数创建阶段

```
[[scope]] = [
    fooContext.AO,
    globalContext.VO
]
```

注意：

1. `[[scope]]` 并不代表作用域链
2. bar 函数的 `[[scope]]` 中是 fooContext.AO 而不是 VO 是因为在 bar 函数创建的时候 foo 函数已经处于激活阶段了

### 函数激活阶段

函数激活的时候会创建上下文，然后先去创建 VO/AO 对象。然后就会将 AO 对象添加到 `[[scope]]` 属性的链表中。

这个时候的这个链表称为当前上下文的作用域链。

## 参考

1. [Identifier Resolution and Closures in the JavaScript Scope Chain](http://davidshariff.com/blog/javascript-scope-chain-and-closures/)
2. [JavaScript深入之作用域链](https://github.com/mqyqingfeng/Blog/issues/6)
3. [Javascript作用域原理](http://www.laruence.com/2009/05/28/863.html)
4. 