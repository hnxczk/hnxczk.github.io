{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{413:function(t,n,a){\"use strict\";a.r(n);var e=a(0),i=Object(e.a)({},function(){var t=this,n=t.$createElement,a=t._self._c||n;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"查找\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#查找\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 查找\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"_15-二分查找（上）\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_15-二分查找（上）\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 15 二分查找（上）\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"思想\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#思想\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 思想\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。\")]),t._v(\" \"),a(\"li\",[t._v(\"每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半\")]),t._v(\" \"),a(\"li\",[t._v(\"直到找到要查找的元素，或者区间被缩小为 0 说明查找的元素不存在\")])]),t._v(\" \"),a(\"h3\",{attrs:{id:\"二分查找时间复杂度\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#二分查找时间复杂度\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 二分查找时间复杂度\")]),t._v(\" \"),a(\"p\",[t._v(\"每查找一次之后，剩余需要查找的区间就会缩小一半，这时候在最坏情况下需要将查找区间缩小到 0。因此 n / (2^k) = 1, k = log2n,时间复杂度就是 O(logn).\")]),t._v(\" \"),a(\"p\",[t._v(\"对数时间复杂度 O(logn) 某些情况下比常数级 O（1）还要高效，因为用大 O 标记法表示时间复杂度的时候，会省略掉常数、系数和低阶，如果这些常数系数有可能是非常大的数值，这时候 O(logn) 将优于 O（1）。\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"代码实现\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#代码实现\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 代码实现\")]),t._v(\" \"),a(\"p\",[t._v(\"循环\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"int binarySearch(int arr[], int n, int item)\\n{\\n    int start = 0, end = n - 1;\\n    while (start <= end) {\\n        int middle = start + ((end - start) >> 1);\\n        if (arr[middle] > item) {\\n            end = middle - 1;\\n        } else if (arr[middle] < item) {\\n            start = middle + 1;\\n        } else {\\n            return middle;\\n        }\\n    }\\n    return -1;\\n}\\n\")])])]),a(\"p\",[t._v(\"递归\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"int binary(int arr[], int start, int end, int item)\\n{\\n    if (start > end) return -1;\\n    \\n    int middle = start + ((end - start) >> 1);\\n    int midVal = arr[middle];\\n    if (midVal > item) {\\n        return binary(arr, start, middle - 1, item);\\n    } else if (midVal < item) {\\n        return binary(arr, middle + 1, end, item);\\n    } else {\\n        return middle;\\n    }\\n}\\n\\nint binarySearch_1(int arr[], int n, int item)\\n{\\n    return binary(arr, 0, n - 1, item);\\n}\\n\")])])]),a(\"h4\",{attrs:{id:\"注意点\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#注意点\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 注意点\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"循环退出条件 start <= end\")]),t._v(\" \"),a(\"li\",[t._v(\"middle 的取值 (start + end) / 2 在数值较大的时候可能出现溢出\")]),t._v(\" \"),a(\"li\",[t._v(\"start end 的更新注意 +1  和 -1。如果直接写成 low=mid 或者 high=mid，就可能会发生死循环。比如，当 high=3，low=3 时，如果 a[3] 不等于 value，就会导致一直循环不退出。\")])]),t._v(\" \"),a(\"h3\",{attrs:{id:\"使用场景\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#使用场景\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 使用场景\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"必须是顺序表中的数组，当时链表的时候复杂度会升高\")]),t._v(\" \"),a(\"li\",[t._v(\"必须是有序数据\")]),t._v(\" \"),a(\"li\",[t._v(\"数据量太小不适合二分查找\")]),t._v(\" \"),a(\"li\",[t._v(\"数据比较较为耗费性能的时候就需要使用二分查找\")]),t._v(\" \"),a(\"li\",[t._v(\"数据量太大也不适合二分查找\")]),t._v(\" \"),a(\"li\",[t._v(\"大部分情况下，用二分查找可以解决的问题，用散列表、二叉树都可以解决。但是不管是散列表还是二叉树，都会需要比较多的额外的内存空间，二分查找只需要一个数组，较为节省空间\")])]),t._v(\" \"),a(\"h3\",{attrs:{id:\"qa\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#qa\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" QA\")]),t._v(\" \"),a(\"h4\",{attrs:{id:\"求一个数-x-的平方根”？要求精确到小数点后-6-位\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#求一个数-x-的平方根”？要求精确到小数点后-6-位\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 求一个数 x 的平方根”？要求精确到小数点后 6 位\")]),t._v(\" \"),a(\"p\",[t._v(\"利用二分查找 0 到 x 之间的数 mid ,直到 mid * mid - x < 1e-6\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"double sqrt(double x)\\n{\\n    double start = 0, end = x, middle = 0;\\n    while (fabs(end - start) >= 1e-6) {\\n        middle = start + ((end - start) / 2);\\n        if (middle * middle > x) {\\n            end = middle;\\n        } else if (middle * middle < x) {\\n            start = middle;\\n        } else {\\n            return middle;\\n        }\\n    }\\n    return middle;\\n}\\n\")])])]),a(\"h4\",{attrs:{id:\"分析使用链表储存数据时二分查找的时间复杂度\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#分析使用链表储存数据时二分查找的时间复杂度\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 分析使用链表储存数据时二分查找的时间复杂度\")]),t._v(\" \"),a(\"p\",[t._v(\"使用数组实现二分查找的时候，由于数组具有根据下标随机访问时间复杂度为 O（1）的特性，因此其主要的费时操作就是不断的缩小查找区间，区间缩小多少次\\b就执行了多少步操作，因此可以计算出其时间复杂度是 O(logn)\")]),t._v(\" \"),a(\"p\",[t._v(\"使用链表来实现二分查找的时候，由于链表访问某个位置的\\b时间复杂度是 O(n), 因此在查找阶段需要进行的\\b\\b操作如下：\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"第一次查找中点，移动指针 n/2 次\")]),t._v(\" \"),a(\"li\",[t._v(\"第二次，移动 n/4 次\")]),t._v(\" \"),a(\"li\",[t._v(\"第三次，移动 n/8 次\")]),t._v(\" \"),a(\"li\",[t._v(\"......\")]),t._v(\" \"),a(\"li\",[t._v(\"第 k 次， 移动 n/(2^k) 次\")])]),t._v(\" \"),a(\"p\",[t._v(\"这时候在由于比较这一操作相较于移动指针的操作来说是常数阶，因此可以忽略\")]),t._v(\" \"),a(\"p\",[t._v(\"由此可以看出这是一个等比公式，在最坏情况下首项是 n/(2^k) = 1 (这时候 k = log2n), 公比 是 2，数列的项数等于 k。因此根据等比数列求和公式可以得出\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"sum = (1 - 2^k) / (1 - 2)\")]),t._v(\" \"),a(\"li\",[t._v(\"sum = 2^k - 1\")]),t._v(\" \"),a(\"li\",[t._v(\"sum = 2^(log2n) - 1\")]),t._v(\" \"),a(\"li\",[t._v(\"sum = n - 1\")])]),t._v(\" \"),a(\"p\",[t._v(\"因此算法的时间复杂度就是 O(n), 与遍历查找相同。但由于需要进行额外的其他操作，因此其效率低于遍历查找。\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"_16-二分查找（下）\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_16-二分查找（下）\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 16 二分查找（下）\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"变体-：查找第一个值等于给定值的元素\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#变体-：查找第一个值等于给定值的元素\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 变体-：查找第一个值等于给定值的元素\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"int _bsearch(int arr[], int n, int item)\\n{\\n    int start = 0, end = n - 1;\\n    while (start <= end) {\\n        int mid = start + (end - start) / 2;\\n        if (arr[mid] > item) {\\n            end = mid - 1;\\n        } else if (arr[mid] < item) {\\n            start = mid + 1;\\n        } else {\\n            if ((mid == 0) || (arr[mid - 1] != item )) {\\n                return mid;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n\")])])]),a(\"p\",[t._v(\"思路：\")]),t._v(\" \"),a(\"ol\",[a(\"li\",[a(\"p\",[t._v(\"使用二分查找进行处理\")])]),t._v(\" \"),a(\"li\",[a(\"p\",[t._v(\"arr[mid] 大于 或者 小于 要查找的 item 的时候与二分查找处理相同\")])]),t._v(\" \"),a(\"li\",[a(\"p\",[t._v(\"arr[mid] 等于 item 的时候，说明 mid 的值就是要查找的值，但是由于其可能有多个这时候需要额外判断\")]),t._v(\" \"),a(\"ol\",[a(\"li\",[t._v(\"如果 mid == 0 ，说明 mid 位于数组的首位，一定是要查找的\")]),t._v(\" \"),a(\"li\",[t._v(\"mid - 1 位置的元素 不等于 要查找的值说明 mid 位置的元素就是第一个 目标值\")])])])]),t._v(\" \"),a(\"h3\",{attrs:{id:\"变体二：查找最后一个值等于给定值的元素\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#变体二：查找最后一个值等于给定值的元素\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 变体二：查找最后一个值等于给定值的元素\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"int _bsearch(int arr[], int n, int item)\\n{\\n    int start = 0, end = n - 1;\\n    while (start <= end) {\\n        int mid = start + (end - start) / 2;\\n        if (arr[mid] > item) {\\n            end = mid - 1;\\n        } else if (arr[mid] < item) {\\n            start = mid + 1;\\n        } else {\\n            if ((mid == n - 1) || (arr[mid + 1] != item )) {\\n                return mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n\")])])]),a(\"p\",[t._v(\"思路:与变体一基本相同，也是要判断 arr[mid] 等于 item 的情况\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"变体三：查找第一个大于等于给定值的元素\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#变体三：查找第一个大于等于给定值的元素\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 变体三：查找第一个大于等于给定值的元素\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"int _bsearch(int arr[], int n, int item)\\n{\\n    int start = 0, end = n - 1;\\n    while (start <= end) {\\n        int mid = start + (end - start) / 2;\\n        if (arr[mid] >= item) {\\n            if ((mid == 0) || (arr[mid - 1] < item )) {\\n                return mid;\\n            } else {\\n                end = mid - 1;\\n            }\\n        } else {\\n            start = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n\")])])]),a(\"p\",[t._v(\"思路\")]),t._v(\" \"),a(\"ol\",[a(\"li\",[a(\"p\",[t._v(\"使用二分查找\")])]),t._v(\" \"),a(\"li\",[a(\"p\",[t._v(\"当 arr[mid] 小于 要查找的值，则 start = mid + 1\")])]),t._v(\" \"),a(\"li\",[a(\"p\",[t._v(\"当 arr[mid] 大于等于 要查找的值的时候\")]),t._v(\" \"),a(\"ol\",[a(\"li\",[t._v(\"如果 mid == 0 说明，mid 就是数组首位，满足条件\")]),t._v(\" \"),a(\"li\",[t._v(\"如果 arr[mid - 1] 小于 要查找的值，说明 mid 位置的元素就是第一个大于等于给定值的元素\")]),t._v(\" \"),a(\"li\",[t._v(\"其他情况下说明 mid 位置的元素虽然大于目标元素但不是第一个，需要继续进行查找\")])])])]),t._v(\" \"),a(\"h3\",{attrs:{id:\"变体四：查找第一个小于等于给定值的元素\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#变体四：查找第一个小于等于给定值的元素\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 变体四：查找第一个小于等于给定值的元素\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"int _bsearch(int arr[], int n, int item)\\n{\\n    int start = 0, end = n - 1;\\n    while (start <= end) {\\n        int mid = start + (end - start) / 2;\\n        if (arr[mid] <= item) {\\n            if ((mid == n - 1) || (arr[mid + 1] > item )) {\\n                return mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n\")])])]),a(\"p\",[t._v(\"与变体三的思路基本相同\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"qa-2\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#qa-2\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" QA\")]),t._v(\" \"),a(\"h4\",{attrs:{id:\"_1-如何快速定位-ip-归属地\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-如何快速定位-ip-归属地\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 1. 如何快速定位 IP 归属地\")]),t._v(\" \"),a(\"p\",[t._v(\"如何快速定位出一个IP地址的归属地？\")]),t._v(\" \"),a(\"blockquote\",[a(\"p\",[t._v(\"[202.102.133.0, 202.102.133.255] 山东东营市\\n[202.102.135.0, 202.102.136.255] 山东烟台\\n[202.102.156.34, 202.102.157.255] 山东青岛\\n[202.102.48.0, 202.102.48.255] 江苏宿迁\\n[202.102.49.15, 202.102.51.251] 江苏泰州\\n[202.102.56.0, 202.102.56.255] 江苏连云港\")])]),t._v(\" \"),a(\"p\",[t._v(\"假设我们有 12 万条这样的 IP 区间与归属地的对应关系，如何快速定位出一个IP地址的归属地呢？\")]),t._v(\" \"),a(\"p\",[t._v(\"将所有的 IP 区间的开始位置转化为 32 位 的数，然后放到数组中进行排序。\")]),t._v(\" \"),a(\"p\",[t._v(\"这样以来问题就转换为查找这个数组中最后一个小于等于目标 IP 对应的数值 的问题\")]),t._v(\" \"),a(\"h4\",{attrs:{id:\"_2-如果有序数组是一个循环有序数组，比如-4，5，6，1，2，3。针对这种情况，如何实现一个求“值等于给定值”的二分查找算法呢？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-如果有序数组是一个循环有序数组，比如-4，5，6，1，2，3。针对这种情况，如何实现一个求“值等于给定值”的二分查找算法呢？\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 2. 如果有序数组是一个循环有序数组，比如 4，5，6，1，2，3。针对这种情况，如何实现一个求“值等于给定值”的二分查找算法呢？\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"int _bsearch(int nums[], int n, int target)\\n{\\n    int left = 0,right = numsSize-1;\\n    while(left<=right){\\n        int mid = (left+right)/2;\\n        \\n        if(nums[mid]==target){\\n            //找到了，返回\\n            return mid;\\n        }\\n        \\n        //左半边是正常序列\\n        if(nums[left]<=nums[mid]){\\n            //target在这个序列\\n            if(target>=nums[left] && target<=nums[mid]){\\n                //分到左半边\\n                right = mid-1;\\n            }else{\\n                //分到右半边\\n                left = mid+1;\\n            }\\n        }else{\\n            //右半边是正常序列\\n            //target在这个序列\\n            if(target>=nums[mid] && target<=nums[right]){\\n                //分到右半边\\n                left = mid+1;\\n            }else{\\n                //分到左半边\\n                right = mid-1;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n\")])])])])},[],!1,null,null,null);n.default=i.exports}}]);","extractedComments":[]}