{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{363:function(e,t,a){e.exports=a.p+\"assets/img/02-obsver-pattern-1.41dc1609.png\"},364:function(e,t,a){e.exports=a.p+\"assets/img/02-obsever-pattern-2.123d0ffd.png\"},490:function(e,t,a){\"use strict\";a.r(t);var r=a(0),n=Object(r.a)({},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[r(\"h1\",{attrs:{id:\"观察者模式\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#观察者模式\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 观察者模式\")]),e._v(\" \"),r(\"h2\",{attrs:{id:\"定义\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#定义\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 定义\")]),e._v(\" \"),r(\"p\",[r(\"strong\",[e._v(\"观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会受到通知并自动更新\")])]),e._v(\" \"),r(\"h2\",{attrs:{id:\"气象监测应用\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#气象监测应用\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 气象监测应用\")]),e._v(\" \"),r(\"p\",[e._v(\"建立一个应用，利用已知的 WeatherData 对象获取数据并更新三个布告板：目前情况（温度、湿度、气压）、气象统计、天气预报。\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"@interface WeatherData : NSObject\\n\\n- (CGFloat)getTemperature;\\n- (CGFloat)getHumidity;\\n- (CGFloat)getPressure;\\n\\n// 一旦气象测量更新，此方法会被调用\\n- (void)measurementsChanged;\\n\\n@end\\n\")])])]),r(\"h3\",{attrs:{id:\"已知条件\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#已知条件\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 已知条件\")]),e._v(\" \"),r(\"ol\",[r(\"li\",[e._v(\"WeatherData类具有getter方法，可以取得三个测量值。\")]),e._v(\" \"),r(\"li\",[e._v(\"当心的测量数据备妥时，measurementsChanged 方法就会被调用（我们不在乎此方法是如何被调用的，我们只在乎它被调用了）。\")]),e._v(\" \"),r(\"li\",[e._v(\"我们需要实现三个使用天气数据的布告板，一旦 WeatherData 有新的测量，这些布告板必须马上更新。\")]),e._v(\" \"),r(\"li\",[e._v(\"此系统必须可扩展，让其他开发人员建立定制的布告板，用户可以随心所欲地添加或删除任何布告板。\")])]),e._v(\" \"),r(\"h2\",{attrs:{id:\"错误示范\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#错误示范\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 错误示范\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"- (void)measurementsChanged\\n{\\n    CGFloat temp = [self getTemperature];\\n    CGFloat hum = [self getHumidity];\\n    CGFloat pressure = [self getPressure];\\n    \\n    [currentConditionsDisplay updateWithTemp:temp humidity:hum pressure:pressure];\\n    [statisticsDisplay updateWithTemp:temp humidity:hum pressure:pressure];\\n    [forecastDisplay updateWithTemp:temp humidity:hum pressure:pressure];\\n}\\n\")])])]),r(\"p\",[e._v(\"存在的问题\")]),e._v(\" \"),r(\"ol\",[r(\"li\",[e._v(\"我们是针对具体实现编程，而非针对接口。这样的话我们以后再正价或者删除布告板的时候必须修改程序。\")]),e._v(\" \"),r(\"li\",[e._v(\"对于每个新的布告板，我们都得修改代码。\")]),e._v(\" \"),r(\"li\",[e._v(\"我们无法再运行时动态地增加（或删除）布告板。\")]),e._v(\" \"),r(\"li\",[e._v(\"我们尚未封装改变的部分。\")])]),e._v(\" \"),r(\"h2\",{attrs:{id:\"观察者模式-2\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#观察者模式-2\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 观察者模式\")]),e._v(\" \"),r(\"p\",[e._v(\"定义\")]),e._v(\" \"),r(\"p\",[r(\"strong\",[e._v(\"观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会受到通知并自动更新\")])]),e._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:a(363),alt:\"\"}})]),e._v(\" \"),r(\"h2\",{attrs:{id:\"松耦合的威力\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#松耦合的威力\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 松耦合的威力\")]),e._v(\" \"),r(\"p\",[r(\"strong\",[e._v(\"松耦合的设计之所以能让我买建立有弹性的、能应对变化的系统是因为对象之间的画像依赖降到了最低。\")])]),e._v(\" \"),r(\"p\",[e._v(\"就拿观察者模式来说这就是一个松耦合的设计。主题只知道观察者实现了某些接口，但是它并不知道观察者具体的类型，也不知道观察者的具体细节。主题唯一依赖的就是一个实现相应接口的对象列表，把观察者加入该列表或者从列表中删除都不会影响到主题。\")]),e._v(\" \"),r(\"p\",[e._v(\"##代码实现\")]),e._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:a(364),alt:\"\"}})]),e._v(\" \"),r(\"p\",[e._v(\"具体实现见\"),r(\"a\",{attrs:{href:\"./code/02-obsever-pattern/01-Weather\"}},[e._v(\"相关代码\")])]),e._v(\" \"),r(\"h2\",{attrs:{id:\"观察者模式是怎么准守设计准则的\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#观察者模式是怎么准守设计准则的\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 观察者模式是怎么准守设计准则的\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"_1-找出程序中会变化的部分，然后将其和固定不变的部分分离\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-找出程序中会变化的部分，然后将其和固定不变的部分分离\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 1. 找出程序中会变化的部分，然后将其和固定不变的部分分离\")]),e._v(\" \"),r(\"p\",[e._v(\"在观察者模式中，会改变的是主题的状态\\b以及观察者的数量和类型。使用这个模式可以改变依赖于主题状态改变的对象，而不用改变主题。\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"_2-针对接口编程，不针对实现编程\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-针对接口编程，不针对实现编程\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 2. 针对接口编程，不针对实现编程\")]),e._v(\" \"),r(\"p\",[e._v(\"主题与接口都使用接口，观察者利用主题的接口向主题注册，主题利用观察者接口通知观察者。这样就具有松耦合的优点。\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"_3-多用组合，少用继承\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-多用组合，少用继承\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 3 多用组合，少用继承\")]),e._v(\" \"),r(\"p\",[e._v(\"观察者模式利用组合奖许多的观察者组合进祖逖的容器中。这样一来对象之间就没有继承而是通过组合产生关系。\")]),e._v(\" \"),r(\"h2\",{attrs:{id:\"oc-中的观察者模式\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#oc-中的观察者模式\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" OC 中的观察者模式\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"nsnotification\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#nsnotification\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" NSNotification\")]),e._v(\" \"),r(\"p\",[e._v(\"先看一个例子\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v('- (void)viewDidLoad {\\n    [super viewDidLoad];\\n    \\n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(noticeAction) name:NOTIFICATION_NAME object:nil];\\n}\\n\\n- (void)noticeAction\\n{\\n    NSLog(@\"getNotice\");\\n}\\n\\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\\n{\\n    [[NSNotificationCenter defaultCenter] postNotificationName:NOTIFICATION_NAME object:nil userInfo:nil];\\n}\\n')])])]),r(\"p\",[e._v(\"在 iOS 中主题是由一个单例 \"),r(\"code\",[e._v(\"NSNotificationCenter\")]),e._v(\" 来充当。 而一个观察者通过调用 \"),r(\"code\",[e._v(\"addObserver...\")]),e._v(\" 方法来注册。与上面介绍的不同的是注册的时候 OC 同时传入 selector 来告诉主题在通知观察者的时候的调用方法。这其实与通过协议的方式异曲同工。\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"kvo\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#kvo\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" KVO\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v('@interface ViewController ()\\n\\n@property (nonatomic, assign) NSInteger count;\\n\\n@end\\n\\n@implementation ViewController\\n\\n- (void)viewDidLoad {\\n    [super viewDidLoad];\\n\\n    [self addObserver:self forKeyPath:@\"count\" options:NSKeyValueObservingOptionOld | NSKeyValueObservingOptionNew context:nil];\\n}\\n\\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context\\n{\\n    NSLog(@\"%@\", change);\\n}\\n\\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event\\n{\\n    self.count = 10;\\n}\\n\\n@end\\n')])])]),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"2018-06-21 22:21:45.894083+0800 03-KVO[7403:124006] {\\n    kind = 1;\\n    new = 10;\\n    old = 0;\\n}\\n\")])])]),r(\"p\",[e._v(\"对于上面 KVO 的例子来说，self 即是主题也是观察者（当然很多情况下都不是这样，偷懒ing...），而 \"),r(\"code\",[e._v(\"observeValueForKeyPath...\")]),e._v(\" 这个方法从当了协议的角色。\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"更多-oc-中二者的具体用法可以看南峰子大神的博客\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#更多-oc-中二者的具体用法可以看南峰子大神的博客\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 更多 OC 中二者的具体用法可以看南峰子大神的博客\")]),e._v(\" \"),r(\"ol\",[r(\"li\",[r(\"a\",{attrs:{href:\"http://southpeak.github.io/2015/04/23/cocoa-foundation-nskeyvalueobserving/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"Foundation: NSKeyValueObserving(KVO)\"),r(\"OutboundLink\")],1)]),e._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"http://southpeak.github.io/2015/03/20/cocoa-foundation-nsnotificationcenter/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"Foundation: NSNotificationCenter\"),r(\"OutboundLink\")],1)])])])},[],!1,null,null,null);t.default=n.exports}}]);","extractedComments":[]}