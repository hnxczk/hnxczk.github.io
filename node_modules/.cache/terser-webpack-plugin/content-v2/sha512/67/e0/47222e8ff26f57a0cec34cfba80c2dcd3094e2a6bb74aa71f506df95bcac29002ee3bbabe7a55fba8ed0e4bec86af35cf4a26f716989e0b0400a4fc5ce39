{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{454:function(_,v,a){\"use strict\";a.r(v);var t=a(0),r=Object(t.a)({},function(){var _=this,v=_.$createElement,a=_._self._c||v;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":_.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"链表\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#链表\",\"aria-hidden\":\"true\"}},[_._v(\"#\")]),_._v(\" 链表\")]),_._v(\" \"),a(\"h2\",{attrs:{id:\"_06-链表（上）\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_06-链表（上）\",\"aria-hidden\":\"true\"}},[_._v(\"#\")]),_._v(\" 06 链表（上）\")]),_._v(\" \"),a(\"h3\",{attrs:{id:\"定义\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#定义\",\"aria-hidden\":\"true\"}},[_._v(\"#\")]),_._v(\" 定义\")]),_._v(\" \"),a(\"p\",[_._v(\"通过指针将一组零散的内存块串联起来就构成了链表。\")]),_._v(\" \"),a(\"p\",[_._v(\"其中这些内存块称为\"),a(\"strong\",[_._v(\"节点\")]),_._v(\"，节点中记录链表下个节点地址的指针称为\"),a(\"strong\",[_._v(\"后继指针\")]),_._v(\"。\")]),_._v(\" \"),a(\"p\",[_._v(\"两个特殊节点：第一个节点称为\"),a(\"strong\",[_._v(\"头结点\")]),_._v(\"，最后一个节点称为\"),a(\"strong\",[_._v(\"尾节点\")]),_._v(\"，尾节点的后继节点是一个\"),a(\"strong\",[_._v(\"空地址 NULL\")])]),_._v(\" \"),a(\"h3\",{attrs:{id:\"分类\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#分类\",\"aria-hidden\":\"true\"}},[_._v(\"#\")]),_._v(\" 分类\")]),_._v(\" \"),a(\"ol\",[a(\"li\",[_._v(\"单链表 单链表的节点只包含一个存储数据的内存空间和后继指针 next\")]),_._v(\" \"),a(\"li\",[_._v(\"双向链表 双向链表的节点包含一个存储数据的内存空间以及前驱指针 prev 和后继指针 next\")]),_._v(\" \"),a(\"li\",[_._v(\"循环链表 尾节点的后继指针指向头节点的链表就是循环链表\")])]),_._v(\" \"),a(\"h3\",{attrs:{id:\"双向链表的优点\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#双向链表的优点\",\"aria-hidden\":\"true\"}},[_._v(\"#\")]),_._v(\" 双向链表的优点\")]),_._v(\" \"),a(\"p\",[_._v(\"链表遍历的时间复杂度是 O(n),在实际使用中双向链表可以减少链表的遍历操作。\")]),_._v(\" \"),a(\"h3\",{attrs:{id:\"链表与数组性能对比\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#链表与数组性能对比\",\"aria-hidden\":\"true\"}},[_._v(\"#\")]),_._v(\" 链表与数组性能对比\")]),_._v(\" \"),a(\"h4\",{attrs:{id:\"数组\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#数组\",\"aria-hidden\":\"true\"}},[_._v(\"#\")]),_._v(\" 数组\")]),_._v(\" \"),a(\"ul\",[a(\"li\",[_._v(\"随机访问 O(1) 插入删除 O(n)\")]),_._v(\" \"),a(\"li\",[_._v(\"实际使用中由于数组使用的是连续内存空间，可以借助 CPU 的缓存机制预读数组中的数据，因此访问效率更高。\")]),_._v(\" \"),a(\"li\",[_._v(\"数组扩容非常耗时\")])]),_._v(\" \"),a(\"h4\",{attrs:{id:\"链表-2\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#链表-2\",\"aria-hidden\":\"true\"}},[_._v(\"#\")]),_._v(\" 链表\")]),_._v(\" \"),a(\"ul\",[a(\"li\",[_._v(\"随机访问 O(n) 插入删除 O(1)\")]),_._v(\" \"),a(\"li\",[_._v(\"由于不是连续内存，对 CPU 缓存不太友好。\")]),_._v(\" \"),a(\"li\",[_._v(\"更容易造成内存碎片\")]),_._v(\" \"),a(\"li\",[_._v(\"对于 Java 来说还会导致频繁的垃圾回收。\")])]),_._v(\" \"),a(\"h3\",{attrs:{id:\"基于链表实现-lru-缓存淘汰算法\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#基于链表实现-lru-缓存淘汰算法\",\"aria-hidden\":\"true\"}},[_._v(\"#\")]),_._v(\" 基于链表实现 LRU 缓存淘汰算法\")]),_._v(\" \"),a(\"ol\",[a(\"li\",[_._v(\"当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。\")]),_._v(\" \"),a(\"li\",[_._v(\"如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。\")]),_._v(\" \"),a(\"li\",[_._v(\"如果此数据没有在缓存链表中，又可以分为两种情况：\\n\"),a(\"ul\",[a(\"li\",[_._v(\"如果此时缓存未满，则将此结点直接插入到链表的头部；\")]),_._v(\" \"),a(\"li\",[_._v(\"如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。\")])])])]),_._v(\" \"),a(\"h2\",{attrs:{id:\"_07-链表（下）\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_07-链表（下）\",\"aria-hidden\":\"true\"}},[_._v(\"#\")]),_._v(\" 07 链表（下）\")]),_._v(\" \"),a(\"h3\",{attrs:{id:\"写链表代码的技巧\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#写链表代码的技巧\",\"aria-hidden\":\"true\"}},[_._v(\"#\")]),_._v(\" 写链表代码的技巧\")]),_._v(\" \"),a(\"ol\",[a(\"li\",[a(\"p\",[_._v(\"理解指针或引用的含义\")]),_._v(\" \"),a(\"p\",[_._v(\"将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。\")])]),_._v(\" \"),a(\"li\",[a(\"p\",[_._v(\"警惕指针丢失和内存泄漏\")]),_._v(\" \"),a(\"ul\",[a(\"li\",[_._v(\"插入结点时，一定要注意操作的顺序\")]),_._v(\" \"),a(\"li\",[_._v(\"删除链表结点时，也一定要记得手动释放内存空间（自动管理内存的语言除外）\")])])]),_._v(\" \"),a(\"li\",[a(\"p\",[_._v(\"利用哨兵简化实现难度\")]),_._v(\" \"),a(\"p\",[_._v(\"链表中的“哨兵”节点是解决边界问题的，不参与业务逻辑。如果我们引入“哨兵”节点，则不管链表是否为空，head指针都会指向这个“哨兵”节点。\")]),_._v(\" \"),a(\"p\",[_._v(\"我们把这种有“哨兵”节点的链表称为带头链表，相反，没有“哨兵”节点的链表就称为不带头链表。\")])]),_._v(\" \"),a(\"li\",[a(\"p\",[_._v(\"重点留意边界条件处理\")]),_._v(\" \"),a(\"ul\",[a(\"li\",[_._v(\"如果链表为空时，代码是否能正常工作？\")]),_._v(\" \"),a(\"li\",[_._v(\"如果链表只包含一个结点时，代码是否能正常工作？\")]),_._v(\" \"),a(\"li\",[_._v(\"如果链表只包含两个结点时，代码是否能正常工作？\")]),_._v(\" \"),a(\"li\",[_._v(\"代码逻辑在处理头结点和尾结点的时候，是否能正常工作？\")])])]),_._v(\" \"),a(\"li\",[a(\"p\",[_._v(\"举例画图，辅助思考\")])]),_._v(\" \"),a(\"li\",[a(\"p\",[_._v(\"多写多练，没有捷径\")])])]),_._v(\" \"),a(\"h3\",{attrs:{id:\"常见链表题\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#常见链表题\",\"aria-hidden\":\"true\"}},[_._v(\"#\")]),_._v(\" 常见链表题\")]),_._v(\" \"),a(\"ul\",[a(\"li\",[_._v(\"单链表反转\")]),_._v(\" \"),a(\"li\",[_._v(\"链表中环的检测\")]),_._v(\" \"),a(\"li\",[_._v(\"两个有序的链表合并\")]),_._v(\" \"),a(\"li\",[_._v(\"删除链表倒数第 n 个结点\")]),_._v(\" \"),a(\"li\",[_._v(\"求链表的中间结点\")])]),_._v(\" \"),a(\"h3\",{attrs:{id:\"tips\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#tips\",\"aria-hidden\":\"true\"}},[_._v(\"#\")]),_._v(\" tips\")]),_._v(\" \"),a(\"ul\",[a(\"li\",[a(\"p\",[_._v(\"利用 LeetCode 刷题\")]),_._v(\" \"),a(\"p\",[_._v(\"LeetCode上的测试用例往往很全，能测试出特殊情况下的 bug\")])]),_._v(\" \"),a(\"li\",[a(\"p\",[_._v(\"不用太纠结\")]),_._v(\" \"),a(\"p\",[_._v(\"在一定时间内实在想不出来就去搜一下答案，没必要一直纠结。有些巧妙的解题思路确实不是很好想出来的。\")])])])])},[],!1,null,null,null);v.default=r.exports}}]);","extractedComments":[]}