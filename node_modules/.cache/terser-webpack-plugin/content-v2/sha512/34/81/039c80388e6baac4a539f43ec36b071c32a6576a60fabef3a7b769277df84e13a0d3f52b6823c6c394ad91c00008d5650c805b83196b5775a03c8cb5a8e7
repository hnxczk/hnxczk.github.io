{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{300:function(t,e,n){t.exports=n.p+\"assets/img/obj-6.4bb0781b.png\"},301:function(t,e,n){t.exports=n.p+\"assets/img/obj-7.25d4cd91.png\"},302:function(t,e,n){t.exports=n.p+\"assets/img/obj-8.d7005f78.png\"},303:function(t,e,n){t.exports=n.p+\"assets/img/obj-9.af8eb7ed.png\"},304:function(t,e,n){t.exports=n.p+\"assets/img/obj-2.b5141953.png\"},305:function(t,e,n){t.exports=n.p+\"assets/img/obj-3.f5ea97a6.png\"},306:function(t,e,n){t.exports=n.p+\"assets/img/obj-4.a4144a76.png\"},307:function(t,e,n){t.exports=n.p+\"assets/img/obj-5.4aa546fe.png\"},308:function(t,e,n){t.exports=n.p+\"assets/img/obj-10.60b6a198.png\"},309:function(t,e,n){t.exports=n.p+\"assets/img/obj-11.f69f78fa.png\"},310:function(t,e,n){t.exports=n.p+\"assets/img/obj-12.784154a0.png\"},311:function(t,e,n){t.exports=n.p+\"assets/img/obj-13.dda96726.png\"},312:function(t,e,n){t.exports=n.p+\"assets/img/obj-14.59c32c9c.png\"},414:function(t,e,n){\"use strict\";n.r(e);var o=n(0),r=Object(o.a)({},function(){var t=this,e=t.$createElement,o=t._self._c||e;return o(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[o(\"h1\",{attrs:{id:\"对象与原型链\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#对象与原型链\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 对象与原型链\")]),t._v(\" \"),o(\"h2\",{attrs:{id:\"基于类和基于原型\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#基于类和基于原型\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 基于类和基于原型\")]),t._v(\" \"),o(\"p\",[t._v(\"我们都知道 JavaScript 是一个面向对象的语言，但是它却没有其他诸如 Java、C++ 这些面向对象的语言中都存在\"),o(\"strong\",[t._v(\"类\")]),t._v(\"的这个概念。取而代之的是\"),o(\"strong\",[t._v(\"原型\")]),t._v(\"的概念。这其实就是两种不同的编程范式。\")]),t._v(\" \"),o(\"ol\",[o(\"li\",[o(\"p\",[t._v(\"基于类的面向对象\")]),t._v(\" \"),o(\"p\",[t._v(\"在这种范式中，类定义了对象的结构和行为以及继承关系，所有基于该类的对象都有\"),o(\"strong\",[t._v(\"相同\")]),t._v(\"的行为和结构，不同的只是他们的状态。\")]),t._v(\" \"),o(\"p\",[t._v(\"创建新的对象通过类的构造器来创建。只有少数基于类的面向对象语言允许类在运行时进行修改。\")])]),t._v(\" \"),o(\"li\",[o(\"p\",[t._v(\"基于原型的面向对象\")]),t._v(\" \"),o(\"p\",[t._v(\"在这种范式中，关注的是一系列对象的行为，将拥有\"),o(\"strong\",[t._v(\"相似\")]),t._v(\"行为的对象通过原型链串联起来。\")]),t._v(\" \"),o(\"p\",[t._v(\"创建新的对象通过拓展原有对象创建。很多的基于原型的语言提倡运行时对原型进行修改。\")])])]),t._v(\" \"),o(\"p\",[t._v(\"我们可以看出来基于原型相对来说更加灵活。这也许是 JavaScript 选择基于原型构建面向对象的原因之一吧。\")]),t._v(\" \"),o(\"h2\",{attrs:{id:\"对象：无序属性的集合\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#对象：无序属性的集合\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 对象：无序属性的集合\")]),t._v(\" \"),o(\"p\",[t._v(\"ECMA262 把对象定义为：无序属性的集合，其属性可以包含基本值、对象或者函数。\")]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v(\"var obj = {\\n    a: 5,\\n    b: function() {},\\n    c:{ d: 10 }\\n}\\n\")])])]),o(\"p\",[t._v(\"在上面这段代码中 基本类型 a，函数 b，对象 c 都是对象 obj 的属性。\")]),t._v(\" \"),o(\"p\",[t._v(\"实际上 JavaScript 中函数也可以添加属性。\")]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v(\"var fun = function(){}\\nfun.a = 5\\nfun.b = function() {}\\nfun.c = { d: 10 }\\n\")])])]),o(\"p\",[t._v(\"因此我们可以推断出来函数也是属性的集合，它也是对象。\")]),t._v(\" \"),o(\"h2\",{attrs:{id:\"构造函数\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#构造函数\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 构造函数\")]),t._v(\" \"),o(\"p\",[t._v(\"‘面向对象编程’的第一步，就是要生成对象。在基于类的语言中类都有创建对象的构造函数。而在 JavaScript 中没有类，生成对象的工作就交由函数来完成。这种函数被称为构造函数。\"),o(\"strong\",[t._v(\"所有对象\")]),t._v(\"都有一个 constructor 的属性指向它的构建函数。\")]),t._v(\" \"),o(\"p\",[t._v(\"你可能会提出反对意见：\")]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v(\"var obj = { a: 5, b: 10 }\\nvar fun = function(){}\\n\")])])]),o(\"p\",[t._v(\"你会说 obj 和 fun 都是对象，但他们都没有通过函数生成啊。\")]),t._v(\" \"),o(\"p\",[t._v(\"其实这是 JavaScript 提供的语法糖，本质上他们会分别调用 Object 和 Function （注意大写）这两个\"),o(\"strong\",[t._v(\"函数\")]),t._v(\"来生成。\")]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v(\"obj.constructor // ƒ Object() { [native code] }\\nfun.constructor // ƒ Function() { [native code] }\\n\")])])]),o(\"p\",[t._v(\"因此上面的代码等同于：\")]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v(\"// var obj = { a: 5, b: 10 }\\nvar obj = new Object()\\nobj.a = 5\\nobj.b = 10\\n\\n// var fun = function(){} \\nvar fun = new Function()\\n\")])])]),o(\"p\",[t._v(\"除了 Object 和 Function 这两个函数外，你也可以自定义构造函数。函数要具备下面的特征：\")]),t._v(\" \"),o(\"ul\",[o(\"li\",[t._v(\"为区别于普通函数，通常构造函数名首字母大写；\")]),t._v(\" \"),o(\"li\",[t._v(\"构造函数必须通过 new 命令调用；\")]),t._v(\" \"),o(\"li\",[t._v(\"构造函数内部使用 this 关键字，this 指向当前构造函数生成的对象；\")]),t._v(\" \"),o(\"li\",[t._v(\"构造函数没有 return，默认返回 this。\")])]),t._v(\" \"),o(\"p\",[t._v(\"一个例子\")]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v(\"function Person(name) {\\n    this.name = name\\n}\\nvar peter = new Person('Peter')\\n\")])])]),o(\"p\",[t._v(\"通过例子我们可以看到除了构造函数外还需要 new 运算符，它都做了以下工作：\")]),t._v(\" \"),o(\"ul\",[o(\"li\",[t._v(\"创建一个空对象，作为将要返回的对象实例；\")]),t._v(\" \"),o(\"li\",[t._v(\"将空对象的原型 \"),o(\"code\",[t._v(\"__proto__\")]),t._v(\" 指向了构造函数的 \"),o(\"code\",[t._v(\"prototype\")]),t._v(\" 属性；\")]),t._v(\" \"),o(\"li\",[t._v(\"将空对象赋值给构造函数内部的 this 关键字；\")]),t._v(\" \"),o(\"li\",[t._v(\"开始执行构造函数内部的代码；\")]),t._v(\" \"),o(\"li\",[t._v(\"如果构造器返回的是对象，则返回，否则返回第一步创建的对象。\")])]),t._v(\" \"),o(\"p\",[t._v(\"这里出现了两个容易混淆的概念：\"),o(\"code\",[t._v(\"__proto__\")]),t._v(\" 和 \"),o(\"code\",[t._v(\"prototype\")]),t._v(\"。\")]),t._v(\" \"),o(\"ul\",[o(\"li\",[o(\"code\",[t._v(\"__proto__\")]),t._v(\" 是每个\"),o(\"strong\",[t._v(\"对象\")]),t._v(\"都有的一个属性。指向创建该对象的函数的 prototype。用它来产生一个链，一个原型链，用于寻找方法名或属性，等等。它是个隐藏属性，早期低版本的浏览器甚至不支持这个属性。\")]),t._v(\" \"),o(\"li\",[o(\"code\",[t._v(\"prototype\")]),t._v(\" 是每个\"),o(\"strong\",[t._v(\"函数\")]),t._v(\"都有的一个属性。它本身是一个对象，它的 constructor 指向函数本身。这个属性存在的目的就是在通过 new 来创建对象时构造对象的 \"),o(\"code\",[t._v(\"__proto__\")]),t._v(\" 属性。\")])]),t._v(\" \"),o(\"p\",[t._v(\"知识通过上面的叙述可能理解起来比较困难，我们通过代码和图来仔细分析。\")]),t._v(\" \"),o(\"p\",[t._v(\"对于 Person 函数来说，\")]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v(\"// Person.prototype 是一个对象，它有两个属性 constructor 指向 Person 函数，__proto__ 指向 Object。（先不用理会 Object 这个对象，后面会详细介绍）\\n\\nPerson.prototype \\n/*\\n * {constructor: ƒ}\\n *    constructor: ƒ Person()\\n *    __proto__: Object\\n */\\n\")])])]),o(\"p\",[t._v(\"由于 Person 是函数因此它拥有 \"),o(\"code\",[t._v(\"constructor\")]),t._v(\"、\"),o(\"code\",[t._v(\"__proto__\")]),t._v(\"、\"),o(\"code\",[t._v(\"prototype\")]),t._v(\" 属性。Person.prototype 是只是个普通对象，因此 Person.prototype 拥有 \"),o(\"code\",[t._v(\"constructor\")]),t._v(\"、\"),o(\"code\",[t._v(\"__proto__\")]),t._v(\" 属性。\")]),t._v(\" \"),o(\"p\",[o(\"img\",{attrs:{src:n(300),alt:\"\"}})]),t._v(\" \"),o(\"p\",[t._v(\"对于 peter 来说，它是个对象因此具有 \"),o(\"code\",[t._v(\"constructor\")]),t._v(\"、\"),o(\"code\",[t._v(\"__proto__\")]),t._v(\" 属性。\")]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v(\"// peter 对象的构造函数就是 Person()\\npeter.constructor // ƒ Person() {...}\\n\\n// peter 对象的 __proto__ 属性指向 Person.prototype\\npeter.__proto__ == Person.prototype // true\\n\")])])]),o(\"p\",[o(\"img\",{attrs:{src:n(301),alt:\"\"}})]),t._v(\" \"),o(\"p\",[t._v(\"通过上面的图可以清楚的看到对象和它的构造函数之间的联系，总结一下：\")]),t._v(\" \"),o(\"ol\",[o(\"li\",[t._v(\"每个对象都是由其构造函数生成，并且对象有个 \"),o(\"code\",[t._v(\"constructor\")]),t._v(\" 属性指向构造函数；\")]),t._v(\" \"),o(\"li\",[t._v(\"每个对象都有个原型属性 \"),o(\"code\",[t._v(\"__proto__\")]),t._v(\"，指向其构造函数的 \"),o(\"code\",[t._v(\"prototype\")]),t._v(\" 属性；\")]),t._v(\" \"),o(\"li\",[t._v(\"每个函数都有一个 \"),o(\"code\",[t._v(\"prototype\")]),t._v(\" 属性用于充当构造函数时构建对象的 \"),o(\"code\",[t._v(\"__proto__\")]),t._v(\" 属性。\")])]),t._v(\" \"),o(\"h2\",{attrs:{id:\"原型链\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#原型链\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 原型链\")]),t._v(\" \"),o(\"p\",[t._v(\"看到上面的内容你也许会疑惑为什么要这样设计，其实是因为 JavaScript 也是面向对象的语言，他是通过这样的设计通过构建原型链实现继承的。\")]),t._v(\" \"),o(\"p\",[t._v(\"在上面代码的基础上我们在声明一个 Student 的构造函数\")]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v(\"function Student(name, score) {\\n    Person.call(this, name)\\n    this.score = score\\n}\\n\\n// 只执行上面的语句还不够，需要通过这行代码将它们产生链接也就是继承关系\\nStudent.prototype = Object.create(Person.prototype)\\n\\n// 这段代码是为了让 Student.prototype 的构造函数指向 Student 函数，不指定的话会指向 Person 函数\\nStudent.prototype.constructor = Student\\n\\n// 创建一个对象\\nvar jim = new Student('Jim', 90)\\n\")])])]),o(\"p\",[t._v(\"我们先来分析下内存布局\")]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v(\"Student.prototype.constructor == Student // true\\nStudent.prototype.__proto__ == Person.prototype // true \\n\\njim.__proto__ == Student.prototype // true\\njim.constructor == Student // true \\n\")])])]),o(\"p\",[o(\"img\",{attrs:{src:n(302),alt:\"\"}})]),t._v(\" \"),o(\"p\",[t._v(\"看着这张图我们可以明显的看到一个链条，一个靠 \"),o(\"code\",[t._v(\"__proto__\")]),t._v(\" 属性串联起来的链条，这就是所谓的原型链。\")]),t._v(\" \"),o(\"p\",[o(\"img\",{attrs:{src:n(303),alt:\"\"}})]),t._v(\" \"),o(\"p\",[t._v(\"正是有了原型链当我们访问一个对象的属性时，会先在基本属性中查找，如果没有，再沿着 \"),o(\"code\",[t._v(\"__proto__\")]),t._v(\" 这条链向上找。这样就实现了继承。\")]),t._v(\" \"),o(\"p\",[t._v(\"不过按照我们现在的分析可以发现这个链条在 Person.prototype 这里断了，而且图中有些属性没有标注出来。别急，我们后面来把它慢慢补全。\")]),t._v(\" \"),o(\"h2\",{attrs:{id:\"function-和-object\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#function-和-object\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" Function 和 Object\")]),t._v(\" \"),o(\"p\",[t._v(\"我们先看下面的代码。\")]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v(\"var obj = { a: 5, b: 10 }\\nvar fun = function(){}\\n\")])])]),o(\"p\",[t._v(\"我们知道等价于\")]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v(\"// var obj = { a: 5, b: 10 }\\nvar obj = new Object()\\nobj.a = 5\\nobj.b = 10\\n\\n// var fun = function(){} \\nvar fun = new Function()\\n\")])])]),o(\"p\",[t._v(\"由此可见 Object 和 Function 是两个比较总要的\"),o(\"strong\",[t._v(\"函数对象\")]),t._v(\"。我们来探究下它们的内存布局。\")]),t._v(\" \"),o(\"p\",[t._v(\"因为它们都是对象因此它们都有 \"),o(\"code\",[t._v(\"constructor\")]),t._v(\"、\"),o(\"code\",[t._v(\"__proto__\")]),t._v(\" 属性，又因为他们是函数对象，因此它们都有 \"),o(\"code\",[t._v(\"prototype\")]),t._v(\" 属性。\")]),t._v(\" \"),o(\"p\",[o(\"img\",{attrs:{src:n(304),alt:\"\"}})]),t._v(\" \"),o(\"p\",[t._v(\"对于 Function 来说\")]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v('// 虽然 Function.prototype 返回的类型是 function 但是它的 prototype 属性并不存在，因此它是特殊的函数对象。\\ntypeof Function.prototype // \"function\"\\ntypeof Function.prototype.prototype // \"undefined\"\\n\\n// Function.prototype 与 Function.__proto__ 指向同一个对象\\nFunction.prototype == Function.__proto__\\n\\n// Function.prototype 的 constructor 是 Function 函数\\nFunction.prototype.constructor // ƒ Function() { [native code] }\\n\\n// Function 的 constructor 是 Function 函数自己\\nFunction.constructor // ƒ Function() { [native code] }\\n')])])]),o(\"p\",[t._v(\"可以画出下面的图\")]),t._v(\" \"),o(\"p\",[o(\"img\",{attrs:{src:n(305),alt:\"\"}})]),t._v(\" \"),o(\"p\",[t._v(\"对于 Object 来说\")]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v('// Object.prototype 是一个对象\\ntypeof Object.prototype // \"object\"\\n\\n// Object.__proto__ 与 Object.prototype 指向的不是同一个对象\\nObject.prototype == Object.__proto__ // false\\n// Object.__proto__ 指向 Function.prototype 的对象 \\nObject.__proto__ == Function.prototype // true\\n\\n// Object.prototype 的 constructor 是 Object 函数\\nObject.prototype.constructor // ƒ Object() { [native code] }\\n\\n// Object 的 constructor 是 Function 函数\\nObject.constructor // ƒ Function() { [native code] }\\n')])])]),o(\"p\",[t._v(\"可以画出下面的图\")]),t._v(\" \"),o(\"p\",[o(\"img\",{attrs:{src:n(306),alt:\"\"}})]),t._v(\" \"),o(\"p\",[t._v(\"我们发现还有两个属性没确定分别是 \"),o(\"code\",[t._v(\"Object.prototype.__proto__\")]),t._v(\" 和 \"),o(\"code\",[t._v(\"Function.prototype.__proto__\")]),t._v(\"。我们通过代码在确认一下。\")]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v(\"// Function.prototype 的 __proto__ 属性指向 Object.prototype\\nFunction.prototype.__proto__ == Object.prototype // true\\n\\n// Object.prototype 的 __proto__  属性指向 null\\nObject.prototype.__proto__ // null\\n\")])])]),o(\"p\",[t._v(\"最终得到这个图\")]),t._v(\" \"),o(\"p\",[o(\"img\",{attrs:{src:n(307),alt:\"\"}})]),t._v(\" \"),o(\"p\",[t._v(\"我们再结合上面原型链那部分的内容。\")]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v(\"// Person 函数的构造函数是 Function\\nPerson.constructor // ƒ Function() { [native code] }\\n\\n// Person 函数的原型是 Function.prototype\\nPerson.__proto__ // ƒ () { [native code] }\\nPerson.__proto__ == Function.prototype // true\\n\\n// Student 函数的构造函数是 Function\\nStudent.constructor // ƒ Function() { [native code] }\\n\\n// Student 函数的原型是 Function.prototype\\nStudent.__proto__ // ƒ () { [native code] }\\nStudent.__proto__ == Function.prototype // true\\n\\n// Person.prototype 的原型是 Object.prototype\\nPerson.prototype.__proto__ == Object.prototype\\n\")])])]),o(\"p\",[o(\"img\",{attrs:{src:n(308),alt:\"\"}})]),t._v(\" \"),o(\"p\",[t._v(\"我们可以观察到几条明显的原型链，见下图：\")]),t._v(\" \"),o(\"ol\",[o(\"li\",[t._v(\"绿色的是我们自定义的 Person Student 对象的原型链；\")]),t._v(\" \"),o(\"li\",[t._v(\"其他颜色的是 函数对象的原型链。\")])]),t._v(\" \"),o(\"p\",[o(\"img\",{attrs:{src:n(309),alt:\"\"}})]),t._v(\" \"),o(\"p\",[t._v(\"分析这张图我们可以得出以下结论\")]),t._v(\" \"),o(\"ol\",[o(\"li\",[o(\"strong\",[t._v(\"所有函数的原型都是 \"),o(\"code\",[t._v(\"Function.prototype\")]),t._v(\"，包括 Function 函数自己\")])]),t._v(\" \"),o(\"li\",[o(\"strong\",[t._v(\"所有函数的构造函数都是 Function，包括 Function 函数自己\")])]),t._v(\" \"),o(\"li\",[o(\"strong\",[t._v(\"所有对象的原型终点都是 \"),o(\"code\",[t._v(\"Object.prototype\")]),t._v(\"，包括函数对象和普通对象，而 \"),o(\"code\",[t._v(\"Object.prototype.__proto__\")]),t._v(\" 的原型指向了 \"),o(\"code\",[t._v(\"null\")])])])]),t._v(\" \"),o(\"p\",[t._v(\"这里面有个最初让我比较疑惑的就是 Object 的原型为什么不是 \"),o(\"code\",[t._v(\"Object.prototype\")]),t._v(\" 而是 \"),o(\"code\",[t._v(\"Function.prototype\")])]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v(\"Object.__proto__ == Function.prototype // true\\n\")])])]),o(\"p\",[t._v(\"其实这是因为 Object 本身就是个函数，它跟其他函数一样都是由 Function 来构造的。\")]),t._v(\" \"),o(\"h2\",{attrs:{id:\"与原型链相关的方法\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#与原型链相关的方法\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 与原型链相关的方法\")]),t._v(\" \"),o(\"h3\",{attrs:{id:\"instanceof\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#instanceof\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" instanceof\")]),t._v(\" \"),o(\"p\",[t._v(\"instanceof 主要的作用就是判断一个实例是否属于某种类型，其实现原理就是通过原型链进行判断。\")]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v(\"function new_instance_of(leftVaule, rightVaule) { \\n    let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值\\n    leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值\\n    while (true) {\\n    \\tif (leftVaule === null) {\\n            return false;\\t\\n        }\\n        if (leftVaule === rightProto) {\\n            return true;\\t\\n        } \\n        leftVaule = leftVaule.__proto__ \\n    }\\n}\\n\")])])]),o(\"p\",[t._v(\"可以看出来 instanceof 的实现思路就是判断右值变量的 prototype 是否在左值变量的原型链上。\")]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v(\"jim instanceof Person // true\\njim instanceof Student // true\\n\")])])]),o(\"p\",[t._v(\"参考上方的图我们也可以解释一些看起来比较诡异的判断\")]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v(\"Object instanceof Object // true\\n\")])])]),o(\"p\",[o(\"img\",{attrs:{src:n(310),alt:\"\"}})]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v(\"Function instanceof Function // true\\n\")])])]),o(\"p\",[o(\"img\",{attrs:{src:n(311),alt:\"\"}})]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v(\"Function instanceof Object // true\\n\")])])]),o(\"p\",[o(\"img\",{attrs:{src:n(312),alt:\"\"}})]),t._v(\" \"),o(\"p\",[t._v(\"下面这些你可以自行检测。\")]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v(\"function Foo() { } // 定义一个函数\\n\\nFoo instanceof Object // true\\nFoo instanceof Function // true\\n\")])])]),o(\"h3\",{attrs:{id:\"hasownproperty\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#hasownproperty\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" hasOwnProperty\")]),t._v(\" \"),o(\"p\",[t._v(\"Object.hasOwnProperty() 返回一个布尔值，表示某个对象的实例是否含有指定的属性，而且此属性非原型链继承。用来判断属性是来自实例属性还是原型属性。类似还有 in 操作符，in 操作符只要属性存在，不管实在实例中还是原型中，就会返回 true。同时使用 in 和 hasOwnProperty 就可以判断属性是在原型中还是在实例中。\")]),t._v(\" \"),o(\"h3\",{attrs:{id:\"isprototypeof\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#isprototypeof\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" isPrototypeOf\")]),t._v(\" \"),o(\"p\",[t._v(\"返回一个布尔值，表示指定的对象是否在本对象的原型链中。\")]),t._v(\" \"),o(\"h3\",{attrs:{id:\"getprototypeof\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#getprototypeof\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" getPrototypeOf\")]),t._v(\" \"),o(\"p\",[t._v(\"返回该对象的原型\")]),t._v(\" \"),o(\"h2\",{attrs:{id:\"es6-之前实现继承\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#es6-之前实现继承\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" ES6 之前实现继承\")]),t._v(\" \"),o(\"h2\",{attrs:{id:\"es6-实现继承\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#es6-实现继承\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" ES6 实现继承\")]),t._v(\" \"),o(\"h2\",{attrs:{id:\"参考\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#参考\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 参考\")]),t._v(\" \"),o(\"ol\",[o(\"li\",[o(\"a\",{attrs:{href:\"https://juejin.im/entry/584a1c98ac502e006c5d63b8\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"JavaScript 中的构造函数\"),o(\"OutboundLink\")],1)]),t._v(\" \"),o(\"li\",[o(\"a\",{attrs:{href:\"https://www.jianshu.com/p/3cada0f002f5?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"全方位理解JavaScript面向对象\"),o(\"OutboundLink\")],1)]),t._v(\" \"),o(\"li\",[o(\"a\",{attrs:{href:\"https://www.jianshu.com/p/b0f10a9b584c?utm_campaign=haruki&utm_content=note&utm_medium=reader_share&utm_source=weixin_timeline&from=timeline&isappinstalled=0\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"大话JavaScript对象\"),o(\"OutboundLink\")],1)]),t._v(\" \"),o(\"li\",[o(\"a\",{attrs:{href:\"https://www.cnblogs.com/wangfupeng1988/p/3977924.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"深入理解javascript原型和闭包（完结）\"),o(\"OutboundLink\")],1)]),t._v(\" \"),o(\"li\",[o(\"a\",{attrs:{href:\"https://juejin.im/post/5b0b9b9051882515773ae714\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"浅谈 instanceof 和 typeof 的实现原理\"),o(\"OutboundLink\")],1)])])])},[],!1,null,null,null);e.default=r.exports}}]);","extractedComments":[]}