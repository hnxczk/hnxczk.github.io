{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{342:function(e,a,n){e.exports=n.p+\"assets/img/Sd_Diagram2.143ff46c.png\"},343:function(e,a,n){e.exports=n.p+\"assets/img/Sd_Diagram1.41ff8b0f.png\"},344:function(e,a){e.exports=\"data:image/png;base64,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\"},345:function(e,a){e.exports=\"data:image/png;base64,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\"},383:function(e,a,n){\"use strict\";n.r(a);var o=n(0),t=Object(o.a)({},function(){var e=this,a=e.$createElement,o=e._self._c||a;return o(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[o(\"h1\",{attrs:{id:\"sdwebimage-源码解析\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#sdwebimage-源码解析\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" SDWebImage 源码解析\")]),e._v(\" \"),o(\"p\",[e._v(\"地址：\"),o(\"a\",{attrs:{href:\"https://github.com/rs/SDWebImage\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"https://github.com/rs/SDWebImage\"),o(\"OutboundLink\")],1)]),e._v(\" \"),o(\"p\",[e._v(\"版本：v4.3.3\")]),e._v(\" \"),o(\"p\",[e._v(\"ps: 从 github 直接 down 下来的 zip 包中的 demo 无法正常跑起来，提示缺少某些文件，解决办法就是利用\"),o(\"code\",[e._v(\"git clone --recursive https://github.com/rs/SDWebImage.git\")]),e._v(\"直接 clone。\")]),e._v(\" \"),o(\"p\",[e._v(\"pps: 最新的 demo 中包含了一个 FLAnimatedImageView 的库，大致看了一下这个是用来做一些动图用的。暂时按下不表，我们依然从最常用的功能开始看。\")]),e._v(\" \"),o(\"p\",[o(\"img\",{attrs:{src:n(342),alt:\"官方给出的类图\"}}),e._v(\"\\n上面这是官方给出的类图。可以看出其规模还是很可观的。\")]),e._v(\" \"),o(\"p\",[o(\"img\",{attrs:{src:n(343),alt:\"官方给出的时序图\"}}),e._v(\"\\n从这个时序图可以看出大致的调用层级，然后我们按着这个来分析。\")]),e._v(\" \"),o(\"h2\",{attrs:{id:\"uiimageview-webcache\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#uiimageview-webcache\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" UIImageView + WebCache\")]),e._v(\" \"),o(\"p\",[e._v(\"项目中用到最多的大概是下面这个方法\")]),e._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v('[self.imageView sd_setImageWithURL:[NSURL URLWithString:@\"url\"]\\n                  placeholderImage:[UIImage imageNamed:@\"placeholder.png\"]];\\n')])])]),o(\"p\",[e._v(\"我们按下 command 键 进入方法实现，然后按下 command + shift + j 在目录中选中当前文件。然后我们会发现该方法定义在 \"),o(\"code\",[e._v(\"UIImageView +WebCache\")]),e._v(\" 这个文件中，同时你会看到很多的 \"),o(\"code\",[e._v(\"sd_setImageWithURL......\")]),e._v(\" 方法, 它们最终都会调用下面这个方法\")]),e._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v(\"- (void)sd_internalSetImageWithURL:(nullable NSURL *)url\\n                  placeholderImage:(nullable UIImage *)placeholder\\n                           options:(SDWebImageOptions)options\\n                      operationKey:(nullable NSString *)operationKey\\n                     setImageBlock:(nullable SDSetImageBlock)setImageBlock\\n                          progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock\\n                         completed:(nullable SDExternalCompletionBlock)completedBlock\\n                           context:(nullable NSDictionary<NSString *, id> *)context;\\n\")])])]),o(\"p\",[e._v(\"该方法定义于\"),o(\"code\",[e._v(\"UIView+WebCache\")]),e._v(\"中。为什么不是\"),o(\"code\",[e._v(\"UIImageView+WebCache\")]),e._v(\"而要上一层到 UIView 的分类里呢？ 因为 SDWebImage 框架也支持 UIButton 的下载图片等方法，所以需要在它们的父类：UIView 里面统一一个下载方法。\")]),e._v(\" \"),o(\"h2\",{attrs:{id:\"uiview-webcache\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#uiview-webcache\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" UIView + WebCache\")]),e._v(\" \"),o(\"p\",[o(\"code\",[e._v(\"sd_internalSetImageWithURL\")]),e._v(\"方法的具体实现\")]),e._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v(' // 获取操作的 key，然后根据 key 去取消下载操作。框架中的所有操作实际上都是通过一个 operationDictionary 的 NSMapTable 来管理, 而这个字典实际上是动态的添加到 UIView 上的一个属性。这行代码是要保证没有当前正在进行的异步下载操作, 不会与即将进行的操作发生冲突。\\n    NSString *validOperationKey = operationKey ?: NSStringFromClass([self class]);\\n    [self sd_cancelImageLoadOperationWithKey:validOperationKey];\\n    \\n    // 添加 imageURLKey 外界可通过 sd_imageURL 方法获取当前的 url\\n    objc_setAssociatedObject(self, &imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\\n    \\n    // 设置占位图\\n    if (!(options & SDWebImageDelayPlaceholder)) {\\n        if ([context valueForKey:SDWebImageInternalSetImageGroupKey]) {\\n            dispatch_group_t group = [context valueForKey:SDWebImageInternalSetImageGroupKey];\\n            dispatch_group_enter(group);\\n        }\\n        dispatch_main_async_safe(^{\\n            [self sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock];\\n        });\\n    }\\n    \\n    if (url) {\\n        // 检查加载指示器是否显示\\n        // check if activityView is enabled or not\\n        if ([self sd_showActivityIndicatorView]) {\\n            // 添加指示器\\n            [self sd_addActivityIndicator];\\n        }\\n        \\n        // 重置进度\\n        // reset the progress\\n        self.sd_imageProgress.totalUnitCount = 0;\\n        self.sd_imageProgress.completedUnitCount = 0;\\n        \\n        // 获取manager\\n        SDWebImageManager *manager;\\n        if ([context valueForKey:SDWebImageExternalCustomManagerKey]) {\\n            manager = (SDWebImageManager *)[context valueForKey:SDWebImageExternalCustomManagerKey];\\n        } else {\\n            manager = [SDWebImageManager sharedManager];\\n        }\\n        \\n        __weak __typeof(self)wself = self;\\n        SDWebImageDownloaderProgressBlock combinedProgressBlock = ^(NSInteger receivedSize, NSInteger expectedSize, NSURL * _Nullable targetURL) {\\n            wself.sd_imageProgress.totalUnitCount = expectedSize;\\n            wself.sd_imageProgress.completedUnitCount = receivedSize;\\n            if (progressBlock) {\\n                progressBlock(receivedSize, expectedSize, targetURL);\\n            }\\n        };\\n        // 利用 manger 下载图片\\n        id <SDWebImageOperation> operation = [manager loadImageWithURL:url options:options progress:combinedProgressBlock completed:^(UIImage *image, NSData *data, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) {\\n            // 下载完成的回调\\n            \\n            __strong __typeof (wself) sself = wself;\\n            if (!sself) { return; }\\n            \\n            [sself sd_removeActivityIndicator];\\n            \\n            // if the progress not been updated, mark it to complete state\\n            if (finished && !error && sself.sd_imageProgress.totalUnitCount == 0 && sself.sd_imageProgress.completedUnitCount == 0) {\\n                sself.sd_imageProgress.totalUnitCount = SDWebImageProgressUnitCountUnknown;\\n                sself.sd_imageProgress.completedUnitCount = SDWebImageProgressUnitCountUnknown;\\n            }\\n            // 是否调用完成回调\\n            BOOL shouldCallCompletedBlock = finished || (options & SDWebImageAvoidAutoSetImage);\\n            // 是否不自动设置图片\\n            BOOL shouldNotSetImage = ((image && (options & SDWebImageAvoidAutoSetImage)) ||\\n                                      (!image && !(options & SDWebImageDelayPlaceholder)));\\n            SDWebImageNoParamsBlock callCompletedBlockClojure = ^{\\n                if (!sself) { return; }\\n                // 需要设置图片，调用sd_setNeedsLayout，告诉 runloop 需要重绘，runloop 会在当前循环完成后进行重新绘制\\n                if (!shouldNotSetImage) {\\n                    [sself sd_setNeedsLayout];\\n                }\\n                if (completedBlock && shouldCallCompletedBlock) {\\n                    completedBlock(image, error, cacheType, url);\\n                }\\n            };\\n            \\n            // case 1a: we got an image, but the SDWebImageAvoidAutoSetImage flag is set\\n            // OR\\n            // case 1b: we got no image and the SDWebImageDelayPlaceholder is not set\\n            if (shouldNotSetImage) {\\n                dispatch_main_async_safe(callCompletedBlockClojure);\\n                return;\\n            }\\n            \\n            UIImage *targetImage = nil;\\n            NSData *targetData = nil;\\n            if (image) {\\n                // case 2a: we got an image and the SDWebImageAvoidAutoSetImage is not set\\n                targetImage = image;\\n                targetData = data;\\n            } else if (options & SDWebImageDelayPlaceholder) {\\n                // case 2b: we got no image and the SDWebImageDelayPlaceholder flag is set\\n                targetImage = placeholder;\\n                targetData = nil;\\n            }\\n            \\n            // 检查变换属性是否设置\\n            // check whether we should use the image transition\\n            SDWebImageTransition *transition = nil;\\n            if (finished && (options & SDWebImageForceTransition || cacheType == SDImageCacheTypeNone)) {\\n                transition = sself.sd_imageTransition;\\n            }\\n            \\n            if ([context valueForKey:SDWebImageInternalSetImageGroupKey]) {\\n                dispatch_group_t group = [context valueForKey:SDWebImageInternalSetImageGroupKey];\\n                dispatch_group_enter(group);\\n                dispatch_main_async_safe(^{\\n                    // 设置图片及图片变化\\n                    [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock transition:transition cacheType:cacheType imageURL:imageURL];\\n                });\\n                // ensure completion block is called after custom setImage process finish\\n                dispatch_group_notify(group, dispatch_get_main_queue(), ^{\\n                    callCompletedBlockClojure();\\n                });\\n            } else {\\n                dispatch_main_async_safe(^{\\n                    // 设置图片及图片变化\\n                    [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock transition:transition cacheType:cacheType imageURL:imageURL];\\n                    // 调用完成的回调，确认是否重绘\\n                    callCompletedBlockClojure();\\n                });\\n            }\\n        }];\\n                // 把当前的操作放入字典中\\n        [self sd_setImageLoadOperation:operation forKey:validOperationKey];\\n    } else {\\n        // 未设置url的处理\\n        dispatch_main_async_safe(^{\\n            [self sd_removeActivityIndicator];\\n            if (completedBlock) {\\n                NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:-1 userInfo:@{NSLocalizedDescriptionKey : @\"Trying to load a nil url\"}];\\n                completedBlock(nil, error, SDImageCacheTypeNone, url);\\n            }\\n        });\\n    }\\n')])])]),o(\"p\",[e._v(\"上面代码主要的工作就是先根据 key 取消字典中（这个字典是通过关联属性关联到 UIView 上的）的操作，然后通过 manger 创建操作并放到字典中。期间进行了 url 检测，指示器检测，图片变换检测、图片设置检测以及是否调用回调检测等操作。\")]),e._v(\" \"),o(\"h2\",{attrs:{id:\"sdwebimagemanager\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#sdwebimagemanager\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" SDWebImageManager\")]),e._v(\" \"),o(\"p\",[e._v(\"在上面的方法中我们了解到下载图片的操作是通过 SDWebImageManager 进行的。通过源码和上方的类图我们可以看出这个类是比较核心的一个类，他通过管理 SDImageCache 和 SDWebImageDownloader 这两个类来协调异步下载和图片缓存。\")]),e._v(\" \"),o(\"h3\",{attrs:{id:\"管理策略\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#管理策略\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 管理策略\")]),e._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v(\"typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) {\\n    \\n    // 默认情况下，当URL下载失败时，URL会被列入黑名单，导致库不会再去重试，该标记用于禁用黑名单\\n    SDWebImageRetryFailed = 1 << 0,\\n    \\n    // 默认情况下，图片下载开始于UI交互，该标记禁用这一特性，这样下载延迟到UIScrollView减速时\\n    SDWebImageLowPriority = 1 << 1,\\n    \\n    // 该标记禁用磁盘缓存\\n    SDWebImageCacheMemoryOnly = 1 << 2,\\n    \\n    // 该标记启用渐进式下载，图片在下载过程中是渐渐显示的，如同浏览器一下。\\n    // 默认情况下，图像在下载完成后一次性显示\\n    SDWebImageProgressiveDownload = 1 << 3,\\n    \\n    // 即使图片缓存了，也期望HTTP响应cache control，并在需要的情况下从远程刷新图片。\\n    // 磁盘缓存将被NSURLCache处理而不是SDWebImage，因为SDWebImage会导致轻微的性能下载。\\n    // 该标记帮助处理在相同请求URL后面改变的图片。如果缓存图片被刷新，则完成block会使用缓存图片调用一次\\n    // 然后再用最终图片调用一次\\n    SDWebImageRefreshCached = 1 << 4,\\n    \\n    // 在iOS 4+系统中，当程序进入后台后继续下载图片。这将要求系统给予额外的时间让请求完成\\n    // 如果后台任务超时，则操作被取消\\n    SDWebImageContinueInBackground = 1 << 5,\\n    \\n    // 通过设置NSMutableURLRequest.HTTPShouldHandleCookies = YES;来处理存储在NSHTTPCookieStore中的cookie\\n    SDWebImageHandleCookies = 1 << 6,\\n    \\n    // 允许不受信任的SSL认证\\n    SDWebImageAllowInvalidSSLCertificates = 1 << 7,\\n    \\n    // 默认情况下，图片下载按入队的顺序来执行。该标记将其移到队列的前面，\\n    // 以便图片能立即下载而不是等到当前队列被加载\\n    SDWebImageHighPriority = 1 << 8,\\n    \\n    // 默认情况下，占位图片在加载图片的同时被加载。该标记延迟占位图片的加载直到图片已被加载完成\\n    SDWebImageDelayPlaceholder = 1 << 9,\\n    \\n    // 通常我们不调用动画图片的transformDownloadedImage代理方法，因为大多数转换代码可以管理它。\\n    // 使用这个 flag 则任何情况下都进行转换。\\n    SDWebImageTransformAnimatedImage = 1 << 10,\\n    \\n    // 默认情况下图片下载后就会被设置到视图，但是一些时候我们需要获取设置图片的时机（用来添加过滤或者添加渐变动画）\\n    // 当你想在结束的时候手动设置图片时可以利用这个 flag\\n    SDWebImageAvoidAutoSetImage = 1 << 11,\\n    \\n    // 默认情况下图片下载后就会被设置到视图，但是一些时候我们需要获取设置图片的时机（用来添加过滤或者添加渐变动画）\\n    // 当你想在结束的时候手动设置图片时可以利用这个 flag\\n    SDWebImageAvoidAutoSetImage = 1 << 11,\\n    \\n   // 默认情况下，图片会基于他们的原始大小进行解码，在小内存 iOS 的设备中，这个 flag 会压缩图片。\\n    SDWebImageScaleDownLargeImages = 1 << 12,\\n    \\n   // 默认情况下对于内存缓存的图片并不会去查找磁盘，通过这个标识就可以同时查找磁盘上的内容。\\n    // 建议这个标识与 SDWebImageQueryDiskSync 一起使用确保图片是在同一个 runloop 中加载\\n    SDWebImageQueryDataWhenInMemory = 1 << 13,\\n    \\n   // 默认情况下查找内存缓存是同步的操作，磁盘缓存是异步操作。这个标识可以同步查找磁盘缓存来确认图片的加载在同一个 runloop 中。\\n    // 这个 flag 可以用来避免不适用内存缓存或者其他情况下引起的 cell 重用造成的闪烁问题\\n    SDWebImageQueryDiskSync = 1 << 14,\\n\\n    // 默认情况下没有缓存的情况下就会通过网络下载，这个 flag 可以阻止网络下载，只使用缓存。\\n    SDWebImageFromCacheOnly = 1 << 15,\\n \\n     // 默认情况下可以利用 `SDWebImageTransition` 来实现图片下载完成后进行变换的操作，但是只对下载的图片起作用，利用这个可以对缓存的图片也能起作用\\n    SDWebImageForceTransition = 1 << 16\\n};\\n\")])])]),o(\"h3\",{attrs:{id:\"下载方法\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#下载方法\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 下载方法\")]),e._v(\" \"),o(\"p\",[e._v(\"接下来分析下最重要的下载方法\")]),e._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v(\"- (id <SDWebImageOperation>)loadImageWithURL:(nullable NSURL *)url\\n                                     options:(SDWebImageOptions)options\\n                                    progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock\\n                                   completed:(nullable SDInternalCompletionBlock)completedBlock {\\n    // 没有 completedBlock 被认为是无意义的，直接断言走你\\n    // Invoking this method without a completedBlock is pointless\\n    NSAssert(completedBlock != nil, @\\\"If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead\\\");\\n\\n    // 如果 url 参数传入的是 NSString 则转换为 NSURL\\n    // Very common mistake is to send the URL using NSString object instead of NSURL. For some strange reason, Xcode won't\\n    // throw any warning for this type mismatch. Here we failsafe this error by allowing URLs to be passed as NSString.\\n    if ([url isKindOfClass:NSString.class]) {\\n        url = [NSURL URLWithString:(NSString *)url];\\n    }\\n    \\n    // 防止类型错误\\n    // Prevents app crashing on argument type error like sending NSNull instead of NSURL\\n    if (![url isKindOfClass:NSURL.class]) {\\n        url = nil;\\n    }\\n\\n    // 创建操作对象，需要注意的是这个操作对象只是一个实现了 cancel 方法的 nsobject 对象，他有一个 cacheOperation 的 NSOperation 对象，而 调用 cancel 方法的话会进行一些清理操作\\n    SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];\\n    operation.manager = self;\\n\\n    BOOL isFailedUrl = NO;\\n    if (url) {\\n        // 检查该 url 是否是之前请求失败 url\\n        @synchronized (self.failedURLs) {\\n            isFailedUrl = [self.failedURLs containsObject:url];\\n        }\\n    }\\n    // url 错误，或者该 url 是失败 url 且不要求重试失败 url ，则直接返回\\n    if (url.absoluteString.length == 0 || (!(options & SDWebImageRetryFailed) && isFailedUrl)) {\\n        [self callCompletionBlockForOperation:operation completion:completedBlock error:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil] url:url];\\n        return operation;\\n    }\\n    \\n    // 添加操作到当前运行的操作集合中\\n    @synchronized (self.runningOperations) {\\n        [self.runningOperations addObject:operation];\\n    }\\n    \\n    NSString *key = [self cacheKeyForURL:url];\\n    \\n    // 获取缓存配置\\n    SDImageCacheOptions cacheOptions = 0;\\n    if (options & SDWebImageQueryDataWhenInMemory) cacheOptions |= SDImageCacheQueryDataWhenInMemory;\\n    if (options & SDWebImageQueryDiskSync) cacheOptions |= SDImageCacheQueryDiskSync;\\n    if (options & SDWebImageScaleDownLargeImages) cacheOptions |= SDImageCacheScaleDownLargeImages;\\n    \\n    __weak SDWebImageCombinedOperation *weakOperation = operation;\\n    // 查找缓存\\n    operation.cacheOperation = [self.imageCache queryCacheOperationForKey:key options:cacheOptions done:^(UIImage *cachedImage, NSData *cachedData, SDImageCacheType cacheType) {\\n        __strong __typeof(weakOperation) strongOperation = weakOperation;\\n        if (!strongOperation || strongOperation.isCancelled) {\\n            [self safelyRemoveOperationFromRunning:strongOperation];\\n            return;\\n        }\\n        \\n        // Check whether we should download image from network\\n        // 是否需要下载图片 = （不是只从缓存中获取图片）&& （（没有缓存图片） || （即使有缓存图片，也需要更新缓存图片））&& （（代理没有响应imageManager:shouldDownloadImageForURL:消息，默认返回yes，需要下载图片）|| （imageManager:shouldDownloadImageForURL:返回yes，需要下载图片））\\n        BOOL shouldDownload = (!(options & SDWebImageFromCacheOnly))\\n            && (!cachedImage || options & SDWebImageRefreshCached)\\n            && (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url]);\\n        if (shouldDownload) {\\n            // 有缓存图片 并且 即使图片缓存了，也期望HTTP响应cache control，并在需要的情况下从远程刷新图片。\\n            // 则先返回缓存中的图片给外部，之后继续从网络下载并刷新缓存中的图片\\n            if (cachedImage && options & SDWebImageRefreshCached) {\\n                // If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image\\n                // AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.\\n                [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url];\\n            }\\n\\n            // 下载策略\\n            // download if no image or requested to refresh anyway, and download allowed by delegate\\n            SDWebImageDownloaderOptions downloaderOptions = 0;\\n            if (options & SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;\\n            if (options & SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload;\\n            if (options & SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache;\\n            if (options & SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground;\\n            if (options & SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies;\\n            if (options & SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates;\\n            if (options & SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority;\\n            if (options & SDWebImageScaleDownLargeImages) downloaderOptions |= SDWebImageDownloaderScaleDownLargeImages;\\n            \\n            // 如果是刷新缓存操作，不执行渐进下载，同时需要执行缓存操作\\n            if (cachedImage && options & SDWebImageRefreshCached) {\\n                // force progressive off if image already cached but forced refreshing\\n                downloaderOptions &= ~SDWebImageDownloaderProgressiveDownload;\\n                // ignore image read from NSURLCache if image if cached but force refreshing\\n                downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse;\\n            }\\n            \\n            // `SDWebImageCombinedOperation` -> `SDWebImageDownloadToken` -> `downloadOperationCancelToken`, which is a `SDCallbacksDictionary` and retain the completed block below, so we need weak-strong again to avoid retain cycle\\n            __weak typeof(strongOperation) weakSubOperation = strongOperation;\\n            strongOperation.downloadToken = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) {\\n                __strong typeof(weakSubOperation) strongSubOperation = weakSubOperation;\\n                if (!strongSubOperation || strongSubOperation.isCancelled) {\\n                    // Do nothing if the operation was cancelled\\n                    // See #699 for more details\\n                    // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data\\n                } else if (error) {\\n                    [self callCompletionBlockForOperation:strongSubOperation completion:completedBlock error:error url:url];\\n                    BOOL shouldBlockFailedURL;\\n                    // Check whether we should block failed url\\n                    if ([self.delegate respondsToSelector:@selector(imageManager:shouldBlockFailedURL:withError:)]) {\\n                        shouldBlockFailedURL = [self.delegate imageManager:self shouldBlockFailedURL:url withError:error];\\n                    } else {\\n                        shouldBlockFailedURL = (   error.code != NSURLErrorNotConnectedToInternet\\n                                                && error.code != NSURLErrorCancelled\\n                                                && error.code != NSURLErrorTimedOut\\n                                                && error.code != NSURLErrorInternationalRoamingOff\\n                                                && error.code != NSURLErrorDataNotAllowed\\n                                                && error.code != NSURLErrorCannotFindHost\\n                                                && error.code != NSURLErrorCannotConnectToHost\\n                                                && error.code != NSURLErrorNetworkConnectionLost);\\n                    }\\n                    // 下载失败，并且排除上述网络原因，将该 Url 置为操作失败的 Url\\n                    if (shouldBlockFailedURL) {\\n                        @synchronized (self.failedURLs) {\\n                            [self.failedURLs addObject:url];\\n                        }\\n                    }\\n                }\\n                else {\\n                    // 下载成功后尝试去清除 SDWebImageRetryFailed 策略下的失败 url\\n                    if ((options & SDWebImageRetryFailed)) {\\n                        @synchronized (self.failedURLs) {\\n                            [self.failedURLs removeObject:url];\\n                        }\\n                    }\\n                    \\n                    BOOL cacheOnDisk = !(options & SDWebImageCacheMemoryOnly);\\n                    \\n                    // 对一些情况下的图片进行缩放处理\\n                    // We've done the scale process in SDWebImageDownloader with the shared manager, this is used for custom manager and avoid extra scale.\\n                    if (self != [SDWebImageManager sharedManager] && self.cacheKeyFilter && downloadedImage) {\\n                        downloadedImage = [self scaledImageForKey:key image:downloadedImage];\\n                    }\\n\\n                    if (options & SDWebImageRefreshCached && cachedImage && !downloadedImage) {\\n                        // Image refresh hit the NSURLCache cache, do not call the completion block\\n                        // 设置了 NSUrlCache 作为默认缓存，则不执行自定义的缓存\\n                    }\\n                    //（下载图片成功 && （没有动图||处理动图） && （下载之后，缓存之前处理图片）\\n                    else if (downloadedImage && (!downloadedImage.images || (options & SDWebImageTransformAnimatedImage)) && [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) {\\n                        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{\\n                            // 通过代理对图片进行转换\\n                            UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];\\n\\n                            if (transformedImage && finished) {\\n                                BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];\\n                                NSData *cacheData;\\n                                // pass nil if the image was transformed, so we can recalculate the data from the image\\n                                if (self.cacheSerializer) {\\n                                    cacheData = self.cacheSerializer(transformedImage, (imageWasTransformed ? nil : downloadedData), url);\\n                                } else {\\n                                    cacheData = (imageWasTransformed ? nil : downloadedData);\\n                                }\\n                                // 缓存图片\\n                                [self.imageCache storeImage:transformedImage imageData:cacheData forKey:key toDisk:cacheOnDisk completion:nil];\\n                            }\\n                            // 将图片传入 completedBlock\\n                            [self callCompletionBlockForOperation:strongSubOperation completion:completedBlock image:transformedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url];\\n                        });\\n                    }\\n                    // (图片下载成功并结束)\\n                    else {\\n                        if (downloadedImage && finished) {\\n                            if (self.cacheSerializer) {\\n                                dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{\\n                                    NSData *cacheData = self.cacheSerializer(downloadedImage, downloadedData, url);\\n                                    [self.imageCache storeImage:downloadedImage imageData:cacheData forKey:key toDisk:cacheOnDisk completion:nil];\\n                                });\\n                            } else {\\n                                [self.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:nil];\\n                            }\\n                        }\\n                        [self callCompletionBlockForOperation:strongSubOperation completion:completedBlock image:downloadedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url];\\n                    }\\n                }\\n                // 如果完成，从当前运行的操作列表里移除当前操作\\n                if (finished) {\\n                    [self safelyRemoveOperationFromRunning:strongSubOperation];\\n                }\\n            }];\\n        }\\n        // 存在缓存图片\\n        else if (cachedImage) {\\n            // 调用完成的block\\n            [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url];\\n            // 删去当前的下载操作\\n            [self safelyRemoveOperationFromRunning:strongOperation];\\n        }\\n        // 没有缓存的图片，而且下载被代理终止了\\n        else {\\n            // Image not in cache and download disallowed by delegate\\n            [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:nil data:nil error:nil cacheType:SDImageCacheTypeNone finished:YES url:url];\\n            [self safelyRemoveOperationFromRunning:strongOperation];\\n        }\\n    }];\\n\\n    return operation;\\n}\\n\")])])]),o(\"p\",[e._v(\"该方法主要用于获取图片，根据设置的策略从缓存中或者从网络下载图片并缓存。并返回 operation。\")]),e._v(\" \"),o(\"h3\",{attrs:{id:\"sdwebimagecombinedoperation\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#sdwebimagecombinedoperation\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" SDWebImageCombinedOperation\")]),e._v(\" \"),o(\"p\",[e._v('当 url 被正确传入之后, 会实例一个非常奇怪的 \"operation\", 它其实是一个遵循 SDWebImageOperation 协议的 NSObject 的子类. 而这个协议也非常的简单:')]),e._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v(\"@protocol SDWebImageOperation <NSObject>\\n\\n- (void)cancel;\\n\\n@end\\n\")])])]),o(\"p\",[e._v(\"这里仅仅是将这个 SDWebImageOperation 类包装成一个看着像 NSOperation 其实并不是 NSOperation 的类, 而这个类唯一与 NSOperation 的相同之处就是它们都可以响应 cancel 方法.\")]),e._v(\" \"),o(\"p\",[e._v(\"而调用这个类的存在实际是为了使代码更加的简洁, 因为调用这个类的 cancel 方法, 会使得它持有的查找缓存和下载图片的两个 operation 都被 cancel.\")]),e._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v(\"@interface SDWebImageCombinedOperation : NSObject <SDWebImageOperation>\\n\\n@property (assign, nonatomic, getter = isCancelled) BOOL cancelled;\\n// downloadToken 中包含下载的 Operation 以及其对应的 token\\n@property (strong, nonatomic, nullable) SDWebImageDownloadToken *downloadToken;\\n// cacheOperation 指查询缓存的 Operation\\n@property (strong, nonatomic, nullable) NSOperation *cacheOperation;\\n@property (weak, nonatomic, nullable) SDWebImageManager *manager;\\n\\n@end\\n\\n@implementation SDWebImageCombinedOperation\\n\\n- (void)cancel {\\n    @synchronized(self) {\\n        self.cancelled = YES;\\n        if (self.cacheOperation) {\\n            [self.cacheOperation cancel];\\n            self.cacheOperation = nil;\\n        }\\n        if (self.downloadToken) {\\n            [self.manager.imageDownloader cancel:self.downloadToken];\\n        }\\n        [self.manager safelyRemoveOperationFromRunning:self];\\n    }\\n}\\n\\n@end\\n\")])])]),o(\"p\",[e._v(\"而这个类, 应该是为了实现更简洁的 cancel 操作而设计出来的.\")]),e._v(\" \"),o(\"h2\",{attrs:{id:\"sdwebimagecache\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#sdwebimagecache\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" SDWebImageCache\")]),e._v(\" \"),o(\"p\",[e._v(\"从源码可以看出该类在创建的时候可以通过设置namespace和存储位置来区分不同的缓存。并且该类有个串行队列来管理 IO 操作。\")]),e._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v('_ioQueue = dispatch_queue_create(\"com.hackemist.SDWebImageCache\", DISPATCH_QUEUE_SERIAL);\\n')])])]),o(\"p\",[e._v(\"而在上面 manger 的 \"),o(\"code\",[e._v(\"loadImageWithURL\")]),e._v(\" 方法中可以看到跟缓存相关的两个重要方法 \"),o(\"code\",[e._v(\"queryCacheOperationForKey\")]),e._v(\" 和 \"),o(\"code\",[e._v(\"storeImage\")])]),e._v(\" \"),o(\"h3\",{attrs:{id:\"querycacheoperationforkey\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#querycacheoperationforkey\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" queryCacheOperationForKey\")]),e._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v(\"- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key options:(SDImageCacheOptions)options done:(nullable SDCacheQueryCompletedBlock)doneBlock {\\n    if (!key) {\\n        if (doneBlock) {\\n            doneBlock(nil, nil, SDImageCacheTypeNone);\\n        }\\n        return nil;\\n    }\\n    \\n    // 首先查找内存缓存\\n    // First check the in-memory cache...\\n    UIImage *image = [self imageFromMemoryCacheForKey:key];\\n    BOOL shouldQueryMemoryOnly = (image && !(options & SDImageCacheQueryDataWhenInMemory));\\n    if (shouldQueryMemoryOnly) {\\n        if (doneBlock) {\\n            doneBlock(image, nil, SDImageCacheTypeMemory);\\n        }\\n        return nil;\\n    }\\n    \\n    NSOperation *operation = [NSOperation new];\\n    // 封装 block 是为了后面同步或者异步执行\\n    void(^queryDiskBlock)(void) =  ^{\\n        if (operation.isCancelled) {\\n            // do not call the completion if cancelled\\n            return;\\n        }\\n        \\n        // 创建自动释放池来及时释放内存占用较大的临时变量\\n        @autoreleasepool {\\n            NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key];\\n            UIImage *diskImage;\\n            SDImageCacheType cacheType = SDImageCacheTypeDisk;\\n            if (image) {\\n                // the image is from in-memory cache\\n                diskImage = image;\\n                cacheType = SDImageCacheTypeMemory;\\n            } else if (diskData) {\\n                // decode image data only if in-memory cache missed\\n                diskImage = [self diskImageForKey:key data:diskData options:options];\\n                if (diskImage && self.config.shouldCacheImagesInMemory) {\\n                    // cost 被用来计算缓存中所有对象的代价。当内存受限或者所有缓存对象的总代价超过了最大允许的值时，缓存会移除其中的一些对象。\\n                    NSUInteger cost = SDCacheCostForImage(diskImage);\\n                    [self.memCache setObject:diskImage forKey:key cost:cost];\\n                }\\n            }\\n            \\n            if (doneBlock) {\\n                if (options & SDImageCacheQueryDiskSync) {\\n                    doneBlock(diskImage, diskData, cacheType);\\n                } else {\\n                    dispatch_async(dispatch_get_main_queue(), ^{\\n                        doneBlock(diskImage, diskData, cacheType);\\n                    });\\n                }\\n            }\\n        }\\n    };\\n    \\n    if (options & SDImageCacheQueryDiskSync) {\\n        // 同步调用 block\\n        queryDiskBlock();\\n    } else {\\n        // 异步调用 block\\n        dispatch_async(self.ioQueue, queryDiskBlock);\\n    }\\n    \\n    return operation;\\n}\\n\")])])]),o(\"h3\",{attrs:{id:\"storeimage\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#storeimage\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" storeImage\")]),e._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v(\"- (void)storeImage:(nullable UIImage *)image\\n         imageData:(nullable NSData *)imageData\\n            forKey:(nullable NSString *)key\\n            toDisk:(BOOL)toDisk\\n        completion:(nullable SDWebImageNoParamsBlock)completionBlock {\\n    if (!image || !key) {\\n        if (completionBlock) {\\n            completionBlock();\\n        }\\n        return;\\n    }\\n    // if memory cache is enabled\\n    // 设置内存缓存\\n    if (self.config.shouldCacheImagesInMemory) {\\n        NSUInteger cost = SDCacheCostForImage(image);\\n        [self.memCache setObject:image forKey:key cost:cost];\\n    }\\n    // 添加到磁盘\\n    if (toDisk) {\\n        // 如果确定需要磁盘缓存，则将缓存操作作为一个任务放入ioQueue中\\n        // 异步io串行队列，为什么用串行？因为涉及到写入操作，怕对应的key话发生混乱，也就是怕产生的文件名和存入磁盘的数据不对应所以磁盘存储都要一个个存储，这样就可以不用去加锁了，为什么要进行加锁，因为并发情况下这些存储操作都不是线程安全的，但使用了串行队列就完全不需要考虑加锁释放锁\\n        dispatch_async(self.ioQueue, ^{\\n            @autoreleasepool {\\n                NSData *data = imageData;\\n                if (!data && image) {\\n                    // If we do not have any data to detect image format, check whether it contains alpha channel to use PNG or JPEG format\\n                    // 检查是否包含alpha通道，因为jpeg是有损压缩格式, 将像素信息用jpeg保存成文件再读取出来，其中某些像素值会有少许变化。没有透明信息jpeg比较适合用来存储相机拍摄出来的图片。png是一种无损压缩格式，它可以有透明效果，png比较适合矢量图,几何图.所以下面如果包含Alpha的图片就把它的格式定义为PNG，如果没有则定位为JPEG\\n                    SDImageFormat format;\\n                    if (SDCGImageRefContainsAlpha(image.CGImage)) {\\n                        format = SDImageFormatPNG;\\n                    } else {\\n                        format = SDImageFormatJPEG;\\n                    }\\n                    // 然后再根据 format 进行对 UIImage 编码，编码过程，这里指的就是将一个 UIImage 表示的图像，编码为对应图像格式的数据，输出一个 NSData 的过程\\n                    data = [[SDWebImageCodersManager sharedInstance] encodedDataWithImage:image format:format];\\n                }\\n                // 存储到磁盘中\\n                [self _storeImageDataToDisk:data forKey:key];\\n            }\\n            \\n            if (completionBlock) {\\n                dispatch_async(dispatch_get_main_queue(), ^{\\n                    completionBlock();\\n                });\\n            }\\n        });\\n    } else {\\n        if (completionBlock) {\\n            completionBlock();\\n        }\\n    }\\n}\\n\")])])]),o(\"p\",[e._v(\"关于存储相关的更详细说明可以看 \"),o(\"a\",{attrs:{href:\"https://blog.csdn.net/ZCMUCZX/article/details/79491589\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"这里\"),o(\"OutboundLink\")],1)]),e._v(\" \"),o(\"h3\",{attrs:{id:\"sdmemorycache\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#sdmemorycache\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" SDMemoryCache\")]),e._v(\" \"),o(\"p\",[e._v(\"该类是用来管理内存缓存的类。其继承自NSCache。内部有两个属性\")]),e._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v(\"// 存储用的表\\n@property (nonatomic, strong, nonnull) NSMapTable<KeyType, ObjectType> *weakCache; \\n// 保证线程安全的信号量\\n@property (nonatomic, strong, nonnull) dispatch_semaphore_t weakCacheLock; \\n\")])])]),o(\"p\",[e._v(\"并且提供以下两个宏，方便进行加锁和解锁\")]),e._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v(\"#define LOCK(lock) dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);\\n#define UNLOCK(lock) dispatch_semaphore_signal(lock);\\n\")])])]),o(\"p\",[e._v(\"使用\"),o(\"code\",[e._v(\"dispatch_semaphore_t\")]),e._v(\"来保证线程安全是一个性能较好的解决方案，具体可以参考我的另一篇 \"),o(\"router-link\",{attrs:{to:\"/articles/locks.html\"}},[e._v(\"文章\")])],1),e._v(\" \"),o(\"p\",[e._v(\"而对于 weakCache 这个表来说，我们可以看到在存的时候会在 weakCache 和这个类本身中都保存，而在收到内存警告的时候会清空NSCache，而 weakCache 则没有清理。取的时候会先去 NSCache 本身中取，如果为空则去 weakCache 中去取，如果有会从新设置到 NSCache 中。\")]),e._v(\" \"),o(\"h2\",{attrs:{id:\"sdwebimagedownloader\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#sdwebimagedownloader\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" SDWebImageDownloader\")]),e._v(\" \"),o(\"p\",[e._v(\"它是一个异步下载器，并对图像加载做了优化处理。\")]),e._v(\" \"),o(\"h3\",{attrs:{id:\"下载选项\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#下载选项\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 下载选项\")]),e._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v(\"typedef NS_OPTIONS(NSUInteger, SDWebImageDownloaderOptions) {\\n\\t // 设置图片下载队列的优先级为低优先级\\n    SDWebImageDownloaderLowPriority = 1 << 0,\\n    \\n    // 图片会随着下载进度慢慢显示\\n    SDWebImageDownloaderProgressiveDownload = 1 << 1,\\n    \\n    // 默认情况下请求不使用NSURLCache，如果设置该选项，则以默认的缓存策略来使用NSURLCache\\n    SDWebImageDownloaderUseNSURLCache = 1 << 2,\\n    \\n    // 如果从NSURLCache缓存中读取图片，则使用nil作为参数来调用完成block\\n    SDWebImageDownloaderIgnoreCachedResponse = 1 << 3,\\n    \\n\\t// 在iOS 4+系统上，允许程序进入后台后继续下载图片。该操作通过向系统申请额外的时间来完成后台下载。如果后台任务终止，则操作会被取消\\n    SDWebImageDownloaderContinueInBackground = 1 << 4,\\n    \\n    // 通过设置NSMutableURLRequest.HTTPShouldHandleCookies = YES来处理存储在NSHTTPCookieStore中的cookie\\n    SDWebImageDownloaderHandleCookies = 1 << 5,\\n    \\n    // 允许不受信任的SSL证书。主要用于测试目的。\\n    SDWebImageDownloaderAllowInvalidSSLCertificates = 1 << 6,\\n    \\n    // 将图片下载放到高优先级队列中\\n    SDWebImageDownloaderHighPriority = 1 << 7,\\n    \\n    // 压缩图片\\n    SDWebImageDownloaderScaleDownLargeImages = 1 << 8,\\n};\\n\")])])]),o(\"h3\",{attrs:{id:\"downloadimagewithurl\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#downloadimagewithurl\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" downloadImageWithURL\")]),e._v(\" \"),o(\"p\",[e._v(\"通过制定 url 来下载，代码中可以看到先调用了 \"),o(\"code\",[e._v(\"addProgressCallback\")]),e._v(\" 并在传入的 block 中设置了请求头等一系列参数并根据 request 返回了一个 operation。\")]),e._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v('- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url\\n                                                   options:(SDWebImageDownloaderOptions)options\\n                                                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock\\n                                                 completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock {\\n    __weak SDWebImageDownloader *wself = self;\\n    \\n    return [self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation *{\\n        __strong __typeof (wself) sself = wself;\\n        // 设置超时时长，默认是15s\\n        NSTimeInterval timeoutInterval = sself.downloadTimeout;\\n        if (timeoutInterval == 0.0) {\\n            timeoutInterval = 15.0;\\n        }\\n\\n        // 保证只使用 NSURLCache 或者 SDImageCache 中的一种，不要同时使用二者\\n        // In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise\\n        NSURLRequestCachePolicy cachePolicy = options & SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData;\\n        // 创建请求\\n        NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url\\n                                                                    cachePolicy:cachePolicy\\n                                                                timeoutInterval:timeoutInterval];\\n        \\n        request.HTTPShouldHandleCookies = (options & SDWebImageDownloaderHandleCookies);\\n        //HTTPShouldUsePipelining设置为YES, 则允许不必等到response, 就可以再次请求. 这个会很大的提高网络请求的效率,但是也可能会出问题\\n        //因为客户端无法正确的匹配请求与响应, 所以这依赖于服务器必须保证,响应的顺序与客户端请求的顺序一致.如果服务器不能保证这一点, 那可能导致响应和请求混乱.\\n        request.HTTPShouldUsePipelining = YES;\\n        \\n        // 设置 HTTP header中的 Accept 来告诉服务器倾向于获取 @\"image/*;q=0.8\" 或者 @\"image/webp,image/*;q=0.8\" 类型的数据\\n        if (sself.headersFilter) {\\n            // 过滤 header\\n            request.allHTTPHeaderFields = sself.headersFilter(url, [sself allHTTPHeaderFields]);\\n        }\\n        else {\\n            // 设置 header\\n            request.allHTTPHeaderFields = [sself allHTTPHeaderFields];\\n        }\\n        \\n        // 使用 operationClass 这个属性来确保生成的 operation 必须遵循 SDWebImageDownloaderOperationInterface 协议\\n        // 否则就从新生成一个 SDWebImageDownloaderOperation 对象\\n        SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options];\\n        operation.shouldDecompressImages = sself.shouldDecompressImages;\\n        \\n        // 进行身份认证\\n        if (sself.urlCredential) {\\n            operation.credential = sself.urlCredential;\\n        } else if (sself.username && sself.password) {\\n            operation.credential = [NSURLCredential credentialWithUser:sself.username password:sself.password persistence:NSURLCredentialPersistenceForSession];\\n        }\\n        \\n        // 下载优先级\\n        if (options & SDWebImageDownloaderHighPriority) {\\n            operation.queuePriority = NSOperationQueuePriorityHigh;\\n        } else if (options & SDWebImageDownloaderLowPriority) {\\n            operation.queuePriority = NSOperationQueuePriorityLow;\\n        }\\n        \\n        // 执行顺序是后进先出（栈）的话进行处理\\n        if (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) {\\n            // Emulate LIFO execution order by systematically adding new operations as last operation\\'s dependency\\n            [sself.lastAddedOperation addDependency:operation];\\n            sself.lastAddedOperation = operation;\\n        }\\n\\n        return operation;\\n    }];\\n}\\n')])])]),o(\"h3\",{attrs:{id:\"addprogresscallback\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#addprogresscallback\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" addProgressCallback\")]),e._v(\" \"),o(\"p\",[e._v(\"这个方法主要作用是获取 URLOperations 中的 operation， 没有的话调用 createCallback 进行创建然后加入到 URLOperations 中。然后把取得的 operation 加入到 queue 中。并且会在 operation 完成的回调中从 URLOperations 去除。\")]),e._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v(\"- (nullable SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock\\n                                           completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock\\n                                                   forURL:(nullable NSURL *)url\\n                                           createCallback:(SDWebImageDownloaderOperation *(^)(void))createCallback {\\n    // The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data.\\n    // url 用来作为回调字典的key，如果为空，立即返回失败\\n    if (url == nil) {\\n        if (completedBlock != nil) {\\n            completedBlock(nil, nil, nil, NO);\\n        }\\n        return nil;\\n    }\\n    \\n    // 使用信号量来确保 URLOperations downloadQueue 的 线程安全\\n    // URLOperations 以下载url作为key value是具体的下载operation 用字典来存储，方便cancel等操作\\n    LOCK(self.operationsLock);\\n    // 根据 url 取出 operation\\n    SDWebImageDownloaderOperation *operation = [self.URLOperations objectForKey:url];\\n    // 没有 operation 的话就会调用 createCallback 来获取\\n    if (!operation) {\\n        operation = createCallback();\\n        __weak typeof(self) wself = self;\\n        // operation 完成的回调中从 URLOperations 中移除\\n        operation.completionBlock = ^{\\n            __strong typeof(wself) sself = wself;\\n            if (!sself) {\\n                return;\\n            }\\n            LOCK(sself.operationsLock);\\n            [sself.URLOperations removeObjectForKey:url];\\n            UNLOCK(sself.operationsLock);\\n        };\\n        // 添加到 URLOperations 中\\n        [self.URLOperations setObject:operation forKey:url];\\n        // Add operation to operation queue only after all configuration done according to Apple's doc.\\n        // `addOperation:` does not synchronously execute the `operation.completionBlock` so this will not cause deadlock.\\n        // 这段代码不会造成死锁的原因是 当 operation 加入 queue 中时并不会同步的执行 operation.completionBlock\\n        [self.downloadQueue addOperation:operation];\\n    }\\n    UNLOCK(self.operationsLock);\\n\\n    // 把 progressBlock 和 completedBlock 放入 callbackBlocks 中\\n    id downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];\\n    \\n    // 生成 token ，后续 manger 可以根据 token 取消相应的操作\\n    SDWebImageDownloadToken *token = [SDWebImageDownloadToken new];\\n    token.downloadOperation = operation;\\n    token.url = url;\\n    token.downloadOperationCancelToken = downloadOperationCancelToken;\\n\\n    return token;\\n}\\n\")])])]),o(\"h2\",{attrs:{id:\"sdwebimagedownloaderoperation\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#sdwebimagedownloaderoperation\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" SDWebImageDownloaderOperation\")]),e._v(\" \"),o(\"p\",[e._v(\"由上面的代码我们可以看出他们做的工作就是生成 operation 然后对 operation 进行一些处理。而\"),o(\"code\",[e._v(\"SDWebImageDownloaderOperation\")]),e._v(\"才是具体的执行图片下载的单位。他继承自 NSOperation ，负责生成 NSURLSessionTask 进行图片请求，支持下载取消和后台下载，在下载中及时汇报下载进度，在下载成功后，对图片进行解码，缩放和压缩等操作。\")]),e._v(\" \"),o(\"h3\",{attrs:{id:\"start\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#start\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" start\")]),e._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v('// 重写operation的start方法，当任务添加到NSOperationQueue后会执行该方法，启动下载任务\\n- (void)start {\\n    //添加锁，防止多线程数据竞争\\n    @synchronized (self) {\\n        if (self.isCancelled) {\\n            self.finished = YES;\\n            [self reset];\\n            return;\\n        }\\n\\n#if SD_UIKIT\\n        // 如调用者配置了在后台可以继续下载图片，那么在这里继续下载\\n        Class UIApplicationClass = NSClassFromString(@\"UIApplication\");\\n        BOOL hasApplication = UIApplicationClass && [UIApplicationClass respondsToSelector:@selector(sharedApplication)];\\n        if (hasApplication && [self shouldContinueWhenAppEntersBackground]) {\\n            __weak __typeof__ (self) wself = self;\\n            UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)];\\n            self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^{\\n                __strong __typeof (wself) sself = wself;\\n\\n                if (sself) {\\n                    [sself cancel];\\n\\n                    [app endBackgroundTask:sself.backgroundTaskId];\\n                    sself.backgroundTaskId = UIBackgroundTaskInvalid;\\n                }\\n            }];\\n        }\\n#endif\\n        // 判断unownedSession是否为了nil，如果是nil则重新创建一个ownedSession\\n        // 注意这里unownedSession使用的属性修饰符是weak，因为unownedSession是从SDWebImageDownloader传过来的，所以需要SDWebImageDownloader管理\\n        // 如果unownedSession是nil，我们需要手动创建一个并且管理它的生命周期和代理方法\\n        NSURLSession *session = self.unownedSession;\\n        if (!session) {\\n            NSURLSessionConfiguration *sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration];\\n            sessionConfig.timeoutIntervalForRequest = 15;\\n            \\n            /**\\n             *  Create the session for this task\\n             *  We send nil as delegate queue so that the session creates a serial operation queue for performing all delegate\\n             *  method calls and completion handler calls.\\n             */\\n            session = [NSURLSession sessionWithConfiguration:sessionConfig\\n                                                    delegate:self\\n                                               delegateQueue:nil];\\n            self.ownedSession = session;\\n        }\\n        \\n        // 获取网络请求的缓存数据\\n        if (self.options & SDWebImageDownloaderIgnoreCachedResponse) {\\n            // Grab the cached data for later check\\n            NSURLCache *URLCache = session.configuration.URLCache;\\n            if (!URLCache) {\\n                URLCache = [NSURLCache sharedURLCache];\\n            }\\n            NSCachedURLResponse *cachedResponse;\\n            // NSURLCache\\'s `cachedResponseForRequest:` is not thread-safe, see https://developer.apple.com/documentation/foundation/nsurlcache#2317483\\n            @synchronized (URLCache) {\\n                cachedResponse = [URLCache cachedResponseForRequest:self.request];\\n            }\\n            if (cachedResponse) {\\n                self.cachedData = cachedResponse.data;\\n            }\\n        }\\n        //使用 session 来创建一个 NSURLSessionDataTask 类型下载任务\\n        self.dataTask = [session dataTaskWithRequest:self.request];\\n        self.executing = YES;\\n    }\\n\\n    if (self.dataTask) {\\n#pragma clang diagnostic push\\n#pragma clang diagnostic ignored \"-Wunguarded-availability\"\\n        if ([self.dataTask respondsToSelector:@selector(setPriority:)]) {\\n            if (self.options & SDWebImageDownloaderHighPriority) {\\n                self.dataTask.priority = NSURLSessionTaskPriorityHigh;\\n            } else if (self.options & SDWebImageDownloaderLowPriority) {\\n                self.dataTask.priority = NSURLSessionTaskPriorityLow;\\n            }\\n        }\\n#pragma clang diagnostic pop\\n        // 开始执行任务\\n        [self.dataTask resume];\\n        // 任务开启，遍历进度块数组 执行第一个下载进度 进度为0\\n        for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) {\\n            progressBlock(0, NSURLResponseUnknownLength, self.request.URL);\\n        }\\n        __weak typeof(self) weakSelf = self;\\n        //在主线程发送通知，并将self传出去，为什么在主线程发送呢？\\n        //因为在哪个线程发送通知就在哪个线程接受通知，这样如果在接受通知方法中执行修改UI的操作也不会有问题\\n        dispatch_async(dispatch_get_main_queue(), ^{\\n            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:weakSelf];\\n        });\\n    } else {\\n        // 如果创建tataTask失败就执行失败的回调块\\n        [self callCompletionBlocksWithError:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorUnknown userInfo:@{NSLocalizedDescriptionKey : @\"Task can\\'t be initialized\"}]];\\n        [self done];\\n        return;\\n    }\\n\\n#if SD_UIKIT\\n    // 后台继续下载\\n    Class UIApplicationClass = NSClassFromString(@\"UIApplication\");\\n    if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) {\\n        return;\\n    }\\n    if (self.backgroundTaskId != UIBackgroundTaskInvalid) {\\n        UIApplication * app = [UIApplication performSelector:@selector(sharedApplication)];\\n        [app endBackgroundTask:self.backgroundTaskId];\\n        self.backgroundTaskId = UIBackgroundTaskInvalid;\\n    }\\n#endif\\n}\\n')])])]),o(\"h3\",{attrs:{id:\"nsurlsessiontaskdelegate\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#nsurlsessiontaskdelegate\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" NSURLSessionTaskDelegate\")]),e._v(\" \"),o(\"p\",[e._v(\"这里只分析了下请求完成的代理方法，在该方法中会对下载完成的图片进行解码。\")]),e._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v('// 下载完成或下载失败时的回调方法\\n- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error {\\n    @synchronized(self) {\\n        self.dataTask = nil;\\n        __weak typeof(self) weakSelf = self;\\n        // 回到主线程发送下载结束的通知\\n        dispatch_async(dispatch_get_main_queue(), ^{\\n            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:weakSelf];\\n            if (!error) {\\n                [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadFinishNotification object:weakSelf];\\n            }\\n        });\\n    }\\n    \\n    // make sure to call `[self done]` to mark operation as finished\\n    // 下载失败则走失败的回调\\n    if (error) {\\n        [self callCompletionBlocksWithError:error];\\n        [self done];\\n    } else {\\n        // 判断下载回调结束块数量是否大于0\\n        if ([self callbacksForKey:kCompletedCallbackKey].count > 0) {\\n            /**\\n             *  If you specified to use `NSURLCache`, then the response you get here is what you need.\\n             */\\n            __block NSData *imageData = [self.imageData copy];\\n            // 如果图片存在\\n            if (imageData) {\\n                /**  if you specified to only use cached data via `SDWebImageDownloaderIgnoreCachedResponse`,\\n                 *  then we should check if the cached data is equal to image data\\n                 */\\n                // 判断调用是否配置了使用缓存，如果是则判断缓存data是否和当前图片一致，如果一致则回调结束\\n                if (self.options & SDWebImageDownloaderIgnoreCachedResponse && [self.cachedData isEqualToData:imageData]) {\\n                    // call completion block with nil\\n                    [self callCompletionBlocksWithImage:nil imageData:nil error:nil finished:YES];\\n                    [self done];\\n                } else {\\n                    // 在 coderQueue 这个串行队列中对图片 data 解码\\n                    // decode the image in coder queue\\n                    dispatch_async(self.coderQueue, ^{\\n                        UIImage *image = [[SDWebImageCodersManager sharedInstance] decodedImageWithData:imageData];\\n                        // 根据图片url获得缓存的key\\n                        NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];\\n                        // 对图片进行缩放\\n                        image = [self scaledImageForKey:key image:image];\\n                        \\n                        BOOL shouldDecode = YES;\\n                        // Do not force decoding animated GIFs and WebPs\\n                        // 针对GIF和WebP图片不做压缩\\n                        if (image.images) {\\n                            shouldDecode = NO;\\n                        } else {\\n#ifdef SD_WEBP\\n                            // sd_imageFormatForImageData分类方法判断是哪种图片格式\\n                            SDImageFormat imageFormat = [NSData sd_imageFormatForImageData:imageData];\\n                            if (imageFormat == SDImageFormatWebP) {\\n                                shouldDecode = NO;\\n                            }\\n#endif\\n                        }\\n                        // 如果是可以压缩的格式，并且调用者也设置了压缩，那么这里开始压缩图片\\n                        if (shouldDecode) {\\n                            if (self.shouldDecompressImages) {\\n                                BOOL shouldScaleDown = self.options & SDWebImageDownloaderScaleDownLargeImages;\\n                                image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&imageData options:@{SDWebImageCoderScaleDownLargeImagesKey: @(shouldScaleDown)}];\\n                            }\\n                        }\\n                        CGSize imageSize = image.size;\\n                        if (imageSize.width == 0 || imageSize.height == 0) {\\n                            [self callCompletionBlocksWithError:[NSError errorWithDomain:SDWebImageErrorDomain code:0 userInfo:@{NSLocalizedDescriptionKey : @\"Downloaded image has 0 pixels\"}]];\\n                        } else {\\n                            // 不存在图片直接回调结束\\n                            [self callCompletionBlocksWithImage:image imageData:imageData error:nil finished:YES];\\n                        }\\n                        [self done];\\n                    });\\n                }\\n            } else {\\n                [self callCompletionBlocksWithError:[NSError errorWithDomain:SDWebImageErrorDomain code:0 userInfo:@{NSLocalizedDescriptionKey : @\"Image data is nil\"}]];\\n                [self done];\\n            }\\n        } else {\\n            // 结束后的操作\\n            [self done];\\n        }\\n    }\\n}\\n\\n')])])]),o(\"h2\",{attrs:{id:\"下载流程\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#下载流程\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 下载流程\")]),e._v(\" \"),o(\"p\",[e._v(\"具体的下载流程用文字来叙述：\")]),e._v(\" \"),o(\"ol\",[o(\"li\",[e._v(\"首先生成继承自NSOperation的SDWebImageDownloaderOperation，配置当前operation。\")]),e._v(\" \"),o(\"li\",[e._v(\"将operation添加到NSOperationQueue下载队列中，添加到下载队列会触发operation的start方法。\")]),e._v(\" \"),o(\"li\",[e._v(\"如果发现operation的isCancelled为YES，说明已经被取消，则finished=YES结束下载。\")]),e._v(\" \"),o(\"li\",[e._v(\"创建NSURLSessionTask执行resume开始下载。\")]),e._v(\" \"),o(\"li\",[e._v(\"当收到服务端的相应时根据code判断请求状态，如果是正常状态则发送正在接受response的通知以及下载进度。如果是304或者其他异常状态则cancel下载操作。\")]),e._v(\" \"),o(\"li\",[e._v(\"在didReceiveData每次收到服务器的返回response时，给可变data追加图片当前下载的data，并汇报下载的进度。\")]),e._v(\" \"),o(\"li\",[e._v(\"在didCompleteWithError下载结束时，如果下载成功进行图片data解码，图片的缩放或者压缩操作，发送下载结束通知。下载失败执行失败回调。\")])]),e._v(\" \"),o(\"h2\",{attrs:{id:\"相关技术点\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#相关技术点\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 相关技术点\")]),e._v(\" \"),o(\"h3\",{attrs:{id:\"ns-options与位运算\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#ns-options与位运算\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" NS_OPTIONS与位运算\")]),e._v(\" \"),o(\"p\",[e._v(\"NS_OPTIONS 用来定义位移相关操作的枚举值，当一个枚举变量需要携带多种值的时候就需要，我们可以参考 UIKit.Framework 的头文件，可以看到大量的枚举定义。例如在 SDWebImage 下面就会接触到 SDWebImageOptions 枚举值：\")]),e._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v(\"typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) {\\n    SDWebImageRetryFailed = 1 << 0,\\n    SDWebImageLowPriority = 1 << 1,\\n    SDWebImageCacheMemoryOnly = 1 << 2,\\n    SDWebImageProgressiveDownload = 1 << 3,\\n    SDWebImageRefreshCached = 1 << 4,\\n    SDWebImageContinueInBackground = 1 << 5,\\n    ...\\n};\\n\")])])]),o(\"p\",[e._v(\"“<<”是位运算中的左移运算符，第一个值 SDWebImageRetryFailed = 1 << 0，十进制1转化为二进制：0b00000001，这里 <<0 将所有二进制位左移0位，那么还是0b00000001，最终SDWebImageRetryFailed 值为1.\\n第二个枚举值SDWebImageLowPriority = 1<<1,这里是将1的二进制所有位向左移动1位，空缺的用0补齐，那么0b00000001变成0b00000010，十进制为2则SDWebImageLowPriority值为2。\")]),e._v(\" \"),o(\"p\",[e._v(\"下面来举个使用的例子\")]),e._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v(\" [customImageView sd_setImageWithURL:url placeholderImage:nil options:SDWebImageRetryFailed | SDWebImageCacheMemoryOnly];\\n\")])])]),o(\"p\",[e._v(\"注意到代码中用到了”|”，‘|’是位运算中的或运算，需要两个操作数，作用是将两个数的相同位进行逻辑或运算，即如果两个对应位有一个位1，则运算后此位为1，如果两个对应位都为0。例如十进制1的二进制0b00000001 | 十进制2的二进制0b00000010，结果为0b00000011十进制为3。\")]),e._v(\" \"),o(\"p\",[o(\"img\",{attrs:{src:n(344),alt:\"\"}})]),e._v(\" \"),o(\"p\",[e._v(\"具体的用法可以通过下面的代码来演示\")]),e._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v(\"if (url.absoluteString.length == 0 || (!(options & SDWebImageRetryFailed) && isFailedUrl)) {\\n    }\\n\")])])]),o(\"p\",[e._v(\"‘&’是位运算中的与运算，当对应位数同为1结果才为1.例如十进制1的二进制0b00000001&十进制2的二进制0b00000010，结果为0b00000000十进制是0.\\n\"),o(\"img\",{attrs:{src:n(345),alt:\"\"}})]),e._v(\" \"),o(\"p\",[e._v(\"上面的代码中，SD将此时的options二进制0b00000101和SDWebImageRetryFailed的二进制进行&运算，如果options包含了SDWebImageRetryFailed则结果为真。\")]),e._v(\" \"),o(\"h3\",{attrs:{id:\"如何快速判断当前程序是否有指定类\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何快速判断当前程序是否有指定类\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 如何快速判断当前程序是否有指定类\")]),e._v(\" \"),o(\"p\",[e._v(\"可以通过以下代码来进行判断\")]),e._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v('    if (NSClassFromString(@\"SDNetworkActivityIndicator\")) {\\n\\t}\\n')])])]),o(\"h3\",{attrs:{id:\"nscache\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#nscache\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" NSCache\")]),e._v(\" \"),o(\"p\",[e._v(\"NSCache 类：一个类似于集合的容器。它存储 key-value 对，这一点类似于NSDictionary类。我们通常用使用缓存来临时存储短时间使用但创建昂贵的对象。重用这些对象可以优化性能，因为它们的值不需要重新计算。另外一方面，这些对象对于程序来说不是紧要的，在内存紧张时会被丢弃。\")]),e._v(\" \"),o(\"p\",[e._v(\"NSCache与可变集合有几点不同：\")]),e._v(\" \"),o(\"ul\",[o(\"li\",[e._v(\"NSCache类结合了各种自动删除策略，以确保不会占用过多的系统内存。如果其它应用需要内存时，系统自动执行这些策略。当调用这些策略时，会从缓存中删除一些对象，以最大限度减少内存的占用。\")]),e._v(\" \"),o(\"li\",[e._v(\"NSCache是线程安全的，我们可以在不同的线程中添加、删除和查询缓存中的对象，而不需要锁定缓存区域。\")]),e._v(\" \"),o(\"li\",[e._v(\"不像NSMutableDictionary对象，一个缓存对象不会拷贝key对象。\")])]),e._v(\" \"),o(\"h3\",{attrs:{id:\"nsoperation-及-nsoperationqueue\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#nsoperation-及-nsoperationqueue\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" NSOperation 及 NSOperationQueue\")]),e._v(\" \"),o(\"p\",[e._v(\"操作队列是Objective-C中一种高级的并发处理方法，现在它是基于GCD来实现的。相对于GCD来说，操作队列的优点是可以取消在任务处理队列中的任务，另外在管理操作间的依赖关系方面也容易一些。对 SDWebImage 中我们就看到了如何使用依赖将下载顺序设置成后进先出的顺序。而且最核心的下载图片与图片解码的工作都是在其自定义的 SDWebImageDownloaderOperation 中来实现的。\")]),e._v(\" \"),o(\"h3\",{attrs:{id:\"确保在主线程的宏\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#确保在主线程的宏\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 确保在主线程的宏\")]),e._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v(\"#define dispatch_main_async_safe(block)\\\\\\n    if (strcmp(dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL), dispatch_queue_get_label(dispatch_get_main_queue())) == 0) {\\\\\\n        block();\\\\\\n    } else {\\\\\\n        dispatch_async(dispatch_get_main_queue(), block);\\\\\\n    }\\n#endif\\n\")])])]),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v(\"dispatch_main_async_safe(^{\\n \\t\\t\\t\\t //将下面这段代码放在主线程中\\n            [self sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock];\\n        });\\n\")])])]),o(\"h3\",{attrs:{id:\"锁\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#锁\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 锁\")]),e._v(\" \"),o(\"p\",[e._v(\"在代码里面用的最多的锁就是 \"),o(\"code\",[e._v(\"dispatch_semaphore_t\")]),e._v(\" 这个信号量，并定义了两个宏来方便操作。其特点就是性能相对较好。\")]),e._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v(\"#define LOCK(lock) dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);\\n#define UNLOCK(lock) dispatch_semaphore_signal(lock);\\n\")])])]),o(\"p\",[e._v(\"另外常见的锁就是下面这个互斥锁的用法\")]),e._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v(\"@synchronized (self.runningOperations) {\\n        [self.runningOperations addObject:operation];\\n    }\\n\")])])]),o(\"h3\",{attrs:{id:\"runloop\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#runloop\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" RunLoop\")]),e._v(\" \"),o(\"p\",[e._v(\"在老的版本中的 SDWebImageDownloaderOperation 的 start 函数中，调用了CFRunLoopRun()，我们来看一下CFRunLoopRun到底是做什么的，起到了什么作用。\")]),e._v(\" \"),o(\"p\",[e._v(\"每一个线程有一个runloop,既不可以创建，也不能销毁线程的runloop。Core Foundation根据需求为你创建，通过CFRunLoopGetMain可以获得当前线程的runloop。调用CFRunLoopRun可以使当前线程的runloop以默认模式运行起来，直到调用CFRunLoopStop来停止runloop。你也可以调用CFRunLoopRunInMode来使当前线程的runloop以指定模式运行起来一段时间或者直到runloop被停止。(runloop只能在请求模式至少有一个source或者timer可监控的情况下运行起来。)\")]),e._v(\" \"),o(\"p\",[e._v(\"一般主线程会自动运行runloop，我们一般情况下不会去管。在其他子线程中，如果需要我们需要去管理。使用runloop后，可以把线程想象成进入了一个循环；如果没有这个循环，子线程完成任务后，这个线程就结束了。所以如果需要一个线程处理各种事件而不让它结束，就需要运行runloop。\")]),e._v(\" \"),o(\"p\",[e._v(\"在SDWebImageDownloaderOperation中，\")]),e._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v(\"- (void)start{\\n ...\\n self.connection = [[NSURLConnection alloc] initWithRequest:self.request delegate:self startImmediately:NO];\\n ...\\n\\n if(self.connection){\\n ...\\n CFRunLoopRun()\\n ...\\n }\\n}\\n\\n\\n- (void)cancelInternalAndStop {\\n if (self.isFinished) return;\\n [self cancelInternal];\\n CFRunLoopStop(CFRunLoopGetCurrent());\\n}\\n\")])])]),o(\"p\",[e._v(\"在创建self.connection成功后，执行了CFRunLoopRun()，开启了runloop。在failed或finished的时候会调用CFRunLoopStop停止runloop。如果不开启runloop的话，在执行完start()后任务就完成了，NSURLConnection的代理就不会执行了。runloop相当于子线程的循环，可以灵活控制子线程的生命周期。\")]),e._v(\" \"),o(\"p\",[e._v(\"而在最新版本的实现中并没有对应的代码，这大概是因为新版本使用的是 nsurlsession 来发起请求。猜测其内部会对 runloop 进行处理？（望知道的同学不吝赐教 - 提isuess🙏）\")]),e._v(\" \"),o(\"h2\",{attrs:{id:\"参考\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#参考\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 参考\")]),e._v(\" \"),o(\"ol\",[o(\"li\",[o(\"a\",{attrs:{href:\"https://blog.csdn.net/luobo140716/article/details/78829104\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"搬好小板凳看SDWebImage源码解析\"),o(\"OutboundLink\")],1)]),e._v(\" \"),o(\"li\",[o(\"a\",{attrs:{href:\"https://juejin.im/post/5a4080d16fb9a0451969d0aa\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"SDWebImage 源码解析\"),o(\"OutboundLink\")],1)]),e._v(\" \"),o(\"li\",[o(\"a\",{attrs:{href:\"https://blog.csdn.net/ZCMUCZX/article/details/79491589\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"SDWebImage-存储图片到磁盘和内存过程\"),o(\"OutboundLink\")],1)]),e._v(\" \"),o(\"li\",[o(\"a\",{attrs:{href:\"https://github.com/Draveness/analyze/blob/master/contents/SDWebImage/iOS%20%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%20---%20SDWebImage.md\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"iOS 源代码分析 --- SDWebImage\"),o(\"OutboundLink\")],1)]),e._v(\" \"),o(\"li\",[o(\"a\",{attrs:{href:\"http://southpeak.github.io/2015/02/07/sourcecode-sdwebimage/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"SDWebImage实现分析\"),o(\"OutboundLink\")],1)])])])},[],!1,null,null,null);a.default=t.exports}}]);","extractedComments":[]}