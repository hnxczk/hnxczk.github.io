{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{362:function(n,e,t){n.exports=t.p+\"assets/img/05-singleton-pattern-01.3a5f8312.png\"},390:function(n,e,t){\"use strict\";t.r(e);var a=t(0),s=Object(a.a)({},function(){var n=this,e=n.$createElement,a=n._self._c||e;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":n.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"单例模式\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#单例模式\",\"aria-hidden\":\"true\"}},[n._v(\"#\")]),n._v(\" 单例模式\")]),n._v(\" \"),a(\"p\",[n._v(\"单例模式（Singleton Pattern）是最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。\")]),n._v(\" \"),a(\"h2\",{attrs:{id:\"单例模式的由来\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#单例模式的由来\",\"aria-hidden\":\"true\"}},[n._v(\"#\")]),n._v(\" 单例模式的由来\")]),n._v(\" \"),a(\"p\",[n._v(\"有一些对象其实我们只需要一个，比方说：线程池(threadpool)、缓存(cache)、对话框、处理偏好设置和注册表(registry)的对象、日志对象、充当打印机、显卡等设备的驱动程序的对象，这类对象只能有一个实例，如果制造出多个实例，就会导致许多问题产生，比如：程序的行为异常、资源使用过量，或者是不一致的结果。\")]),n._v(\" \"),a(\"h2\",{attrs:{id:\"保证只有一个实例对象\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#保证只有一个实例对象\",\"aria-hidden\":\"true\"}},[n._v(\"#\")]),n._v(\" 保证只有一个实例对象\")]),n._v(\" \"),a(\"p\",[n._v(\"注意，在 swift 中完全不用以下这些麻烦的方式来实现单例。这里只是为了配合书中的代码引出问题。\\n具体实现及原因可以看\"),a(\"a\",{attrs:{href:\"http://swifter.tips/singleton/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"这里\"),a(\"OutboundLink\")],1),n._v(\"和\"),a(\"a\",{attrs:{href:\"https://juejin.im/post/59e30701f265da432f3026ad\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"这里\"),a(\"OutboundLink\")],1)]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"class Singleton {\\n    private static var _instance: Singleton?\\n\\n    private init() {}\\n    \\n    static func share() -> Singleton {\\n        if _instance == nil {\\n            _instance = Singleton()\\n        }\\n        return _instance!\\n    }\\n    \\n    // other method\\n}\\n\")])])]),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"var singleton = Singleton.share();\\nvar singleton2 = Singleton.share();\\n\")])])]),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"Printing description of singleton:\\n<Singleton: 0x102919960>\\nPrinting description of singleton2:\\n<Singleton: 0x102919960>\\n\")])])]),a(\"p\",[n._v(\"保证只会有一个实例对象的方法就是\")]),n._v(\" \"),a(\"ol\",[a(\"li\",[n._v(\"声明构造函数为私有\")]),n._v(\" \"),a(\"li\",[n._v(\"利用一个静态变量来记录这个唯一实例\")]),n._v(\" \"),a(\"li\",[n._v(\"通过 \"),a(\"code\",[n._v(\"share()\")]),n._v(\" 方法来向外界提供实例对象（先判断静态变量是否有值，为空的话再创建）\")])]),n._v(\" \"),a(\"h2\",{attrs:{id:\"巧克力工厂\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#巧克力工厂\",\"aria-hidden\":\"true\"}},[n._v(\"#\")]),n._v(\" 巧克力工厂\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"class ChocolateBoiler {\\n    private var empty: Bool\\n    private var boiled: Bool\\n    \\n    private static var instance: ChocolateBoiler?\\n    \\n    private init() {\\n        empty = true;\\n        boiled = false;\\n    }\\n    \\n    static func share() -> ChocolateBoiler {\\n        if instance == nil {\\n            instance = ChocolateBoiler()\\n        }\\n        return instance!\\n    }\\n    \\n    func fill() {\\n        // 空的才能往里加入原料\\n        if isEmpty() {\\n            empty = false\\n            boiled = false\\n        }\\n    }\\n    \\n    func drain() {\\n        // 必须是满的而且煮过的才能排出\\n        if !isEmpty() && isBoiled() {\\n            empty = true\\n        }\\n    }\\n    \\n    func boil() {\\n        // 煮的时候必须是满的并且没煮过的\\n        if !isEmpty() && !isBoiled() {\\n            boiled = true\\n        }\\n    }\\n    \\n    func isEmpty() -> Bool {\\n        return self.empty\\n    }\\n    \\n    func isBoiled() -> Bool {\\n        return self.boiled;\\n    }\\n}\\n\")])])]),a(\"p\",[n._v(\"这是一个单例模式的巧克力工厂。\")]),n._v(\" \"),a(\"h2\",{attrs:{id:\"定义\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#定义\",\"aria-hidden\":\"true\"}},[n._v(\"#\")]),n._v(\" 定义\")]),n._v(\" \"),a(\"p\",[a(\"strong\",[n._v(\"单例模式：单件模式确保一个类只有一个实例，并提供一个全局访问点\")])]),n._v(\" \"),a(\"h2\",{attrs:{id:\"多线程中出现的问题\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#多线程中出现的问题\",\"aria-hidden\":\"true\"}},[n._v(\"#\")]),n._v(\" 多线程中出现的问题\")]),n._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:t(362),alt:\"\"}})]),n._v(\" \"),a(\"h2\",{attrs:{id:\"处理方法\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#处理方法\",\"aria-hidden\":\"true\"}},[n._v(\"#\")]),n._v(\" 处理方法\")]),n._v(\" \"),a(\"p\",[n._v(\"其他语言中需要进行加锁，比如 java 中的 synchronized 与 OC 中的 @synchronized、 dispatch_once 都是这种处理方式。\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"+ (id)sharedInstance {  \\n    static testClass *sharedInstance = nil;  \\n    @synchronized(self) {  \\n        if (!sharedInstance) {  \\n            sharedInstance = [[self alloc] init];  \\n        }  \\n    }  \\n    return sharedInstance;  \\n} \\n\")])])]),a(\"p\",[n._v(\"为减少频繁加锁的性能损耗可以使用下面的这种方式\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"+ (id)sharedInstance {  \\n    static testClass *sharedInstance = nil;  \\n    if (!sharedInstance) {\\n        @synchronized(self) {  \\n            if (!sharedInstance) {  \\n                sharedInstance = [[self alloc] init];  \\n            }  \\n        } \\n    }\\n    return sharedInstance;  \\n} \\n\")])])]),a(\"p\",[n._v(\"更好的方式当然还是 dispatch_once\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"+ (id)sharedInstance {  \\n    static testClass *sharedInstance = nil;  \\n    static dispatch_once_t once;  \\n    dispatch_once(&once, ^{  \\n        sharedInstance = [[self alloc] init];  \\n    });  \\n    return sharedInstance;  \\n}  \\n\")])])]),a(\"p\",[n._v(\"dispatch_once 为什么能做到既解决同步多线程问题又不影响性能呢？\\n下面我们来看看 dispatch_once 的原理：\")]),n._v(\" \"),a(\"ol\",[a(\"li\",[n._v(\"dispatch_once 主要是根据 onceToken 的值来决定怎么去执行代码。\")]),n._v(\" \"),a(\"li\",[n._v(\"当 onceToken = 0时，线程执行 dispatch_once 的 block 中代码\")]),n._v(\" \"),a(\"li\",[n._v(\"当 onceToken = -1时，线程跳过 dispatch_once 的 block 中代码不执行\")]),n._v(\" \"),a(\"li\",[n._v(\"当 onceToken 为其他值时，线程被线程被阻塞，等待 onceToken 值改变\")]),n._v(\" \"),a(\"li\",[n._v(\"当线程首先调用 shareInstance，某一线程要执行 block 中的代码时，首先需要改变 onceToken 的值，再去执行 block 中的代码。这里 onceToken 的值变为了 140734605830464。\")]),n._v(\" \"),a(\"li\",[n._v(\"这样当其他线程再获取 onceToken 的值时，值已经变为 140734605830464。其他线程被阻塞。\")]),n._v(\" \"),a(\"li\",[n._v(\"当block线程执行完 block 之后。onceToken 变为 -1。其他线程不再阻塞，跳过 block。\")]),n._v(\" \"),a(\"li\",[n._v(\"下次再调用 shareInstance 时，block 已经为 -1。直接跳过 block。\")]),n._v(\" \"),a(\"li\",[n._v(\"这样 dispatch_once 在首次调用时同步阻塞线程，生成单例之后，不再阻塞线程。\")])]),n._v(\" \"),a(\"p\",[a(\"a\",{attrs:{href:\"https://www.jianshu.com/p/160d77888443\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"出处见这里\"),a(\"OutboundLink\")],1)]),n._v(\" \"),a(\"p\",[n._v(\"而由于 swift 中已经使用 dispatch_once behind the scenes 来执行全局变量和静态属性的线程安全延迟初始化。因此使用静态常量就可以保证线程安全。\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"    private static let instance = ChocolateBoiler2()\\n    \\n    private init() {\\n        empty = true;\\n        boiled = false;\\n    }\\n    \\n    static func share() -> ChocolateBoiler2 {\\n        return instance\\n    }\\n\")])])])])},[],!1,null,null,null);e.default=s.exports}}]);","extractedComments":[]}