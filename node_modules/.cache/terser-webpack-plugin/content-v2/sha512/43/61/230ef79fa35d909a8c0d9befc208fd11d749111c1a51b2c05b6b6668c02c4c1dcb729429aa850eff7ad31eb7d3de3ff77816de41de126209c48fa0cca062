{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{280:function(t,a,s){t.exports=s.p+\"assets/img/context.d248211d.jpeg\"},281:function(t,a,s){t.exports=s.p+\"assets/img/context-stack.aadcf08b.jpeg\"},282:function(t,a,s){t.exports=s.p+\"assets/img/context-stack-1.2f761eb8.gif\"},427:function(t,a,s){\"use strict\";s.r(a);var n=s(0),e=Object(n.a)({},function(){var t=this,a=t.$createElement,n=t._self._c||a;return n(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[n(\"h1\",{attrs:{id:\"执行上下文和执行栈\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#执行上下文和执行栈\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 执行上下文和执行栈\")]),t._v(\" \"),n(\"p\",[t._v(\"开始之前，我们先看以下代码。\")]),t._v(\" \"),n(\"div\",{staticClass:\"language-javascript extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-javascript\"}},[n(\"code\",[t._v(\"console\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"log\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"a\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// Uncaught ReferenceError: a is not defined\")]),t._v(\"\\n\")])])]),n(\"div\",{staticClass:\"language-javascript extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-javascript\"}},[n(\"code\",[t._v(\"console\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"log\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"a\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// undefined\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"var\")]),t._v(\" a \"),n(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"10\")]),t._v(\"\\n\")])])]),n(\"p\",[t._v(\"第一段代码报错很好理解，a 没有声明。所以抛出错误。\")]),t._v(\" \"),n(\"p\",[t._v(\"第二段代码中 a 的声明在使用 a 之后，打印 a 的值是 undefined。这就是变量提升的概念。\")]),t._v(\" \"),n(\"p\",[t._v(\"这里需要注意的是 undefined 是一个值，也就是说在使用 a 的时候，a 已经存在并且有一个值 undefined。这就很奇怪了，明明 a 还没有声明为什么就已经存在了呢？\")]),t._v(\" \"),n(\"p\",[t._v(\"其实是因为当 JavaScript 代码真正执行之前就已经做了一些准备工作，包括上面所说的变量的声明。而这些工作跟执行上下文有着紧密的联系，我们需要先来了解什么是执行上下文。\")]),t._v(\" \"),n(\"h2\",{attrs:{id:\"执行上下文\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#执行上下文\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 执行上下文\")]),t._v(\" \"),n(\"p\",[t._v(\"简单来说执行上下文（Execution Context）就是执行 JavaScript 代码的环境。所有的代码都在执行上下文中执行。\")]),t._v(\" \"),n(\"p\",[t._v(\"上面的例子都是在全局上下文中执行的，其实执行上下文可以分为下面这三种\")]),t._v(\" \"),n(\"ol\",[n(\"li\",[t._v(\"全局执行上下文 (Global Execution Context)\")])]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"这是最基础或者默认的执行上下文，是代码一开始运行就会创建的上下文。\")]),t._v(\" \"),n(\"li\",[t._v(\"一个程序中只会有一个全局执行上下文\")]),t._v(\" \"),n(\"li\",[t._v(\"所有不在函数内部的代码都在全局执行上下文之中\")])]),t._v(\" \"),n(\"ol\",{attrs:{start:\"2\"}},[n(\"li\",[t._v(\"函数执行上下文 (Functional Execution Context)\")])]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"当一个函数被调用时, 会为该函数创建一个上下文\")]),t._v(\" \"),n(\"li\",[t._v(\"每个函数都有自己的执行上下文\")])]),t._v(\" \"),n(\"ol\",{attrs:{start:\"3\"}},[n(\"li\",[t._v(\"Eval 函数执行上下文 (Eval Function Execution Context)\")])]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"执行在 eval 函数内部的代码也会有它属于自己的执行上下文\")])]),t._v(\" \"),n(\"p\",[t._v(\"下面我们通过一个例子来加深印象。\")]),t._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:s(280),alt:\"\"}})]),t._v(\" \"),n(\"p\",[t._v(\"图片中紫色区域标记的是全局执行上下文，绿色、蓝色以及黄色区域标记的是三个函数执行上下文（Eval 函数执行上下文不是很常用，在这里不做介绍）。\")]),t._v(\" \"),n(\"p\",[t._v(\"可以看到在全局执行上下文中定义的有变量，这些被称为全局变量。它可以被所有的上下文访问。\")]),t._v(\" \"),n(\"p\",[t._v(\"每个函数都会创建一个新的函数上下文，在新的函数上下文中，会创建一个私有作用域，在这个函数中创建的任何声明都不能被当前函数作用域之外的地方访问。在上面例子中，一个函数可以访问当前上下文外部定义的变量，但是在外部却无法访问函数内部声明的变量。\")]),t._v(\" \"),n(\"p\",[t._v(\"为什么会是这样呢？代码到底是怎么运行的呢？要解答这些问题就需要先了解 执行栈 的概念。\")]),t._v(\" \"),n(\"h2\",{attrs:{id:\"执行栈\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#执行栈\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 执行栈\")]),t._v(\" \"),n(\"p\",[t._v(\"执行栈，其他语言中被称为调用栈，与存储变量的那个栈的概念不同，它是被用来存储代码运行时创建的所有执行上下文的栈。\")]),t._v(\" \"),n(\"p\",[t._v(\"当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。\")]),t._v(\" \"),n(\"p\",[t._v(\"我们都知道，Javascript 是一门单线程的非阻塞的脚本语言。这就意味着浏览器同一个时间只能处理一个任务。因此引擎只会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。\")]),t._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:s(281),alt:\"\"}})]),t._v(\" \"),n(\"p\",[t._v(\"一个例子\")]),t._v(\" \"),n(\"div\",{staticClass:\"language-javascript extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-javascript\"}},[n(\"code\",[n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"function\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"foo\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token parameter\"}},[t._v(\"i\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    \"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"if\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"i \"),n(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"===\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"3\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n        \"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"return\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n    \"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n    \"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"else\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n        \"),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"foo\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"++\")]),t._v(\"i\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n    \"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"0\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\")])])]),n(\"p\",[t._v(\"执行过程如下\")]),t._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:s(282),alt:\"\"}})]),t._v(\" \"),n(\"p\",[t._v(\"上面的代码是一个递归调用的函数，每次调用的时候就会创建新的函数上下文，而当函数执行完后该上下文就会出栈，将控制权交给下一个执行环境。\")]),t._v(\" \"),n(\"h2\",{attrs:{id:\"参考\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#参考\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 参考\")]),t._v(\" \"),n(\"ol\",[n(\"li\",[n(\"a\",{attrs:{href:\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"Tasks, microtasks, queues and schedules\"),n(\"OutboundLink\")],1)]),t._v(\" \"),n(\"li\",[n(\"a\",{attrs:{href:\"http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"What is the Execution Context & Stack in JavaScript?\"),n(\"OutboundLink\")],1)])])])},[],!1,null,null,null);a.default=e.exports}}]);","extractedComments":[]}