{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{493:function(a,t,r){\"use strict\";r.r(t);var _=r(0),v=Object(_.a)({},function(){var a=this,t=a.$createElement,r=a._self._c||t;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":a.$parent.slotKey}},[r(\"h1\",{attrs:{id:\"图的表示\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#图的表示\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 图的表示\")]),a._v(\" \"),r(\"h2\",{attrs:{id:\"图的定义\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#图的定义\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 图的定义\")]),a._v(\" \"),r(\"ul\",[r(\"li\",[a._v(\"顶点：图中的每个元素\")]),a._v(\" \"),r(\"li\",[a._v(\"边：图中顶点之间的连接关系\")]),a._v(\" \"),r(\"li\",[a._v(\"度：某个顶点相连接的边的条数\")]),a._v(\" \"),r(\"li\",[a._v(\"方向：两个顶点的指向\")]),a._v(\" \"),r(\"li\",[a._v(\"有向图和无向图：顶点之间有方向的就是有向图，否则就是无向图\")]),a._v(\" \"),r(\"li\",[a._v(\"入度：（有向图才有）指向某个顶点的边的个数\")]),a._v(\" \"),r(\"li\",[a._v(\"出度：（有向图才有）以某个顶点为起点的边的个数\")]),a._v(\" \"),r(\"li\",[a._v(\"带权图：每条边都有权重的图就是带权图\")])]),a._v(\" \"),r(\"h2\",{attrs:{id:\"图的存储\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#图的存储\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 图的存储\")]),a._v(\" \"),r(\"h3\",{attrs:{id:\"邻接矩阵存储\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#邻接矩阵存储\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 邻接矩阵存储\")]),a._v(\" \"),r(\"p\",[a._v(\"邻接矩阵的底层是一个二维数组。\")]),a._v(\" \"),r(\"ol\",[r(\"li\",[a._v(\"无向图：如果图中顶点 i 和 j 之间有边，则在 A[i][j] 和 A[j][i] 标记为 1\")]),a._v(\" \"),r(\"li\",[a._v(\"有向图：若顶点 i 有 指向 顶点 j 的边，则在 A[i][j] 标记为 1\")]),a._v(\" \"),r(\"li\",[a._v(\"带权无向图和带权有向图：与上面情况类似，不过标记的是边的权重\")])]),a._v(\" \"),r(\"h4\",{attrs:{id:\"优点\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#优点\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 优点\")]),a._v(\" \"),r(\"ol\",[r(\"li\",[a._v(\"存储方式简单，读取高效\")]),a._v(\" \"),r(\"li\",[a._v(\"方便计算，可以将计算转换成矩阵的运算\")])]),a._v(\" \"),r(\"h4\",{attrs:{id:\"缺点\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#缺点\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 缺点\")]),a._v(\" \"),r(\"ol\",[r(\"li\",[a._v(\"耗费空间\")])]),a._v(\" \"),r(\"h3\",{attrs:{id:\"邻接表存储\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#邻接表存储\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 邻接表存储\")]),a._v(\" \"),r(\"p\",[a._v(\"邻接表与散列表类似\")]),a._v(\" \"),r(\"ol\",[r(\"li\",[a._v(\"将所有顶点依次存储于数组中，每个顶点都有一个链表与之对应。\")]),a._v(\" \"),r(\"li\",[a._v(\"链表中存储的是与这个顶点连接的其他顶点。\\n\"),r(\"ol\",[r(\"li\",[a._v(\"有向图：链表中存储的是以该顶点为起点指向的顶点\")]),a._v(\" \"),r(\"li\",[a._v(\"无向图；链表中存储的是与该顶点连接的顶点\")])])])]),a._v(\" \"),r(\"h4\",{attrs:{id:\"优点-2\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#优点-2\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 优点\")]),a._v(\" \"),r(\"ol\",[r(\"li\",[a._v(\"节省空间\")])]),a._v(\" \"),r(\"h4\",{attrs:{id:\"缺点-2\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#缺点-2\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 缺点\")]),a._v(\" \"),r(\"ol\",[r(\"li\",[a._v(\"由于是靠链表存储顶点之间的关系，对缓存不友好\")]),a._v(\" \"),r(\"li\",[a._v(\"查询两个顶点之间的关系效率较低\")])]),a._v(\" \"),r(\"h4\",{attrs:{id:\"改进\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#改进\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 改进\")]),a._v(\" \"),r(\"p\",[a._v(\"可以通过将链表替换成平衡二叉树、红黑树，以及跳表等动态数据结构提高性能\")]),a._v(\" \"),r(\"h2\",{attrs:{id:\"qa-如何存储社交平台好友关系\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#qa-如何存储社交平台好友关系\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" QA 如何存储社交平台好友关系\")]),a._v(\" \"),r(\"h3\",{attrs:{id:\"微博用户关系支持的操作\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#微博用户关系支持的操作\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 微博用户关系支持的操作\")]),a._v(\" \"),r(\"ul\",[r(\"li\",[a._v(\"判断用户 A 是否关注了用户 B\")]),a._v(\" \"),r(\"li\",[a._v(\"判断 A 是否是 B 的粉丝\")]),a._v(\" \"),r(\"li\",[a._v(\"A 关注 B\")]),a._v(\" \"),r(\"li\",[a._v(\"A 取消关注 B\")]),a._v(\" \"),r(\"li\",[a._v(\"根据用户名的首字母排序，分页获取用户的粉丝列表\")]),a._v(\" \"),r(\"li\",[a._v(\"根据用户名的首字母排序，分页获取用户的关注列表\")])]),a._v(\" \"),r(\"h3\",{attrs:{id:\"实现思路\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#实现思路\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 实现思路\")]),a._v(\" \"),r(\"ol\",[r(\"li\",[a._v(\"通过上面可以看出来用户关系是一个有向图\")]),a._v(\" \"),r(\"li\",[a._v(\"使用邻接表存储用户的关注关系，记录的是该顶点指向的顶点。可以查出用户关注列表\")]),a._v(\" \"),r(\"li\",[a._v(\"使用逆邻接表存储用户的被关注关系，记录的是指向该顶点的顶点。可以查出用户的被关注列表\")])]),a._v(\" \"),r(\"h3\",{attrs:{id:\"改进-2\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#改进-2\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 改进\")]),a._v(\" \"),r(\"h4\",{attrs:{id:\"_1-使用跳表替代基础的邻接表\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-使用跳表替代基础的邻接表\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 1. 使用跳表替代基础的邻接表\")]),a._v(\" \"),r(\"ul\",[r(\"li\",[a._v(\"基础邻接表在查找用户之间关注关系的时候较为低效\")]),a._v(\" \"),r(\"li\",[a._v(\"跳表插入删除查找等操作都非常高效\")]),a._v(\" \"),r(\"li\",[a._v(\"又由于跳表本身存储的就是有序数据，因此在分页获取关注粉丝数据的时候就十分高效\")])]),a._v(\" \"),r(\"h4\",{attrs:{id:\"_2-对于较大规模的数据通过使用哈希算法将数据分片\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-对于较大规模的数据通过使用哈希算法将数据分片\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 2. 对于较大规模的数据通过使用哈希算法将数据分片\")]),a._v(\" \"),r(\"h1\",{attrs:{id:\"深度和广度优先搜索\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#深度和广度优先搜索\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 深度和广度优先搜索\")])])},[],!1,null,null,null);t.default=v.exports}}]);","extractedComments":[]}