{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{401:function(e,t,s){e.exports=s.p+\"assets/img/23.767219b6.png\"},402:function(e,t,s){e.exports=s.p+\"assets/img/24.94a4e85f.png\"},403:function(e,t,s){e.exports=s.p+\"assets/img/25.9451e244.png\"},411:function(e,t,s){\"use strict\";s.r(t);var a=s(0),_=Object(a.a)({},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"类和对象的基本数据结构\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#类和对象的基本数据结构\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 类和对象的基本数据结构\")]),e._v(\" \"),a(\"p\",[e._v(\"由于 OC 中 \"),a(\"code\",[e._v(\"NSObject\")]),e._v(\" 是基类，我们可以从它的实现来看一下类和对象的数据结构是怎么实现的。\")]),e._v(\" \"),a(\"p\",[e._v(\"我们可以在源码中找到 \"),a(\"code\",[e._v(\"NSObject.h\")]),e._v(\" 和 \"),a(\"code\",[e._v(\"NSObject.mm\")]),e._v(\" 这两个文件。\"),a(\"code\",[e._v(\"NSObject\")]),e._v(\" 的定义如下。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// NSObject.h line 53\\n@interface NSObject <NSObject> {\\n    Class isa  OBJC_ISA_AVAILABILITY;\\n}\\n\")])])]),a(\"p\",[e._v(\"我们可以看出它只有一个 \"),a(\"code\",[e._v(\"Class\")]),e._v(\" 成员变量 \"),a(\"code\",[e._v(\"isa\")]),e._v(\"。\")]),e._v(\" \"),a(\"p\",[e._v(\"通过查看 \"),a(\"code\",[e._v(\"Class\")]),e._v(\" 定义如下\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// Object.mm line 33\\ntypedef struct objc_class *Class;\\ntypedef struct objc_object *id;\\n\")])])]),a(\"p\",[e._v(\"在这里我们看到了 \"),a(\"code\",[e._v(\"Class\")]),e._v(\" 就是一个指向 \"),a(\"code\",[e._v(\"objc_class\")]),e._v(\" 类型结构体的指针，同时我们经常用可以修饰任意 OC 对象的 \"),a(\"code\",[e._v(\"id\")]),e._v(\" 是一个指向 \"),a(\"code\",[e._v(\"objc_object\")]),e._v(\" 类型结构体的指针。\")]),e._v(\" \"),a(\"p\",[e._v(\"因此 \"),a(\"code\",[e._v(\"objc_class\")]),e._v(\" 和 \"),a(\"code\",[e._v(\"objc_object\")]),e._v(\" 就是类和对象对应的数据结构。\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"objc-class-和-objc-object\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#objc-class-和-objc-object\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" \"),a(\"code\",[e._v(\"objc_class\")]),e._v(\" 和 \"),a(\"code\",[e._v(\"objc_object\")])]),e._v(\" \"),a(\"p\",[e._v(\"我们在网上看到最多的就是 \"),a(\"code\",[e._v(\"runtime.h\")]),e._v(\" 中的定义。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// runtime.h line 41\\n#if !OBJC_TYPES_DEFINED\\n// line 55\\nstruct objc_class {\\n    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;\\n\\n#if !__OBJC2__\\n    Class _Nullable super_class                              OBJC2_UNAVAILABLE;\\n    const char * _Nonnull name                               OBJC2_UNAVAILABLE;\\n    long version                                             OBJC2_UNAVAILABLE;\\n    long info                                                OBJC2_UNAVAILABLE;\\n    long instance_size                                       OBJC2_UNAVAILABLE;\\n    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;\\n    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;\\n    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;\\n    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;\\n#endif\\n\\n} OBJC2_UNAVAILABLE;\\n/* Use `Class` instead of `struct objc_class *` */\\n\\n#endif\\n\")])])]),a(\"p\",[e._v(\"但是仔细看代码就会发现 \"),a(\"code\",[e._v(\"OBJC_TYPES_DEFINED\")]),e._v(\" 这个宏，它定义在 \"),a(\"code\",[e._v(\"objc-private.h\")]),e._v(\" 文件中\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// objc-private.h line 41\\n#define OBJC_TYPES_DEFINED 1\\n\")])])]),a(\"p\",[e._v(\"因此这个定义是早已过期的。我们接着找。\")]),e._v(\" \"),a(\"p\",[e._v(\"会发现项目中存在 \"),a(\"code\",[e._v(\"objc-runtime-new.h\")]),e._v(\" \"),a(\"code\",[e._v(\"objc-runtime-new.mm\")]),e._v(\" 和 \"),a(\"code\",[e._v(\"objc-runtime-old.h\")]),e._v(\" \"),a(\"code\",[e._v(\"objc-runtime-old.mm\")]),e._v(\" 这些文件。结合上一节的 \"),a(\"code\",[e._v(\"runtime\")]),e._v(\" 的介绍和代码注释我们可以看出来这些就是 Objective-C 以及 Objective-C 2.0 两种实现。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// objc-runtime-old.h line 183\\nstruct objc_class : objc_object {\\n    Class superclass;\\n    const char *name;\\n    uint32_t version;\\n    uint32_t info;\\n    uint32_t instance_size;\\n    struct old_ivar_list *ivars;\\n    struct old_method_list **methodLists;\\n    Cache cache;\\n    struct old_protocol_list *protocols;\\n    // CLS_EXT only\\n    const uint8_t *ivar_layout;\\n    struct old_class_ext *ext;\\n    ...\\n    // 下面都是一些函数\\n}\\n\")])])]),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// objc-runtime-new.h line 1111\\nstruct objc_class : objc_object {\\n    // Class ISA;\\n    Class superclass;\\n    cache_t cache;             // formerly cache pointer and vtable\\n    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags\\n\\n    class_rw_t *data() { \\n        return bits.data();\\n    }\\n    ...\\n}\\n\")])])]),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// objc-private.h line 75\\nstruct objc_object {\\n    isa_t isa;\\n    ...\\n}\\n\")])])]),a(\"p\",[e._v(\"老版本的实现就没必要在仔细看了，但是有一点需要注意的就是 \"),a(\"code\",[e._v(\"ivars\")]),e._v(\"（属性列表）、\"),a(\"code\",[e._v(\"methodLists\")]),e._v(\"（方法列表）。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"struct old_ivar_list *ivars;\\nstruct old_method_list **methodLists;\\n\")])])]),a(\"p\",[a(\"code\",[e._v(\"ivars\")]),e._v(\" 是指向 \"),a(\"code\",[e._v(\"old_ivar_list\")]),e._v(\" 的指针。\\n\"),a(\"code\",[e._v(\"methodLists\")]),e._v(\" 是指向 \"),a(\"code\",[e._v(\"old_method_list\")]),e._v(\" 的指针。\\n\"),a(\"code\",[e._v(\"*methodLists\")]),e._v(\" 是指向指向方法列表的指针。\\n因此可以通过修改 \"),a(\"code\",[e._v(\"*methodLists\")]),e._v(\" 的值来改变方法列表。\")]),e._v(\" \"),a(\"p\",[e._v(\"我们可以看出 \"),a(\"code\",[e._v(\"objc_class\")]),e._v(\" 都继承自 \"),a(\"code\",[e._v(\"objc_object\")]),e._v(\" 。这也说明了在 \"),a(\"strong\",[e._v(\"OC 中类也是对象\")]),e._v(\"。而且所有的对象（继承自 \"),a(\"code\",[e._v(\"NSObject\")]),e._v(\"）都包含了一个类型为 \"),a(\"code\",[e._v(\"isa_t\")]),e._v(\" 的 结构体。\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"isa-和-meta-class\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#isa-和-meta-class\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" \"),a(\"code\",[e._v(\"isa\")]),e._v(\" 和 \"),a(\"code\",[e._v(\"Meta Class\")])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"isa-的实现\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#isa-的实现\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" \"),a(\"code\",[e._v(\"isa\")]),e._v(\" 的实现\")]),e._v(\" \"),a(\"p\",[e._v(\"在老版本中 \"),a(\"code\",[e._v(\"isa\")]),e._v(\" 是一个当前对象指向当前对象对应的类的指针。\"),a(\"code\",[e._v(\"isa_t\")]),e._v(\" 也实现了这个功能，而且添加了一些其他的信息。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// objc-private.h line 61\\nunion isa_t {\\n    isa_t() { }\\n    isa_t(uintptr_t value) : bits(value) { }\\n\\n    Class cls;\\n    uintptr_t bits;\\n#if defined(ISA_BITFIELD)\\n    struct {\\n        ISA_BITFIELD;  // defined in isa.h\\n    };\\n#endif\\n};\\n\\n// isa.h line 78\\n#   define ISA_BITFIELD                                                        \\\\\\n      uintptr_t nonpointer        : 1;                                         \\\\\\n      uintptr_t has_assoc         : 1;                                         \\\\\\n      uintptr_t has_cxx_dtor      : 1;                                         \\\\\\n      uintptr_t shiftcls          : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\\\\\n      uintptr_t magic             : 6;                                         \\\\\\n      uintptr_t weakly_referenced : 1;                                         \\\\\\n      uintptr_t deallocating      : 1;                                         \\\\\\n      uintptr_t has_sidetable_rc  : 1;                                         \\\\\\n      uintptr_t extra_rc          : 8\\n\")])])]),a(\"p\",[e._v(\"通过代码你会发现这是一个相当复杂的结构体，具体为什么这样设计可以参考下面这段文字。\")]),e._v(\" \"),a(\"blockquote\",[a(\"p\",[e._v(\"使用整个指针大小的内存来存储 isa 指针有些浪费，尤其在 64 位的 CPU 上。在 ARM64 运行的 iOS 只使用了 33 位作为指针(与结构体中的 33 位无关，Mac OS 上为 47 位)，而剩下的 31 位用于其它目的。类的指针也同样根据字节对齐了，每一个类指针的地址都能够被 8 整除，也就是使最后 3 bits 为 0，为 isa 留下 34 位用于性能的优化。\")])]),e._v(\" \"),a(\"p\",[e._v(\"更多的内容可以看 draveness 大神的 \"),a(\"a\",{attrs:{href:\"https://github.com/draveness/analyze/blob/master/contents/objc/%E4%BB%8E%20NSObject%20%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%86%E8%A7%A3%20isa.md\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"文章\"),a(\"OutboundLink\")],1),e._v(\"。\")]),e._v(\" \"),a(\"p\",[e._v(\"我们在这里就把 \"),a(\"code\",[e._v(\"isa\")]),e._v(\" 简单的当做指针来进行分析。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"meta-class\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#meta-class\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" \"),a(\"code\",[e._v(\"Meta Class\")])]),e._v(\" \"),a(\"p\",[e._v(\"我们通过上面的 \"),a(\"code\",[e._v(\"objc_object\")]),e._v(\" 的实现代码看出来，OC 中对象并没有存储方法。（这其实很好理解，如果每个对象都存储着自己能执行的方法，那么同一个类的多个对象的方法就会重复存在，这样无疑会造成冗余的空间占用）。\")]),e._v(\" \"),a(\"p\",[e._v(\"当一个对象的实例方法调用的时候，会通过 \"),a(\"code\",[e._v(\"isa\")]),e._v(\" 查找它对应的类，然后在该类的 \"),a(\"code\",[e._v(\"class_data_bits_t\")]),e._v(\" 中查找方法（具体查找过程后面会有）。当该类中无法找到方法的时候会通过 \"),a(\"code\",[e._v(\"super_class\")]),e._v(\" 这个指针去父类中查找。\")]),e._v(\" \"),a(\"p\",[e._v(\"对于类来说我们通过上面的源码知道了它也是一种对象，可以称之为类对象。那类对象的方法就要去它对应的类中查找，这个类就称之为元类（\"),a(\"code\",[e._v(\"Meta Class\")]),e._v(\"）。\")]),e._v(\" \"),a(\"p\",[e._v(\"下面这个图片中大家可以很清晰的看到 \"),a(\"em\",[e._v(\"对象\")]),e._v(\"、\"),a(\"em\",[e._v(\"类\")]),e._v(\"、\"),a(\"em\",[e._v(\"元类\")]),e._v(\" 之间的关系。\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:s(401),alt:\"\"}})]),e._v(\" \"),a(\"p\",[e._v(\"上图中的关系已经很清晰了，有几个需要注意的点。\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[e._v(\"所有 \"),a(\"code\",[e._v(\"meta class\")]),e._v(\" 的 \"),a(\"code\",[e._v(\"isa\")]),e._v(\" 指向 \"),a(\"code\",[e._v(\"Root class\")]),e._v(\"(也就是\"),a(\"code\",[e._v(\"NSObject\")]),e._v(\") 的 \"),a(\"code\",[e._v(\"meta class\")]),e._v(\"。包括 \"),a(\"code\",[e._v(\"NSObject\")]),e._v(\" 的 \"),a(\"code\",[e._v(\"meta class\")]),e._v(\"。\")]),e._v(\" \"),a(\"li\",[a(\"code\",[e._v(\"NSObject\")]),e._v(\" 的 \"),a(\"code\",[e._v(\"meta class\")]),e._v(\" 的 \"),a(\"code\",[e._v(\"super_class\")]),e._v(\" 是 \"),a(\"code\",[e._v(\"NSObject\")]),e._v(\" 的类。\")])]),e._v(\" \"),a(\"p\",[e._v(\"更多信息可以查看 \"),a(\"a\",{attrs:{href:\"http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\" What is a meta-class in Objective-C?\"),a(\"OutboundLink\")],1)]),e._v(\" \"),a(\"p\",[e._v(\"这里岔开一个话题，就是 \"),a(\"code\",[e._v(\"isa\")]),e._v(\" 怎么读。个人认为应读作 \"),a(\"code\",[e._v(\"is a\")]),e._v(\"，而不是 \"),a(\"code\",[e._v(\"isa\")]),e._v(\" 连起来读。这样的话上图中就可以这样理解：\"),a(\"code\",[e._v(\"NSObject\")]),e._v(\" 对象 \"),a(\"code\",[e._v(\"is a\")]),e._v(\" \"),a(\"code\",[e._v(\"NSObject Class\")]),e._v(\" 对象, \"),a(\"code\",[e._v(\"NSObject Class\")]),e._v(\" \"),a(\"code\",[e._v(\"is a\")]),e._v(\" \"),a(\"code\",[e._v(\"NSObject Meta Class\")]),e._v(\" 对象。\")]),e._v(\" \"),a(\"p\",[e._v(\"这里可以通过网上一个很有名的面试题来加深一下印象。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v('@interface Sark : NSObject\\n@end\\n@implementation Sark\\n@end\\nint main(int argc, const char * argv[]) {\\n     @autoreleasepool {\\n          BOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];\\n          BOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];\\n          BOOL res3 = [(id)[Sark class] isKindOfClass:[Sark class]];\\n          BOOL res4 = [(id)[Sark class] isMemberOfClass:[Sark class]];\\n          NSLog(@\"%d %d %d %d\", res1, res2, res3, res4);\\n     }\\n     return 0;\\n}\\n')])])]),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"2019-03-01 09:57:16.064211+0800 test[1647:105298] 1 0 0 0\\n\")])])]),a(\"p\",[e._v(\"我们可以先看一下 \"),a(\"code\",[e._v(\"isKindOfClass\")]),e._v(\" 和 \"),a(\"code\",[e._v(\"isMemberOfClass\")]),e._v(\" 的实现。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// NSObject.mm line 2000\\n+ (BOOL)isMemberOfClass:(Class)cls {\\n    return object_getClass((id)self) == cls;\\n}\\n\\n- (BOOL)isMemberOfClass:(Class)cls {\\n    return [self class] == cls;\\n}\\n\\n+ (BOOL)isKindOfClass:(Class)cls {\\n    for (Class tcls = object_getClass((id)self); tcls; tcls = tcls->superclass) {\\n        if (tcls == cls) return YES;\\n    }\\n    return NO;\\n}\\n\\n- (BOOL)isKindOfClass:(Class)cls {\\n    for (Class tcls = [self class]; tcls; tcls = tcls->superclass) {\\n        if (tcls == cls) return YES;\\n    }\\n    return NO;\\n}\\n\")])])]),a(\"p\",[e._v(\"我们逐个分析一下\")]),e._v(\" \"),a(\"h4\",{attrs:{id:\"res1\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#res1\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" res1\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[a(\"code\",[e._v(\"[NSObject class]\")]),e._v(\" 是一个类，因此会来到 \"),a(\"code\",[e._v(\"+ (BOOL)isKindOfClass:(Class)cls\")]),e._v(\" 方法。此时 \"),a(\"code\",[e._v(\"self\")]),e._v(\" -> \"),a(\"code\",[e._v(\"NSObject class\")]),e._v(\"，\"),a(\"code\",[e._v(\"cls\")]),e._v(\" -> \"),a(\"code\",[e._v(\"NSObject class\")]),e._v(\"。\")]),e._v(\" \"),a(\"li\",[e._v(\"进入循环，\"),a(\"code\",[e._v(\"tcls\")]),e._v(\" -> \"),a(\"code\",[e._v(\"NSObject meta class\")]),e._v(\"。\")]),e._v(\" \"),a(\"li\",[a(\"code\",[e._v(\"tcls != cls\")]),e._v(\"，继续进入下一个循环，此时 \"),a(\"code\",[e._v(\"tcls\")]),e._v(\" -> \"),a(\"code\",[e._v(\"NSObject class\")]),e._v(\"。\")]),e._v(\" \"),a(\"li\",[a(\"code\",[e._v(\"tcls == cls\")]),e._v(\"，返回 \"),a(\"code\",[e._v(\"YES\")]),e._v(\"。\")])]),e._v(\" \"),a(\"h4\",{attrs:{id:\"res2\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#res2\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" res2\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[a(\"code\",[e._v(\"[NSObject class]\")]),e._v(\" 是一个类，因此会来到 \"),a(\"code\",[e._v(\"+ (BOOL)isMemberOfClass:(Class)cls\")]),e._v(\" 方法。此时 \"),a(\"code\",[e._v(\"self\")]),e._v(\" -> \"),a(\"code\",[e._v(\"NSObject class\")]),e._v(\"，\"),a(\"code\",[e._v(\"cls\")]),e._v(\" -> \"),a(\"code\",[e._v(\"NSObject class\")]),e._v(\"。\")]),e._v(\" \"),a(\"li\",[a(\"code\",[e._v(\"object_getClass((id)self)\")]),e._v(\" 就是获取 \"),a(\"code\",[e._v(\"self\")]),e._v(\" 的 \"),a(\"code\",[e._v(\"isa\")]),e._v(\" 指针，因此这个获取的就是 \"),a(\"code\",[e._v(\"NSObject meta class\")]),e._v(\"。\")]),e._v(\" \"),a(\"li\",[e._v(\"显然它与 \"),a(\"code\",[e._v(\"cls\")]),e._v(\" -> \"),a(\"code\",[e._v(\"NSObject class\")]),e._v(\" 不相等，返回 \"),a(\"code\",[e._v(\"NO\")]),e._v(\"。\")])]),e._v(\" \"),a(\"h4\",{attrs:{id:\"res3\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#res3\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" res3\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[e._v(\"与 \"),a(\"code\",[e._v(\"res1\")]),e._v(\" 相同的，会来到\"),a(\"code\",[e._v(\"+ (BOOL)isKindOfClass:(Class)cls\")]),e._v(\" 方法。此时 \"),a(\"code\",[e._v(\"self\")]),e._v(\" -> \"),a(\"code\",[e._v(\"Sark class\")]),e._v(\"，\"),a(\"code\",[e._v(\"cls\")]),e._v(\" -> \"),a(\"code\",[e._v(\"Sark class\")]),e._v(\"。\")]),e._v(\" \"),a(\"li\",[e._v(\"进入循环，\"),a(\"code\",[e._v(\"tcls\")]),e._v(\" -> \"),a(\"code\",[e._v(\"Sark meta class\")]),e._v(\"。\")]),e._v(\" \"),a(\"li\",[a(\"code\",[e._v(\"tcls != cls\")]),e._v(\"，继续进入下一个循环，此时 \"),a(\"code\",[e._v(\"tcls\")]),e._v(\" -> \"),a(\"code\",[e._v(\"NSObject meta class\")]),e._v(\"。\")]),e._v(\" \"),a(\"li\",[e._v(\"依然是 \"),a(\"code\",[e._v(\"tcls != cls\")]),e._v(\"，继续进入下一个循环，\"),a(\"code\",[e._v(\"tcls\")]),e._v(\" -> \"),a(\"code\",[e._v(\"NSObject class\")]),e._v(\"。\")]),e._v(\" \"),a(\"li\",[e._v(\"依然是 \"),a(\"code\",[e._v(\"tcls != cls\")]),e._v(\"，继续进入下一个循环，\"),a(\"code\",[e._v(\"tcls\")]),e._v(\" -> \"),a(\"code\",[e._v(\"nil\")]),e._v(\"。\")]),e._v(\" \"),a(\"li\",[e._v(\"退出循环。返回 \"),a(\"code\",[e._v(\"NO\")]),e._v(\"。\")])]),e._v(\" \"),a(\"h4\",{attrs:{id:\"res4\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#res4\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" res4\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[e._v(\"与 \"),a(\"code\",[e._v(\"res2\")]),e._v(\" 相同，因此会来到 \"),a(\"code\",[e._v(\"+ (BOOL)isMemberOfClass:(Class)cls\")]),e._v(\" 方法。此时 \"),a(\"code\",[e._v(\"self\")]),e._v(\" -> \"),a(\"code\",[e._v(\"Sark class\")]),e._v(\"，\"),a(\"code\",[e._v(\"cls\")]),e._v(\" -> \"),a(\"code\",[e._v(\"Sark class\")]),e._v(\"。\")]),e._v(\" \"),a(\"li\",[a(\"code\",[e._v(\"object_getClass((id)self)\")]),e._v(\" 就是获取 \"),a(\"code\",[e._v(\"self\")]),e._v(\" 的 \"),a(\"code\",[e._v(\"isa\")]),e._v(\" 指针，因此这个获取的就是 \"),a(\"code\",[e._v(\"Sark meta class\")]),e._v(\"。\")]),e._v(\" \"),a(\"li\",[e._v(\"显然它与 \"),a(\"code\",[e._v(\"cls\")]),e._v(\" -> \"),a(\"code\",[e._v(\"Sark class\")]),e._v(\" 不相等，返回 \"),a(\"code\",[e._v(\"NO\")]),e._v(\"。\")])]),e._v(\" \"),a(\"p\",[e._v(\"通过这个例子相信你对于 \"),a(\"code\",[e._v(\"Meta Class\")]),e._v(\" 有了更深的印象。总之诀窍就是\"),a(\"strong\",[e._v(\"按图索骥\")]),e._v(\"。\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"cache-t\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#cache-t\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" \"),a(\"code\",[e._v(\"cache_t\")])]),e._v(\" \"),a(\"p\",[e._v(\"下面是 \"),a(\"code\",[e._v(\"cache_t\")]),e._v(\" 的定义简化后的代码\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// objc-runtime-new.h line 59\\nstruct cache_t {\\n    struct bucket_t *_buckets;\\n    mask_t _mask;\\n    mask_t _occupied;\\n}\\n\\n// objc-runtime-new.h line 37\\nstruct bucket_t {\\n    cache_key_t _key;\\n    MethodCacheIMP _imp; // using MethodCacheIMP = IMP;\\n}\\n\\n// objc-runtime-new.h line 28\\ntypedef uint32_t mask_t; // unsigned int\\n\\n// objc-runtime-new.h line 32\\ntypedef uintptr_t cache_key_t; // unsigned long\\n\")])])]),a(\"p\",[e._v(\"通过源码(objc-cache.mm line 243-637)可以看出\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[a(\"code\",[e._v(\"cache_t\")]),e._v(\"： 其实是一个散列表，以 \"),a(\"code\",[e._v(\"SEL\")]),e._v(\" 为 \"),a(\"code\",[e._v(\"key\")]),e._v(\" 储存 \"),a(\"code\",[e._v(\"SEL+IMP\")]),e._v(\"。\")]),e._v(\" \"),a(\"li\",[a(\"code\",[e._v(\"_buckets\")]),e._v(\"： 是一个数组，它里面放的是 \"),a(\"code\",[e._v(\"bucket_t\")]),e._v(\"。会随着加入数据的增多而进行扩容。\")]),e._v(\" \"),a(\"li\",[a(\"code\",[e._v(\"_mask\")]),e._v(\"： 已经分配内存空间 \"),a(\"code\",[e._v(\"_buckets\")]),e._v(\" 的总数减一。用于 hash 计算。\")]),e._v(\" \"),a(\"li\",[a(\"code\",[e._v(\"_occupied\")]),e._v(\"： 表示是已经缓存的 \"),a(\"code\",[e._v(\"buckets\")]),e._v(\" 数量。\")])]),e._v(\" \"),a(\"p\",[e._v(\"下面我们来看一下两个关键函数。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// objc-cache.mm line 524 \\n// 根据 key 查找对应的 bucket_t\\nbucket_t * cache_t::find(cache_key_t k, id receiver)\\n{\\n    assert(k != 0);\\n\\n    // 找到 _buckets\\n    bucket_t *b = buckets();\\n    // 找到 _mask\\n    mask_t m = mask();\\n\\n    // 获取 k 对应的 hash 值\\n    mask_t begin = cache_hash(k, m);\\n    // 下面是通过线性探测的方法来查找,所以该方法会返回找到的 key 对应的 bucket_t，找不到就返回数组中最后为空的那个位置。\\n    mask_t i = begin;\\n    do {\\n        if (b[i].key() == 0  ||  b[i].key() == k) {\\n            return &b[i];\\n        }\\n    } while ((i = cache_next(i, m)) != begin);\\n\\n    // 报错\\n    // hack\\n    Class cls = (Class)((uintptr_t)this - offsetof(objc_class, cache));\\n    cache_t::bad_cache(receiver, (SEL)k, cls);\\n}\\n\")])])]),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// objc-cache.mm line 561 \\n// 这是存数据的方法，需要传入 cls 类、sel 方法名、imp 方法实现、receiver 方法接收者\\nstatic void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)\\n{\\n    cacheUpdateLock.assertLocked();\\n\\n    // Never cache before +initialize is done\\n    if (!cls->isInitialized()) return;\\n\\n    // 先看一下是否已经存在缓存\\n    // Make sure the entry wasn't added to the cache by some other thread \\n    // before we grabbed the cacheUpdateLock.\\n    if (cache_getImp(cls, sel)) return;\\n\\n    cache_t *cache = getCache(cls);\\n    cache_key_t key = getKey(sel);\\n\\n    // hash 表的装载因子小于 3/4 的时候存入，否则进行扩容\\n    // Use the cache as-is if it is less than 3/4 full\\n    mask_t newOccupied = cache->occupied() + 1;\\n    mask_t capacity = cache->capacity();\\n    if (cache->isConstantEmptyCache()) {\\n        // Cache is read-only. Replace it.\\n        cache->reallocate(capacity, capacity ?: INIT_CACHE_SIZE);\\n    }\\n    else if (newOccupied <= capacity / 4 * 3) {\\n        // Cache is less than 3/4 full. Use it as-is.\\n    }\\n    else {\\n        // Cache is too full. Expand it.\\n        cache->expand();\\n    }\\n\\n    // 来到这里能保证装载因子小于 3/4.\\n    // Scan for the first unused slot and insert there.\\n    // There is guaranteed to be an empty slot because the \\n    // minimum size is 4 and we resized at 3/4 full.\\n    bucket_t *bucket = cache->find(key, receiver);\\n    // 根据上面 find 函数的分析可以看出这个 bucket 里的内容是可能为空的。这就是找不到当前 key 对应的值，这种情况下返回一个空白的 bucket，因此这时候需要添加 _occupied 数量，然后将其存入散列表中\\n    if (bucket->key() == 0) cache->incrementOccupied();\\n    bucket->set(key, imp);\\n}\\n\")])])]),a(\"p\",[e._v(\"上面分析了 \"),a(\"code\",[e._v(\"cache_t\")]),e._v(\" 的实现，其实 \"),a(\"code\",[e._v(\"cache\")]),e._v(\" 的作用就是缓存调用过的方法，这样以来查找方法的时候先去 \"),a(\"code\",[e._v(\"cache\")]),e._v(\" 中查找，找不到了再去方法列表找，这样就提高查找方法的效率。\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"class-data-bits-t-和-class-rw-t-data\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#class-data-bits-t-和-class-rw-t-data\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" \"),a(\"code\",[e._v(\"class_data_bits_t\")]),e._v(\" 和 \"),a(\"code\",[e._v(\"class_rw_t *data()\")])]),e._v(\" \"),a(\"p\",[e._v(\"通过对比新旧两版的 \"),a(\"code\",[e._v(\"objc_class\")]),e._v(\" 的实现，可以看出来 \"),a(\"code\",[e._v(\"isa\")]),e._v(\"、\"),a(\"code\",[e._v(\"superclass\")]),e._v(\"、\"),a(\"code\",[e._v(\"cache\")]),e._v(\" 这些基本是相同的。但是旧版本中的 \"),a(\"code\",[e._v(\"ivars\")]),e._v(\"、\"),a(\"code\",[e._v(\"methodLists\")]),e._v(\" 都找不到了，那我们猜测可以通过 \"),a(\"code\",[e._v(\"class_data_bits_t\")]),e._v(\" 和 \"),a(\"code\",[e._v(\"class_rw_t *data()\")]),e._v(\" 函数找到他们。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// objc-runtime-new.h line 869\\nstruct class_data_bits_t {\\n    // Values are the FAST_ flags above.\\n    uintptr_t bits;\\n\\n    // line 922\\n    class_rw_t* data() {\\n        return (class_rw_t *)(bits & FAST_DATA_MASK);\\n    }\\n}\\n\")])])]),a(\"p\",[e._v(\"可以看出 \"),a(\"code\",[e._v(\"class_data_bits_t\")]),e._v(\" 结构体中只包含一个 \"),a(\"code\",[e._v(\"unsigned long\")]),e._v(\" 类型的 \"),a(\"code\",[e._v(\"bits\")]),e._v(\"。它占有 64 位空间。将 \"),a(\"code\",[e._v(\"bits\")]),e._v(\" 与 \"),a(\"code\",[e._v(\"FAST_DATA_MASK\")]),e._v(\" 做按位与运算后，转化为 \"),a(\"code\",[e._v(\"class_rw_t *\")]),e._v(\" 返回。\")]),e._v(\" \"),a(\"p\",[a(\"code\",[e._v(\"FAST_DATA_MASK\")]),e._v(\" 是个 16 进制的数，转化为二进制就是\"),a(\"code\",[e._v(\"11111111111111111111111111111111111111111111000\")]),e._v(\" 长度为 47 位。因此返回的信息就是 [3 47]之间的数据。\")]),e._v(\" \"),a(\"blockquote\",[a(\"p\",[e._v(\"在 x86_64 架构上，Mac OS 只使用了其中的 47 位来为对象分配地址。而且由于地址要按字节在内存中按字节对齐，所以掩码的后三位都是 0。\\n因为 class_rw_t * 指针只存于第 [3, 47] 位，所以可以使用最后三位来存储关于当前类的其他信息\")])]),e._v(\" \"),a(\"table\",[a(\"thead\",[a(\"tr\",[a(\"th\",[e._v(\"63-47\")]),e._v(\" \"),a(\"th\",[e._v(\"46-3\")]),e._v(\" \"),a(\"th\",[e._v(\"2\")]),e._v(\" \"),a(\"th\",[e._v(\"1\")]),e._v(\" \"),a(\"th\",[e._v(\"0\")])])]),e._v(\" \"),a(\"tbody\",[a(\"tr\",[a(\"td\",[e._v(\"空闲\")]),e._v(\" \"),a(\"td\",[e._v(\"class_rw_t data\")]),e._v(\" \"),a(\"td\",[e._v(\"hasDefaultRR\")]),e._v(\" \"),a(\"td\",[e._v(\"isSwiftStable\")]),e._v(\" \"),a(\"td\",[e._v(\"isSwiftLegacy\")])])])]),e._v(\" \"),a(\"p\",[e._v(\"我们看一下 \"),a(\"code\",[e._v(\"FAST_DATA_MASK\")]),e._v(\" 的定义。\")]),e._v(\" \"),a(\"p\",[e._v(\"(在查找 \"),a(\"code\",[e._v(\"FAST_DATA_MASK\")]),e._v(\" 定义的时候，你会发现它的周围有很多类似的定义，根据宏 \"),a(\"code\",[e._v(\"__LP64__\")]),e._v(\" 来判断到底编译哪个。关于 \"),a(\"code\",[e._v(\"__LP64__\")]),e._v(\" 的更多信息可以看\"),a(\"a\",{attrs:{href:\"https://stackoverflow.com/questions/6721037/where-is-lp64-defined-for-default-builds-of-c-applications-on-osx-10-6\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"这里\"),a(\"OutboundLink\")],1),e._v(\"。你可以通过在终端中通过 \"),a(\"code\",[e._v(\"cpp -dM /dev/null\")]),e._v(\" 命令来查看宏定义的列表。我看了一下是\"),a(\"code\",[e._v(\"#define _LP64 1\")]),e._v(\"。)\")]),e._v(\" \"),a(\"p\",[e._v(\"更新：在 这位大神的 \"),a(\"a\",{attrs:{href:\"http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"文章\"),a(\"OutboundLink\")],1),e._v(\" 里了解到了这些宏定义代表的意义分别是：32 位，64位兼容版，64位不兼容版。我的属于 64 位兼容版。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// objc-runtime-new.h line 485 \\n// Leaks-compatible version that steals low bits only.\\n\\n// class or superclass has .cxx_construct implementation\\n#define RW_HAS_CXX_CTOR       (1<<18)\\n// class or superclass has .cxx_destruct implementation\\n#define RW_HAS_CXX_DTOR       (1<<17)\\n// class or superclass has default alloc/allocWithZone: implementation\\n// Note this is is stored in the metaclass.\\n#define RW_HAS_DEFAULT_AWZ    (1<<16)\\n// class's instances requires raw isa\\n#define RW_REQUIRES_RAW_ISA   (1<<15)\\n\\n// class is a Swift class from the pre-stable Swift ABI\\n#define FAST_IS_SWIFT_LEGACY    (1UL<<0)\\n// class is a Swift class from the stable Swift ABI\\n#define FAST_IS_SWIFT_STABLE    (1UL<<1)\\n// class or superclass has default retain/release/autorelease/retainCount/\\n//   _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference\\n#define FAST_HAS_DEFAULT_RR     (1UL<<2)\\n// data pointer\\n#define FAST_DATA_MASK          0x00007ffffffffff8UL\\n\")])])]),a(\"p\",[e._v(\"这些都是标志位，利用空闲的空间来存储关于当前类的一些信息。比如下面这些是 与 \"),a(\"code\",[e._v(\"bits\")]),e._v(\" 进行按位与运算来获取。其他的则通过与 \"),a(\"code\",[e._v(\"class_rw_t\")]),e._v(\" 中的 \"),a(\"code\",[e._v(\"flags\")]),e._v(\" 按位与运算获取。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// FAST_DATA_MASK\\n0000 0000 0000 0000 0111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1000\\n// FAST_IS_SWIFT_LEGACY\\n0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001\\n// FAST_IS_SWIFT_STABLE\\n0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0010\\n// FAST_HAS_DEFAULT_RR\\n0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0100\\n\")])])]),a(\"p\",[e._v(\"综合上面的内容我们可以看出来 \"),a(\"code\",[e._v(\"class_data_bits_t\")]),e._v(\" 结构体主要作用就是存储 \"),a(\"code\",[e._v(\"class_rw_t\")]),e._v(\" 的地址及一些当前类的信息。更多的信息还是在 \"),a(\"code\",[e._v(\"class_rw_t\")]),e._v(\" 中。\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"class-rw-t-和-class-ro-t\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#class-rw-t-和-class-ro-t\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" \"),a(\"code\",[e._v(\"class_rw_t\")]),e._v(\" 和 \"),a(\"code\",[e._v(\"class_ro_t\")])]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// objc-runtime-new.h lina 826\\nstruct class_rw_t {\\n    // Be warned that Symbolication knows the layout of this structure.\\n    // 一些类相关的标志位，更多的内容可以看 objc-runtime-new.h line 390\\n    uint32_t flags;\\n    uint32_t version;\\n\\n    const class_ro_t *ro;\\n\\n    method_array_t methods;\\n    property_array_t properties;\\n    protocol_array_t protocols;\\n\\n    Class firstSubclass;\\n    Class nextSiblingClass;\\n\\n    char *demangledName;\\n}\\n\")])])]),a(\"p\",[e._v(\"我们可以看出有一个名字非常类似的 \"),a(\"code\",[e._v(\"class_ro_t\")]),e._v(\" 结构体，它的结构如下。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// objc-runtime-new.h lina 553\\nstruct class_ro_t {\\n    uint32_t flags;\\n    uint32_t instanceStart;\\n    uint32_t instanceSize;\\n    uint32_t reserved;\\n\\n    const uint8_t * ivarLayout;\\n    \\n    const char * name;\\n    method_list_t * baseMethodList;\\n    protocol_list_t * baseProtocols;\\n    const ivar_list_t * ivars;\\n\\n    const uint8_t * weakIvarLayout;\\n    property_list_t *baseProperties;\\n\\n    method_list_t *baseMethods() const {\\n        return baseMethodList;\\n    }\\n};\\n\")])])]),a(\"blockquote\",[a(\"p\",[e._v(\"这里的 'rw' 和 ro' 分别表示 'readwrite' 和 'readonly'。class_ro_t是一个指向常量的指针，存储来编译器决定了的属性、方法和遵守协议。\")])]),e._v(\" \"),a(\"p\",[e._v(\"为了更好的理解上面这句话，需要去读一下 \"),a(\"code\",[e._v(\"realizeClass()\")]),e._v(\" 这个函数。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// objc-runtime-new.mm line 1858\\nstatic Class realizeClass(Class cls)\\n{\\n    const class_ro_t *ro;\\n    class_rw_t *rw;\\n    ...\\n    ro = (const class_ro_t *)cls->data();\\n    if (ro->flags & RO_FUTURE) {\\n        // This was a future class. rw data is already allocated.\\n        rw = cls->data();\\n        ro = cls->data()->ro;\\n        cls->changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);\\n    } else {\\n        // Normal class. Allocate writeable class data.\\n        rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1);\\n        rw->ro = ro;\\n        rw->flags = RW_REALIZED|RW_REALIZING;\\n        cls->setData(rw);\\n    }\\n\\n    ...\\n\\n    methodizeClass(cls);\\n\\n}\\n\")])])]),a(\"p\",[e._v(\"我们都知道类的实力化是在 \"),a(\"code\",[e._v(\"main\")]),e._v(\" 函数调用之前进行的。这时候会调用 \"),a(\"code\",[e._v(\"realizeClass\")]),e._v(\"函数。\")]),e._v(\" \"),a(\"p\",[e._v(\"调用 \"),a(\"code\",[e._v(\"realizeClass\")]),e._v(\" 函数之前 \"),a(\"code\",[e._v(\"class_data_bits_t *data\")]),e._v(\" 指向的是 \"),a(\"code\",[e._v(\"class_ro_t\")]),e._v(\" 结构体，它是在编译期间就确定的。\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:s(402),alt:\"\"}})]),e._v(\" \"),a(\"blockquote\",[a(\"p\",[e._v(\"图片来自 \"),a(\"a\",{attrs:{href:\"https://github.com/draveness/analyze/blob/master/contents/objc/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20ObjC%20%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84.md\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"Dravenss\"),a(\"OutboundLink\")],1)])]),e._v(\" \"),a(\"p\",[e._v(\"然后我们看到在 \"),a(\"code\",[e._v(\"realizeClass\")]),e._v(\" 函数中下面几步操作。\")]),e._v(\" \"),a(\"ol\",[a(\"li\",[a(\"code\",[e._v(\"ro = (const class_ro_t *)cls->data();\")]),e._v(\" 获取编译期间就确定的 \"),a(\"code\",[e._v(\"class_ro_t\")])]),e._v(\" \"),a(\"li\",[a(\"code\",[e._v(\"rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1);\")]),e._v(\" 初始化 \"),a(\"code\",[e._v(\"class_rw_t\")]),e._v(\" 结构体\")]),e._v(\" \"),a(\"li\",[a(\"code\",[e._v(\"rw->ro = ro;\")]),e._v(\" \"),a(\"code\",[e._v(\"rw->flags = RW_REALIZED|RW_REALIZING;\")]),e._v(\" 设置 \"),a(\"code\",[e._v(\"class_rw_t\")]),e._v(\" 结构体\")]),e._v(\" \"),a(\"li\",[a(\"code\",[e._v(\"cls->setData(rw);\")]),e._v(\" 设置类的 data\")])]),e._v(\" \"),a(\"p\",[a(\"code\",[e._v(\"realizeClass\")]),e._v(\" 执行后\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:s(403),alt:\"\"}})]),e._v(\" \"),a(\"blockquote\",[a(\"p\",[e._v(\"图片来自 \"),a(\"a\",{attrs:{href:\"https://github.com/draveness/analyze/blob/master/contents/objc/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20ObjC%20%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84.md\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"Dravenss\"),a(\"OutboundLink\")],1)])]),e._v(\" \"),a(\"p\",[e._v(\"如果在上面 \"),a(\"code\",[e._v(\"cls->setData(rw);\")]),e._v(\" 执行之后打断点的话你会发现 \"),a(\"code\",[e._v(\"rw\")]),e._v(\" 的方法列表中是空的，最后需要通过 \"),a(\"code\",[e._v(\"methodizeClass\")]),e._v(\" 函数来将 \"),a(\"code\",[e._v(\"ro\")]),e._v(\" 里面的 \"),a(\"code\",[e._v(\"baseMethods\")]),e._v(\"、\"),a(\"code\",[e._v(\"baseProperties\")]),e._v(\"、\"),a(\"code\",[e._v(\"baseProtocols\")]),e._v(\" 分别添加到 \"),a(\"code\",[e._v(\"rw\")]),e._v(\" 中的 \"),a(\"code\",[e._v(\"methods\")]),e._v(\"、\"),a(\"code\",[e._v(\"properties\")]),e._v(\"、\"),a(\"code\",[e._v(\"protocols\")]),e._v(\" 之中。\")]),e._v(\" \"),a(\"p\",[e._v(\"这样以来，在运行时的时候添加的方法，以及 category 中的方法被添加到 \"),a(\"code\",[e._v(\"rw\")]),e._v(\" 之中。这也解释了为什么 category 不能添加成员变量。因为成员变量相关的信息是放于 \"),a(\"code\",[e._v(\"ro\")]),e._v(\" 中的，它是 readonly 的。\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"method\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#method\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" \"),a(\"code\",[e._v(\"Method\")])]),e._v(\" \"),a(\"p\",[e._v(\"通过代码我们看出 \"),a(\"code\",[e._v(\"class_rw_t\")]),e._v(\" 的 \"),a(\"code\",[e._v(\"method_array_t methods\")]),e._v(\" 和 \"),a(\"code\",[e._v(\"class_ro_t\")]),e._v(\" 的 \"),a(\"code\",[e._v(\"method_list_t * baseMethodList\")]),e._v(\" 都是存储 \"),a(\"code\",[e._v(\"method_t\")]),e._v(\" 的容器。\"),a(\"code\",[e._v(\"method_t\")]),e._v(\" 就是用来表示一个方法的数据类型。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// objc-private.h line 186\\ntypedef struct method_t *Method;\\n\\n// objc-runtime-new.h line 222\\nstruct method_t {\\n    SEL name;\\n    const char *types;\\n    MethodListIMP imp;\\n};\\n\\n// objc.h line 50\\n/// An opaque type that represents a method selector.\\ntypedef struct objc_selector *SEL;\\n\\n// objc.h line 52\\n/// A pointer to the function of a method implementation. \\ntypedef void (*IMP)(void /* id, SEL, ... */ ); \\n\")])])]),a(\"h3\",{attrs:{id:\"sel\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#sel\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" \"),a(\"code\",[e._v(\"SEL\")])]),e._v(\" \"),a(\"p\",[a(\"code\",[e._v(\"SEL\")]),e._v(\" ：方法选择器，代码中 \"),a(\"code\",[e._v(\"SEL\")]),e._v(\" 就是 \"),a(\"code\",[e._v(\"objc_selector\")]),e._v(\" 结构体的指针。不过在源码中并没有找到 \"),a(\"code\",[e._v(\"objc_selector\")]),e._v(\" 的定义。但根据使用经验可以得出以下结论。\")]),e._v(\" \"),a(\"ol\",[a(\"li\",[a(\"code\",[e._v(\"objc_selector\")]),e._v(\" 在编译时会根据每个方法名和参数序列生成唯一标识\")]),e._v(\" \"),a(\"li\",[e._v(\"与类无关，相同名字的方法即使在不同类中定义，它们的 \"),a(\"code\",[e._v(\"SEL\")]),e._v(\" 也相同\")])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"const-char-types\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#const-char-types\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" \"),a(\"code\",[e._v(\"const char *types\")])]),e._v(\" \"),a(\"p\",[e._v(\"这是方法的类型编码，里面有对应的参数类型和返回值类型。具体信息可以参考 \"),a(\"a\",{attrs:{href:\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"官方文档\"),a(\"OutboundLink\")],1),e._v(\" 和 \"),a(\"a\",{attrs:{href:\"http://blog.sunnyxx.com/2016/08/13/reunderstanding-runtime-1/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"重识 Objective-C Runtime - 看透 Type 与 Value\"),a(\"OutboundLink\")],1),e._v(\"。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"imp\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#imp\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" \"),a(\"code\",[e._v(\"IMP\")])]),e._v(\" \"),a(\"p\",[a(\"code\",[e._v(\"IMP\")]),e._v(\" 本质上就是一个函数指针，指向方法的实现。\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"ivar\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#ivar\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" \"),a(\"code\",[e._v(\"Ivar\")])]),e._v(\" \"),a(\"p\",[e._v(\"通过代码可以知道 \"),a(\"code\",[e._v(\"ivar_list_t\")]),e._v(\" 就是存储成员变量的容器。它里面存储的就是 \"),a(\"code\",[e._v(\"ivar_t\")]),e._v(\"。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// objc-private.h line 187\\ntypedef struct ivar_t *Ivar;\\n\\n// objc-runtime-new.h line 237\\nstruct ivar_t {\\n    int32_t *offset; // 基地址偏移\\n    const char *name; // 变量名\\n    const char *type; // 变量类型\\n    // alignment is sometimes -1; use alignment() instead\\n    uint32_t alignment_raw;\\n    uint32_t size;\\n}\\n\")])])]),a(\"p\",[e._v(\"OC 中许多的字典转模型的框架都是利用 \"),a(\"code\",[e._v(\"ivar_t\")]),e._v(\" 的结构开实现“反射”。\")]),e._v(\" \"),a(\"p\",[e._v(\"如果通过 \"),a(\"code\",[e._v(\"class_copyIvarList\")]),e._v(\" 函数获取的会在原本的属性名前加上一个下划线。\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"objc-property-t\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#objc-property-t\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" \"),a(\"code\",[e._v(\"objc_property_t\")])]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// objc-private.h line 189\\ntypedef struct property_t *objc_property_t;\\n\\n// objc-runtime-new.h line 259\\nstruct property_t {\\n    const char *name;\\n    const char *attributes;\\n};\\n\")])])]),a(\"p\",[e._v(\"这里面需要注意的就是 \"),a(\"code\",[e._v(\"attributes\")]),e._v(\"，它来描述属性的类型，跟 \"),a(\"code\",[e._v(\"method_t\")]),e._v(\" 中的 \"),a(\"code\",[e._v(\"types\")]),e._v(\"\\n类似。更多的信息可以查看 \"),a(\"a\",{attrs:{href:\"https://www.jianshu.com/p/cefa1da5e775\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"这篇文章\"),a(\"OutboundLink\")],1),e._v(\"。\")]),e._v(\" \"),a(\"p\",[e._v(\"另外通过 \"),a(\"code\",[e._v(\"class_copyPropertyList\")]),e._v(\" 获取的属性名是没有下划线的。\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"protocol-t\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#protocol-t\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" \"),a(\"code\",[e._v(\"protocol_t\")])]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// objc-runtime-new.h line 296\\nstruct protocol_t : objc_object {\\n    const char *mangledName;\\n    struct protocol_list_t *protocols;\\n    method_list_t *instanceMethods;\\n    method_list_t *classMethods;\\n    method_list_t *optionalInstanceMethods;\\n    method_list_t *optionalClassMethods;\\n    property_list_t *instanceProperties;\\n    uint32_t size;   // sizeof(protocol_t)\\n    uint32_t flags;\\n    // Fields below this point are not always present on disk.\\n    const char **_extendedMethodTypes;\\n    const char *_demangledName;\\n    property_list_t *_classProperties;\\n    ...\\n}\\n\")])])]),a(\"p\",[e._v(\"复杂性超出了预料，而且通过代码我们可以看出来 \"),a(\"code\",[e._v(\"protocol_t\")]),e._v(\" 继承自 \"),a(\"code\",[e._v(\"objc_object\")]),e._v(\"。因此它也是一个类。\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[e._v(\"mangledName和_demangledName\\n这个东西来源于c++的name mangling（命名重整）技术，在c++里面是用来区别重载时的函数。\")]),e._v(\" \"),a(\"li\",[e._v(\"instanceMethods和optionalInstanceMethods\\n对应的是实例方法，可选实例方法，可选就是写在@optional之后的方法。\")]),e._v(\" \"),a(\"li\",[e._v(\"classMethods和optionalClassMethods\\n与上面对应，分别是类方法，可选类方法\")]),e._v(\" \"),a(\"li\",[e._v(\"instanceProperties\\n实例属性。奇怪的是这里为什么不区分必须还是可选？\")]),e._v(\" \"),a(\"li\",[e._v(\"_classProperties\\n类属性。挺少见的，举个例子：\")])]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// 这是常见的属性声明，也就是对象属性\\n@property (nonatomic, assign) NSInteger count;\\n// 这是类属性，与类方法一样，通过类名调用\\n@property (class, nonatomic, copy) NSString *name;\\n\")])])]),a(\"ul\",[a(\"li\",[e._v(\"protocols\\n此协议遵循的协议\")])]),e._v(\" \"),a(\"blockquote\",[a(\"p\",[e._v(\"以上介绍来自 \"),a(\"a\",{attrs:{href:\"https://www.jianshu.com/p/fe8048524e67\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"这里\"),a(\"OutboundLink\")],1)])]),e._v(\" \"),a(\"h2\",{attrs:{id:\"category\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#category\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" \"),a(\"code\",[e._v(\"Category\")])]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// objc-private.h line 188\\ntypedef struct category_t *Category;\\n\\n// objc-runtime-new.h line 1381\\nstruct category_t {\\n    const char *name;\\n    classref_t cls;\\n    struct method_list_t *instanceMethods;\\n    struct method_list_t *classMethods;\\n    struct protocol_list_t *protocols;\\n    struct property_list_t *instanceProperties;\\n    // Fields below this point are not always present on disk.\\n    struct property_list_t *_classProperties;\\n    ...\\n};\\n\")])])]),a(\"blockquote\",[a(\"p\",[e._v(\"可以看出 \"),a(\"code\",[e._v(\"category\")]),e._v(\" 的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。\")])]),e._v(\" \"),a(\"p\",[e._v(\"在上面我们了解到 \"),a(\"code\",[e._v(\"realizeClass\")]),e._v(\" 函数中最后会调用 \"),a(\"code\",[e._v(\"methodizeClass\")]),e._v(\" 函数，它会调用 \"),a(\"code\",[e._v(\"attachCategories\")]),e._v(\" 函数来将 \"),a(\"code\",[e._v(\"class_rw_t\")]),e._v(\" 中的 \"),a(\"code\",[e._v(\"method_array_t\")]),e._v(\", \"),a(\"code\",[e._v(\"property_array_t\")]),e._v(\", \"),a(\"code\",[e._v(\"protocol_array_t\")]),e._v(\" 数组中分别添加到 \"),a(\"code\",[e._v(\"method_list_t\")]),e._v(\", \"),a(\"code\",[e._v(\"property_list_t\")]),e._v(\", \"),a(\"code\",[e._v(\"protocol_list_t\")]),e._v(\" 中。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// objc-runtime-new.mm line 759\\n// Attach method lists and properties and protocols from categories to a class.\\n// Assumes the categories in cats are all loaded and sorted by load order, \\n// oldest categories first.\\nstatic void \\nattachCategories(Class cls, category_list *cats, bool flush_caches)\\n{\\n    ...\\n    // fixme rearrange to remove these intermediate allocations\\n    method_list_t **mlists = (method_list_t **)\\n        malloc(cats->count * sizeof(*mlists));\\n    property_list_t **proplists = (property_list_t **)\\n        malloc(cats->count * sizeof(*proplists));\\n    protocol_list_t **protolists = (protocol_list_t **)\\n        malloc(cats->count * sizeof(*protolists));\\n    ...\\n    auto rw = cls->data();\\n\\n    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);\\n    rw->methods.attachLists(mlists, mcount);\\n    free(mlists);\\n    if (flush_caches  &&  mcount > 0) flushCaches(cls);\\n\\n    rw->properties.attachLists(proplists, propcount);\\n    free(proplists);\\n\\n    rw->protocols.attachLists(protolists, protocount);\\n    free(protolists);\\n}\\n\")])])]),a(\"p\",[e._v(\"关于分类的更多信息可以查看美团的\"),a(\"a\",{attrs:{href:\"https://tech.meituan.com/2015/03/03/diveintocategory.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"这篇文章\"),a(\"OutboundLink\")],1),e._v(\"。\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"qa-一些问答\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#qa-一些问答\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" QA 一些问答\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"_1-分类和协议中能否添加属性和成员变量\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-分类和协议中能否添加属性和成员变量\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 1. 分类和协议中能否添加属性和成员变量\")]),e._v(\" \"),a(\"p\",[e._v(\"先上代码。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v('@protocol LenderProtocol <NSObject>\\n@property float age;\\n@end\\n\\n@interface Lender : NSObject<LenderProtocol>\\n@property float name;\\n@end\\n@implementation Lender\\n//@synthesize age;\\n@end\\n\\n@interface Lender (Category)\\n@property float score;\\n@end\\n@implementation Lender (Category)\\n//@dynamic score;\\n@end\\n\\nint main(int argc, const char * argv[]) {\\n    @autoreleasepool {\\n        id LenderClass = objc_getClass(\"Lender\");\\n        unsigned int outCount, i;\\n        objc_property_t *properties = class_copyPropertyList(LenderClass, &outCount);\\n        for (i = 0; i < outCount; ++i) {\\n            objc_property_t property = properties[i];\\n            NSLog(@\"%s---%s\", property_getName(property), property_getAttributes(property));\\n        }\\n        NSLog(@\"\\\\n==============\\\\n\");\\n        unsigned int ivarCount, j;\\n        Ivar *ivars = class_copyIvarList(LenderClass, &ivarCount);\\n        for (j = 0; j < ivarCount; ++j) {\\n            Ivar ivar = ivars[j];\\n            NSLog(@\"%s---%s---%td\", ivar_getName(ivar), ivar_getTypeEncoding(ivar), ivar_getOffset(ivar));\\n        }\\n        NSLog(@\"\\\\n==============\\\\n\");\\n        unsigned int methodCount, k;\\n        Method *methods = class_copyMethodList(LenderClass, &methodCount);\\n        for (k = 0; k < methodCount; ++k) {\\n            Method method = methods[k];\\n            NSLog(@\"%@----%s\", NSStringFromSelector(method_getName(method)), method_getTypeEncoding(method));\\n        }\\n    }\\n    return 0;\\n}\\n')])])]),a(\"p\",[e._v(\"输出\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v('2019-03-01 18:07:11.298699+0800 test[5126:1225981] score---Tf\\n2019-03-01 18:07:11.298863+0800 test[5126:1225981] name---Tf,V_name\\n2019-03-01 18:07:11.298873+0800 test[5126:1225981] hash---TQ,R\\n2019-03-01 18:07:11.298882+0800 test[5126:1225981] superclass---T#,R\\n2019-03-01 18:07:11.298889+0800 test[5126:1225981] description---T@\"NSString\",R,C\\n2019-03-01 18:07:11.298897+0800 test[5126:1225981] debugDescription---T@\"NSString\",R,C\\n2019-03-01 18:07:11.298905+0800 test[5126:1225981] age---Tf\\n2019-03-01 18:07:11.298912+0800 test[5126:1225981] \\n==============\\n2019-03-01 18:07:11.298949+0800 test[5126:1225981] _name---f---8\\n2019-03-01 18:07:11.298959+0800 test[5126:1225981] \\n==============\\n2019-03-01 18:07:11.299041+0800 test[5126:1225981] name----f16@0:8\\n2019-03-01 18:07:11.299119+0800 test[5126:1225981] setName:----v20@0:8f16\\nProgram ended with exit code: 0\\n')])])]),a(\"p\",[e._v(\"答案是他们都可以添加属性，但是无法添加成员变量。其中对于协议中声明的属性，遵守该协议的类可以通过 \"),a(\"code\",[e._v(\"@synthesize\")]),e._v(\" 来生成成员变量和 setter getter。（好吧，虽然没什么卵用）。\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"参考\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#参考\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 参考\")]),e._v(\" \"),a(\"ol\",[a(\"li\",[a(\"a\",{attrs:{href:\"http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"Objective-C Runtime\"),a(\"OutboundLink\")],1)]),e._v(\" \"),a(\"li\",[a(\"a\",{attrs:{href:\"https://github.com/draveness/analyze/blob/master/contents/objc/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20ObjC%20%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84.md\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"深入解析 ObjC 中方法的结构\"),a(\"OutboundLink\")],1)]),e._v(\" \"),a(\"li\",[a(\"a\",{attrs:{href:\"https://github.com/bestswifter/blog/blob/master/articles/objc-runtime.md\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"结合 category 工作原理分析 OC2.0 中的 runtime\"),a(\"OutboundLink\")],1)]),e._v(\" \"),a(\"li\",[a(\"a\",{attrs:{href:\"https://tech.meituan.com/2015/03/03/diveintocategory.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"深入理解Objective-C：Category\"),a(\"OutboundLink\")],1)]),e._v(\" \"),a(\"li\",[a(\"a\",{attrs:{href:\"https://halfrost.com/objc_runtime_isa_class/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"神经病院 Objective-C Runtime 入院第一天—— isa 和 Class\"),a(\"OutboundLink\")],1)]),e._v(\" \"),a(\"li\",[a(\"a\",{attrs:{href:\"http://www.starming.com/2015/04/01/objc-runtime/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"Objc Runtime 总结\"),a(\"OutboundLink\")],1)])])])},[],!1,null,null,null);t.default=_.exports}}]);","extractedComments":[]}