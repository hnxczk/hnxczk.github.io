{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[111],{470:function(a,r,t){\"use strict\";t.r(r);var e=t(0),s=Object(e.a)({},function(){var a=this,r=a.$createElement,t=a._self._c||r;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":a.$parent.slotKey}},[t(\"h1\",{attrs:{id:\"javascript-学习记录\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#javascript-学习记录\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" JavaScript 学习记录\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_1-mac-上-chrome-打开“开发者工具”-⌘-option-i-chrome-键盘快捷键\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-mac-上-chrome-打开“开发者工具”-⌘-option-i-chrome-键盘快捷键\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 1. Mac 上 Chrome 打开“开发者工具”:\\t⌘ + Option + i \"),t(\"a\",{attrs:{href:\"https://support.google.com/chrome/answer/157179?hl=zh-Hans\",target:\"_blank\",rel:\"noopener noreferrer\"}},[a._v(\"Chrome 键盘快捷键\"),t(\"OutboundLink\")],1)]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_2-由于浏览器的安全限制，以-file-开头的地址无法执行如联网等javascript代码，最终，你还是需要架设一个web服务器，然后以-http-开头的地址来正常执行所有javascript代码。\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-由于浏览器的安全限制，以-file-开头的地址无法执行如联网等javascript代码，最终，你还是需要架设一个web服务器，然后以-http-开头的地址来正常执行所有javascript代码。\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 2. 由于浏览器的安全限制，以 file:// 开头的地址无法执行如联网等JavaScript代码，最终，你还是需要架设一个Web服务器，然后以 http:// 开头的地址来正常执行所有JavaScript代码。\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_3-javascript并不强制要求在每个语句的结尾加-，浏览器中负责执行javascript代码的引擎会自动在每个语句的结尾补上-。\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-javascript并不强制要求在每个语句的结尾加-，浏览器中负责执行javascript代码的引擎会自动在每个语句的结尾补上-。\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 3. JavaScript并不强制要求在每个语句的结尾加 ; ，浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上 ; 。\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_4-number-类型\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-number-类型\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 4. Number 类型\")]),a._v(\" \"),t(\"h3\",{attrs:{id:\"nan\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#nan\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" NaN\")]),a._v(\" \"),t(\"p\",[a._v(\"NaN 表示 Not a Number，当无法计算结果时用NaN表示.这个特殊的Number与所有其他值都不相等，包括它自己：\")]),a._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[a._v(\"NaN === NaN; // false\\n\")])])]),t(\"p\",[a._v(\"唯一能判断NaN的方法是通过isNaN()函数：\")]),a._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[a._v(\"isNaN(NaN); // true\\n\")])])]),t(\"h3\",{attrs:{id:\"infinity\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#infinity\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" Infinity\")]),a._v(\" \"),t(\"p\",[a._v(\"Infinity 表示无限大，当数值超过了 JavaScript 的 Number 所能表示的最大值时，就表示为 Infinity\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_5-字符串是以单引号-或双引号-括起来的任意文本\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5-字符串是以单引号-或双引号-括起来的任意文本\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 5.字符串是以单引号'或双引号\\\"括起来的任意文本\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_6-与\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_6-与\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 6. == 与 ===\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[a._v(\"==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；\")])]),a._v(\" \"),t(\"li\",[t(\"p\",[a._v(\"===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。\")])])]),a._v(\" \"),t(\"p\",[a._v(\"由于JavaScript这个设计缺陷，\"),t(\"strong\",[a._v(\"不要使用 == 比较，始终坚持使用 === 比较。\")])]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_7-注意浮点数的相等比较\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_7-注意浮点数的相等比较\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 7. 注意浮点数的相等比较\")]),a._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[a._v(\"1 / 3 === (1 - 2 / 3); // false\\n\")])])]),t(\"p\",[a._v(\"这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：\")]),a._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[a._v(\"Math.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001; // true\\n\")])])]),t(\"h2\",{attrs:{id:\"_8-大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_8-大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 8. 大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_9-对象\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_9-对象\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 9. 对象\")]),a._v(\" \"),t(\"p\",[a._v(\"JavaScript 的对象是一组由键-值组成的无序集合. 对象的键都是字符串类型，值可以是任意数据类型。\")]),a._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[a._v(\"var person = {\\n    name: 'Bob',\\n    age: 20,\\n    tags: ['js', 'web', 'mobile'],\\n    city: 'Beijing',\\n    hasCar: true,\\n    zipcode: null\\n};\\n\")])])]),t(\"h2\",{attrs:{id:\"_10-javascript-是动态类型语言\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_10-javascript-是动态类型语言\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 10. JavaScript 是动态类型语言\")]),a._v(\" \"),t(\"p\",[a._v(\"在 JavaScript 中，使用等号=对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用var申明一次。\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_11-如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_11-如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 11.如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_12-strict-模式：在strict模式下运行的javascript代码，强制通过var申明变量，未使用var申明变量就使用的，将导致运行错误。\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_12-strict-模式：在strict模式下运行的javascript代码，强制通过var申明变量，未使用var申明变量就使用的，将导致运行错误。\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 12. strict 模式：在strict模式下运行的JavaScript代码，强制通过var申明变量，未使用var申明变量就使用的，将导致运行错误。\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_13-启用strict模式的方法是在javascript代码的第一行写上：-use-strict\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_13-启用strict模式的方法是在javascript代码的第一行写上：-use-strict\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 13. 启用strict模式的方法是在JavaScript代码的第一行写上：'use strict';\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_14-如果字符串内部既包含-又包含-怎么办？可以用转义字符-来标识，比如：-i-m-ok\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_14-如果字符串内部既包含-又包含-怎么办？可以用转义字符-来标识，比如：-i-m-ok\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 14. 如果字符串内部既包含'又包含\\\"怎么办？可以用转义字符\\\\来标识，比如：'I'm \\\"OK\\\"!';\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_15-由于多行字符串用-n写起来比较费事，所以最新的es6标准新增了一种多行字符串的表示方法，用反引号-键盘上数字1左边的键-表示：\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_15-由于多行字符串用-n写起来比较费事，所以最新的es6标准新增了一种多行字符串的表示方法，用反引号-键盘上数字1左边的键-表示：\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 15. 由于多行字符串用\\\\n写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号 \"),t(\"code\"),a._v(\"(键盘上数字1左边的键) 表示：\")]),a._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[a._v(\"`这是一个\\n多行\\n字符串`;\\n\")])])]),t(\"h2\",{attrs:{id:\"_16-需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_16-需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 16. 需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果.\")]),a._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[a._v(\"var s = 'Test';\\ns[0] = 'X';\\nalert(s); // s仍然为'Test'\\n\")])])]),t(\"h2\",{attrs:{id:\"_17-javascript-为字符串提供了一些常用方法，注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_17-javascript-为字符串提供了一些常用方法，注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 17. JavaScript 为字符串提供了一些常用方法，注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串.\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_18-直接给-array-的-length-赋一个新的值会导致-array-大小的变化\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_18-直接给-array-的-length-赋一个新的值会导致-array-大小的变化\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 18. 直接给 Array 的 length 赋一个新的值会导致 Array 大小的变化\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_19-如果通过索引赋值时，索引超过了范围，同样会引起-array-大小的变化：\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_19-如果通过索引赋值时，索引超过了范围，同样会引起-array-大小的变化：\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 19. 如果通过索引赋值时，索引超过了范围，同样会引起 Array 大小的变化：\")]),a._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[a._v(\"var arr = [1, 2, 3];\\narr[5] = 'x';\\narr; // arr变为[1, 2, 3, undefined, undefined, 'x']\\n\")])])]),t(\"h2\",{attrs:{id:\"_20-如果不给-slice-传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个array：\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_20-如果不给-slice-传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个array：\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 20. 如果不给 slice() 传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array：\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_21-如果要往-array-的头部添加若干元素，使用-unshift-方法，shift-方法则把-array-的第一个元素删掉：\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_21-如果要往-array-的头部添加若干元素，使用-unshift-方法，shift-方法则把-array-的第一个元素删掉：\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 21. 如果要往 Array 的头部添加若干元素，使用 unshift() 方法，shift() 方法则把 Array 的第一个元素删掉：\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_22-push-向-array-的末尾添加若干元素，pop-则把array的最后一个元素删除掉：\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_22-push-向-array-的末尾添加若干元素，pop-则把array的最后一个元素删除掉：\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 22. push() 向 Array 的末尾添加若干元素，pop() 则把Array的最后一个元素删除掉：\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_23-splice-方法是修改array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_23-splice-方法是修改array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 23. splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：\")]),a._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[a._v(\"var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];\\n// 从索引2开始删除3个元素,然后再添加两个元素:\\narr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']\\narr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']\\n// 只删除,不添加:\\narr.splice(2, 2); // ['Google', 'Facebook']\\narr; // ['Microsoft', 'Apple', 'Oracle']\\n// 只添加,不删除:\\narr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素\\narr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']\\n\")])])]),t(\"h2\",{attrs:{id:\"_24-对象访问属性是通过-操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用-括起来\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_24-对象访问属性是通过-操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用-括起来\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 24. 对象访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用''括起来\")]),a._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[a._v(\"var xiaohong = {\\n    name: '小红',\\n    'middle-school': 'No.1 Middle School'\\n};\\n\")])])]),t(\"p\",[a._v(\"xiaohong的属性名middle-school不是一个有效的变量，就需要用''括起来。访问这个属性也无法使用.操作符，必须用['xxx']来访问：\")]),a._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[a._v(\"xiaohong['middle-school']; // 'No.1 Middle School'\\nxiaohong['name']; // '小红'\\nxiaohong.name; // '小红'\\n\")])])]),t(\"h2\",{attrs:{id:\"_25-如果我们要检测-xiaoming-对象是否拥有某一属性，可以用-in-操作符\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_25-如果我们要检测-xiaoming-对象是否拥有某一属性，可以用-in-操作符\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 25. 如果我们要检测 xiaoming 对象是否拥有某一属性，可以用 in 操作符\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_26-要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用-hasownproperty-方法\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_26-要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用-hasownproperty-方法\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 26. 要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用 hasOwnProperty() 方法\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_27-tostring定义在object对象中，而所有对象最终都会在原型链上指向object\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_27-tostring定义在object对象中，而所有对象最终都会在原型链上指向object\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 27. toString定义在object对象中，而所有对象最终都会在原型链上指向object\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_28-for-in-对-array-的循环得到的是-string-而不是其他\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_28-for-in-对-array-的循环得到的是-string-而不是其他\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 28. for ... in 对 Array 的循环得到的是 String 而不是其他\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_29-javascript-允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_29-javascript-允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 29. JavaScript 允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_30-利用-arguments，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_30-利用-arguments，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 30. 利用 arguments，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_31-为了获取除了已定义参数之外的参数引入了rest参数，rest参数只能写在最后，前面用-标识，从运行结果可知，传入的参数先绑定已定义参数，多余的参数以数组形式交给变量rest。\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_31-为了获取除了已定义参数之外的参数引入了rest参数，rest参数只能写在最后，前面用-标识，从运行结果可知，传入的参数先绑定已定义参数，多余的参数以数组形式交给变量rest。\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 31. 为了获取除了已定义参数之外的参数引入了rest参数，rest参数只能写在最后，前面用...标识，从运行结果可知，传入的参数先绑定已定义参数，多余的参数以数组形式交给变量rest。\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_32-如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是undefined）\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_32-如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是undefined）\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 32. 如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是undefined）\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_33-变量提升-javascript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：，即可以定义在后面，使用在前面。但是会被初始化为-undefined\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_33-变量提升-javascript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：，即可以定义在后面，使用在前面。但是会被初始化为-undefined\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 33. 变量提升 JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：，即可以\\b定义在后面，\\b使用在前面。但是会被初始化为 undefined\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_34-不在任何函数内定义的变量就具有全局作用域。实际上，javascript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性：\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_34-不在任何函数内定义的变量就具有全局作用域。实际上，javascript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性：\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 34. 不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性：\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_35-全局定义的函数跟变量一样也会绑定到window上，比如-alert-就是一个绑定到-window-上的全局函数。\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_35-全局定义的函数跟变量一样也会绑定到window上，比如-alert-就是一个绑定到-window-上的全局函数。\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 35. 全局定义的函数跟变量一样也会绑定到window上，比如 alert 就是一个\\b绑定到 window 上的全局函数。\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_36-javascript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报referenceerror错误。\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_36-javascript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报referenceerror错误。\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 36. JavaScript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误。\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_37-为了解决块级作用域，es6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_37-为了解决块级作用域，es6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 37. 为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_38-es6标准引入了新的关键字const来定义常量，const与let都具有块级作用域\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_38-es6标准引入了新的关键字const来定义常量，const与let都具有块级作用域\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 38. ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_39-解构赋值\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_39-解构赋值\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 39. 解构赋值\")]),a._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[a._v(\"var [x, y, z] = ['hello', 'JavaScript', 'ES6'];\\n\\nlet [x, [y, z]] = ['hello', ['JavaScript', 'ES6']];\\n\\nlet [, , z] = ['hello', 'JavaScript', 'ES6']; // 忽略前两个元素，只对z赋值第三个元素\\n\\nvar person = {\\n    name: '小明',\\n    age: 20,\\n    gender: 'male',\\n    passport: 'G-12345678',\\n    school: 'No.4 middle school'\\n};\\nvar {name, age, passport} = person; // name, age, passport分别被赋值为对应属性:\\n\\nvar person = {\\n    name: '小明',\\n    age: 20,\\n    gender: 'male',\\n    passport: 'G-12345678',\\n    school: 'No.4 middle school',\\n    address: {\\n        city: 'Beijing',\\n        street: 'No.1 Road',\\n        zipcode: '100001'\\n    }\\n};\\nvar {name, address: {city, zip}} = person;\\nname; // '小明'\\ncity; // 'Beijing'\\nzip; // undefined, 因为属性名是zipcode而不是zip\\n// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:\\naddress; // Uncaught ReferenceError: address is not defined\\n\\n// 使用解构赋值对对象属性进行赋值时，如果对应的属性不存在，变量将被赋值为undefined，这和引用一个不存在的属性获得undefined是一致的。如果要使用的变量名和属性名不一致，可以用下面的语法获取：\\nvar person = {\\n    name: '小明',\\n    age: 20,\\n    gender: 'male',\\n    passport: 'G-12345678',\\n    school: 'No.4 middle school'\\n};\\n\\n// 把passport属性赋值给变量id:\\nlet {name, passport:id} = person;\\nname; // '小明'\\nid; // 'G-12345678'\\n// 注意: passport不是变量，而是为了让变量id获得passport属性:\\npassport; // Uncaught ReferenceError: passport is not defined\\n\\n\\nvar person = {\\n    name: '小明',\\n    age: 20,\\n    gender: 'male',\\n    passport: 'G-12345678'\\n};\\n\\n// 如果person对象没有single属性，默认赋值为true:\\nvar {name, single=true} = person;\\nname; // '小明'\\nsingle; // true\\n\")])])]),t(\"h2\",{attrs:{id:\"_40-有些时候，如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误：\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_40-有些时候，如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误：\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 40. 有些时候，如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误：\")]),a._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[a._v(\"// 声明变量:\\nvar x, y;\\n// 解构赋值:\\n{x, y} = { name: '小明', x: 100, y: 200};\\n// 语法错误: Uncaught SyntaxError: Unexpected token =\\n\")])])]),t(\"p\",[a._v(\"这是因为JavaScript引擎把{开头的语句当作了块处理，于是=不再合法。解决方法是用小括号括起来：\")]),a._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[a._v(\"({x, y} = { name: '小明', x: 100, y: 200}); \\n\")])])]),t(\"h2\",{attrs:{id:\"_41-javascript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_41-javascript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 41. JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。\")]),a._v(\" \"),t(\"p\",[a._v(\"现在假定我们想统计一下代码一共调用了多少次parseInt()，可以把所有的调用都找出来，然后手动加上count += 1，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的parseInt()：\")]),a._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[a._v(\"'use strict';\\n\\nvar count = 0;\\nvar oldParseInt = parseInt; // 保存原函数\\n\\nwindow.parseInt = function () {\\n    count += 1;\\n    return oldParseInt.apply(null, arguments); // 调用原函数\\n};\\n\")])])]),t(\"h2\",{attrs:{id:\"_42\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_42\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 42.\")])])},[],!1,null,null,null);r.default=s.exports}}]);","extractedComments":[]}