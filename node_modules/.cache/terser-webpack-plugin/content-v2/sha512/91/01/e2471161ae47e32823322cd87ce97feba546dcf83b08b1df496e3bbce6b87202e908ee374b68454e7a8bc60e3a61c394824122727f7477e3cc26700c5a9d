{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{440:function(a,t,e){\"use strict\";e.r(t);var r=e(0),i=Object(r.a)({},function(){var a=this,t=a.$createElement,e=a._self._c||t;return e(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":a.$parent.slotKey}},[e(\"h1\",{attrs:{id:\"队列\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#队列\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 队列\")]),a._v(\" \"),e(\"h2\",{attrs:{id:\"_09-队列\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_09-队列\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 09 队列\")]),a._v(\" \"),e(\"h3\",{attrs:{id:\"定义\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#定义\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 定义\")]),a._v(\" \"),e(\"ul\",[e(\"li\",[a._v(\"先进先出的就是队列\")]),a._v(\" \"),e(\"li\",[a._v(\"与栈一样也是一个操作受限的线性表数据额结构：队列头部取数据（enqueue），队列尾部插入数据（dequeue）\")])]),a._v(\" \"),e(\"h3\",{attrs:{id:\"实现\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#实现\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 实现\")]),a._v(\" \"),e(\"ul\",[e(\"li\",[a._v(\"用数组实现的队列叫作顺序队列\")]),a._v(\" \"),e(\"li\",[a._v(\"用链表实现的队列叫作链式队列\")]),a._v(\" \"),e(\"li\",[a._v(\"为了避免顺序队列的数据搬移，有了循环队列的解决思路\")])]),a._v(\" \"),e(\"h3\",{attrs:{id:\"循环队列\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#循环队列\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 循环队列\")]),a._v(\" \"),e(\"p\",[a._v(\"当顺序队列的数组空间用完之后（tail 等于数组的大小），新插入的数据插入到数组头部。这样就避免了数据迁移。\")]),a._v(\" \"),e(\"p\",[a._v(\"循环队列的实现关键是 \"),e(\"strong\",[a._v(\"确定队空和队满的判断\")])]),a._v(\" \"),e(\"ul\",[e(\"li\",[a._v(\"队空：head 等于 tail\")]),a._v(\" \"),e(\"li\",[a._v(\"队满：（tail + 1）%  n == head\")])]),a._v(\" \"),e(\"p\",[a._v(\"表达式是怎么来的：在一般情况下，我们可以看出来，当队列满时，tail+1=head。但是，有个特殊情况，就是tail=n-1，而head=0时，这时候，tail+1=n，而head=0，所以用(tail+1)%n == n%n == 0。而且，tail+1最大的情况就是 n ，不会大于 n，这样，tail+1 除了最大情况，不然怎么余 n 都是 tail+1 本身，也就是 head。这样，表达式就出现了。\")]),a._v(\" \"),e(\"h3\",{attrs:{id:\"阻塞队列和并发队列\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#阻塞队列和并发队列\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 阻塞队列和并发队列\")]),a._v(\" \"),e(\"ul\",[e(\"li\",[a._v(\"阻塞队列：在队列基础上增加了阻塞操作。队列为空的时候从堆头取数据被阻塞，队列满了之后插入数据被阻塞\")]),a._v(\" \"),e(\"li\",[a._v(\"并发队列：能保证多线程并发操作时线程安全的队列称为并发队列\")])]),a._v(\" \"),e(\"h3\",{attrs:{id:\"应用\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#应用\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 应用\")]),a._v(\" \"),e(\"p\",[a._v(\"对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。\")]),a._v(\" \"),e(\"h3\",{attrs:{id:\"无锁并发队列\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#无锁并发队列\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 无锁并发队列\")]),a._v(\" \"),e(\"p\",[a._v(\"考虑使用CAS实现无锁队列。在入队前，获取tail位置，入队时比较tail是否发生变化，如果否，则允许入队，反之，本次入队失败。出队则是获取head位置，进行cas。\")]),a._v(\" \"),e(\"blockquote\",[e(\"p\",[a._v('CAS操作——Compare & Set，或是 Compare & Swap 现在几乎所有的CPU指令都支持CAS的原子操作。\\n\"原子操作(atomic operation)是不需要synchronized\"，这是多线程编程的老生常谈了。 所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何context switch （切 换到另一个线程）。')])])])},[],!1,null,null,null);t.default=i.exports}}]);","extractedComments":[]}