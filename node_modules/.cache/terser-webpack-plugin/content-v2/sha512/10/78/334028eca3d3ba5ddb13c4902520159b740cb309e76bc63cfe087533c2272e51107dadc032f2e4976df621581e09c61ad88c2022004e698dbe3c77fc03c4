{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{245:function(t,e,n){t.exports=n.p+\"assets/img/lock_1.7b418a64.png\"},246:function(t,e,n){t.exports=n.p+\"assets/img/lock_2.37d64ae7.png\"},247:function(t,e,n){t.exports=n.p+\"assets/img/lock_3.06c86ccb.png\"},439:function(t,e,n){\"use strict\";n.r(e);var o=n(0),a=Object(o.a)({},function(){var t=this,e=t.$createElement,o=t._self._c||e;return o(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[o(\"h1\",{attrs:{id:\"ios中的锁\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#ios中的锁\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" iOS中的锁\")]),t._v(\" \"),o(\"p\",[t._v(\"开发中利用多线程来编程的时候往往会遇到线程安全的问题，这个时候就需要利用到锁。\\n锁大致可以分为三类\"),o(\"strong\",[t._v(\"信号量\")]),t._v(\"、\"),o(\"strong\",[t._v(\"互斥体\")]),t._v(\"和\"),o(\"strong\",[t._v(\"自旋锁\")]),t._v(\"。具体的区别可以看 \"),o(\"a\",{attrs:{href:\"http://www.cnblogs.com/biyeymyhjob/archive/2012/07/21/2602015.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"信号量、互斥体和自旋锁\"),o(\"OutboundLink\")],1)]),t._v(\" \"),o(\"p\",[t._v(\"在iOS中 \"),o(\"code\",[t._v(\"pthread_mutex\")]),t._v(\" 是互斥锁。可以传入不同参数，实现递归锁 \"),o(\"code\",[t._v(\"pthread_mutex(recursive)\")]),t._v(\"。\"),o(\"code\",[t._v(\"NSLock\")]),t._v(\"，\"),o(\"code\",[t._v(\"NSCondition\")]),t._v(\"，\"),o(\"code\",[t._v(\"NSRecursiveLock\")]),t._v(\"，\"),o(\"code\",[t._v(\"NSConditionLock\")]),t._v(\"都是内部封装的pthread_mutex，都属于互斥锁。@synchronized 是 NSLock 的一种封装，牺牲了效率，简洁了语法。\"),o(\"code\",[t._v(\"OSSpinLock\")]),t._v(\" 是自旋锁，效率较高，但是由于现在的iOS因为优先级反转的问题，已经不安全。\")]),t._v(\" \"),o(\"h2\",{attrs:{id:\"互斥锁与自旋锁\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#互斥锁与自旋锁\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 互斥锁与自旋锁\")]),t._v(\" \"),o(\"h3\",{attrs:{id:\"原理简介\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#原理简介\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 原理简介\")]),t._v(\" \"),o(\"ul\",[o(\"li\",[o(\"p\",[o(\"strong\",[t._v(\"自旋锁会忙等\")]),t._v(\": 所谓忙等，即在访问被锁资源时，调用者线程不会休眠，而是不停循环在那里，直到被锁资源释放锁。\")])]),t._v(\" \"),o(\"li\",[o(\"p\",[o(\"strong\",[t._v(\"互斥锁会休眠\")]),t._v(\": 所谓休眠，即在访问被锁资源时，调用者线程会休眠，此时cpu可以调度其他线程工作。直到被锁资源释放锁。此时会唤醒休眠线程。\")])])]),t._v(\" \"),o(\"h3\",{attrs:{id:\"优缺点：\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#优缺点：\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 优缺点：\")]),t._v(\" \"),o(\"p\",[t._v(\"自旋锁的优点在于，因为自旋锁不会引起调用者睡眠，所以不会进行线程调度，cpu时间片轮转等耗时操作。所有如果能在很短的时间内获得锁，自旋锁的效率远高于互斥锁。\")]),t._v(\" \"),o(\"p\",[t._v(\"缺点在于，自旋锁一直占用CPU，他在未获得锁的情况下，一直运行－－自旋，所以占用着CPU，如果不能在很短的时 间内获得锁，这无疑会使CPU效率降低。自旋锁不能实现递归调用。\")]),t._v(\" \"),o(\"h2\",{attrs:{id:\"dispatch-semaphore\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#dispatch-semaphore\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" dispatch_semaphore\")]),t._v(\" \"),o(\"p\",[t._v(\"这是 GCD 提供的一个加锁的方式，更多的称之为信号量。大致可以把信号量理解为进入一个大门的钥匙，比如一个大门有三把钥匙，这时候进去一个人并拿走一个钥匙，等到钥匙被全被拿走的时候就没有人能进入了，必须等里面的人出来后把钥匙挂门口之后别的人才能进去。\")]),t._v(\" \"),o(\"p\",[t._v(\"三个相关函数：\")]),t._v(\" \"),o(\"h4\",{attrs:{id:\"_1-dispatch-semaphore-create-long-value\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-dispatch-semaphore-create-long-value\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 1.\"),o(\"code\",[t._v(\"dispatch_semaphore_create(long value);\")])]),t._v(\" \"),o(\"p\",[t._v(\"生成信号量，参数value是信号量计数的初始值。\")]),t._v(\" \"),o(\"p\",[o(\"strong\",[t._v(\"注意\")]),t._v(\" value 必须\"),o(\"strong\",[t._v(\"大于等于\")]),t._v(\" 0 否则函数就会返回 NULL。\")]),t._v(\" \"),o(\"p\",[t._v(\"这一步相当于声明这个门有几把钥匙。\")]),t._v(\" \"),o(\"h4\",{attrs:{id:\"_2-dispatch-semaphore-wait-dispatch-semaphore-t-dsema-dispatch-time-t-timeout\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-dispatch-semaphore-wait-dispatch-semaphore-t-dsema-dispatch-time-t-timeout\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 2.\"),o(\"code\",[t._v(\"dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);\")])]),t._v(\" \"),o(\"p\",[t._v(\"这个函数会将信号量值减一，如果大于等于0就立即返回，否则等待信号量唤醒或者超时（注意 timeout 的类型为 \"),o(\"code\",[t._v(\"dispatch_time_t\")]),t._v(\"，不能直接传入整形或 float 型数），如果等待的期间 desema 的值被\"),o(\"code\",[t._v(\"dispatch_semaphore_signal\")]),t._v(\"函数加1了，且该函数（即\"),o(\"code\",[t._v(\"dispatch_semaphore_wait\")]),t._v(\"）所处线程获得了信号量，那么就继续向下执行并将信号量减1。如果等待期间没有获取到信号量或者信号量的值一直为0，那么等到 timeout 时，其所处线程自动执行其后语句。\")]),t._v(\" \"),o(\"p\",[o(\"img\",{attrs:{src:n(245),alt:\"\"}})]),t._v(\" \"),o(\"p\",[t._v(\"这一步相当于有钥匙的时候拿走一把钥匙，没有钥匙的时候就要一直等待，并且如果超时时间到了的话会直接进入大门。\")]),t._v(\" \"),o(\"h4\",{attrs:{id:\"_3-dispatch-semaphore-signal-dispatch-semaphore-t-dsema\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-dispatch-semaphore-signal-dispatch-semaphore-t-dsema\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 3.\"),o(\"code\",[t._v(\"dispatch_semaphore_signal(dispatch_semaphore_t dsema);\")])]),t._v(\" \"),o(\"p\",[t._v(\"会将信号量值加一，如果value大于0立即返回，否则唤醒某个等待中的线程。\\n\"),o(\"img\",{attrs:{src:n(246),alt:\"\"}})]),t._v(\" \"),o(\"p\",[t._v(\"这一步相当于返还钥匙。\")]),t._v(\" \"),o(\"p\",[t._v(\"具体用法可以参考我的另外一个 \"),o(\"router-link\",{attrs:{to:\"/articles/GCD.html\"}},[t._v(\"GCD\")]),t._v(\" 相关的文章，更多原理方面可以看 \"),o(\"a\",{attrs:{href:\"http://cocoa-chen.github.io/2018/03/08/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAGCD%E4%B9%8Bdispatch_semaphore/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"深入浅出GCD之dispatch_semaphore\"),o(\"OutboundLink\")],1),t._v(\"。\")],1),t._v(\" \"),o(\"h2\",{attrs:{id:\"synchronized\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#synchronized\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" @synchronized\")]),t._v(\" \"),o(\"p\",[t._v(\"这个是我们常见的，也是用起来比较方便的一个锁。比如下面这个例子。\")]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v('\\tNSObject *obj = [[NSObject alloc] init];\\n    \\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\\n        @synchronized(obj) {\\n            NSLog(@\"需要线程同步的操作1 开始\");\\n            sleep(3);\\n            NSLog(@\"需要线程同步的操作1 结束\");\\n        }\\n    });\\n    \\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\\n        sleep(1);\\n        @synchronized(obj) {\\n            NSLog(@\"需要线程同步的操作2\");\\n        }\\n    });\\n    \\n2016-06-29 20:48:35.747 SafeMultiThread[35945:580107] 需要线程同步的操作1 开始\\n2016-06-29 20:48:38.748 SafeMultiThread[35945:580107] 需要线程同步的操作1 结束\\n2016-06-29 20:48:38.749 SafeMultiThread[35945:580118] 需要线程同步的操作2\\n\\n')])])]),o(\"p\",[o(\"code\",[t._v(\"@synchronized\")]),t._v(\"是 OC 层面的锁，它的后面需要紧跟一个 OC 对象，使用该对象为该锁的唯一标识，只有当标识相同时，才满足互斥，所以如果线程 2 中的 \"),o(\"code\",[t._v(\"@synchronized(obj)\")]),t._v(\" 改为其他的对象，则线程2就不会被阻塞，\"),o(\"code\",[t._v(\"@synchronized\")]),t._v(\" 指令实现锁的优点就是我们不需要在代码中显式的创建锁对象，便可以实现锁的机制，但作为一种预防措施，\"),o(\"code\",[t._v(\"@synchronized\")]),t._v(\" 块会隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁。\"),o(\"code\",[t._v(\"@synchronized\")]),t._v(\" 还有一个好处就是不用担心忘记解锁了。\")]),t._v(\" \"),o(\"p\",[t._v(\"如果在 \"),o(\"code\",[t._v(\"@sychronized(object){}\")]),t._v(\" 内部 object 被释放或被设为 nil，但如果 object 一开始就是 nil，则失去了锁的功能。不过虽然 nil 不行，但 \"),o(\"code\",[t._v(\"@synchronized([NSNull null])\")]),t._v(\" 是完全可以的。\")]),t._v(\" \"),o(\"p\",[t._v(\"更多相关内容可以看\"),o(\"a\",{attrs:{href:\"http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"这里\"),o(\"OutboundLink\")],1)]),t._v(\" \"),o(\"h2\",{attrs:{id:\"pthread-mutex\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#pthread-mutex\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" pthread_mutex\")]),t._v(\" \"),o(\"p\",[t._v(\"pthread 表示 POSIX thread，定义了一组跨平台的线程相关的 API，pthread_mutex 表示互斥锁。互斥锁的实现原理与信号量非常相似，不是使用忙等，而是阻塞线程并睡眠，需要进行上下文切换。\")]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v(\"pthread_mutexattr_t attr;\\npthread_mutexattr_init(&attr);\\npthread_mutexattr_settype(&attr, PTHREAD_MUTEX_NORMAL);  // 定义锁的属性\\n\\npthread_mutex_t mutex;\\npthread_mutex_init(&mutex, &attr) // 创建锁\\n\\npthread_mutex_lock(&mutex); // 申请锁\\n    // 临界区\\npthread_mutex_unlock(&mutex); // 释放锁\\n\")])])]),o(\"p\",[t._v(\"一般情况下，一个线程只能申请一次锁，也只能在获得锁的情况下才能释放锁，多次申请锁或释放未获得的锁都会导致崩溃。假设在已经获得锁的情况下再次申请锁，线程会因为等待锁的释放而进入睡眠状态，因此就不可能再释放锁，从而导致死锁。\")]),t._v(\" \"),o(\"p\",[t._v(\"然而这种情况经常会发生，比如某个函数申请了锁，在临界区内又递归调用了自己。辛运的是 pthread_mutex 支持递归锁，也就是允许一个线程递归的申请锁，只要把 attr 的类型改成 \"),o(\"code\",[t._v(\"PTHREAD_MUTEX_RECURSIVE\")]),t._v(\" 即可。\")]),t._v(\" \"),o(\"h2\",{attrs:{id:\"nslocking\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#nslocking\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" NSLocking\")]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v(\"@protocol NSLocking\\n\\n- (void)lock;\\n- (void)unlock;\\n\\n@end\\n\\n\")])])]),o(\"p\",[t._v(\"首先是 \"),o(\"code\",[t._v(\"NSLocking\")]),t._v(\" 协议，实现这个协议的有 \"),o(\"code\",[t._v(\"NSLock\")]),t._v(\" \"),o(\"code\",[t._v(\"NSConditionLock\")]),t._v(\" \"),o(\"code\",[t._v(\"NSRecursiveLock\")]),t._v(\" \"),o(\"code\",[t._v(\"NSCondition\")]),t._v(\"。可以把他们看出是一个系列的。这些都是在内部封装了一个 pthread_mutex，区别仅仅是内部 pthread_mutex 互斥锁的类型不同。它的实现非常简单，通过宏，定义了 lock 方法。而通过宏定义，可以简化方法的定义。下面来一个一个介绍。\")]),t._v(\" \"),o(\"h2\",{attrs:{id:\"nslock\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#nslock\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" NSLock\")]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v('\\tNSLock *lock = [[NSLock alloc] init];\\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\\n        //[lock lock];\\n        [lock lockBeforeDate:[NSDate date]];\\n            NSLog(@\"需要线程同步的操作1 开始\");\\n            sleep(2);\\n            NSLog(@\"需要线程同步的操作1 结束\");\\n        [lock unlock];\\n        \\n    });\\n    \\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\\n        sleep(1);\\n        if ([lock tryLock]) {//尝试获取锁，如果获取不到返回NO，不会阻塞该线程\\n            NSLog(@\"锁可用的操作\");\\n            [lock unlock];\\n        }else{\\n            NSLog(@\"锁不可用的操作\");\\n        }\\n        \\n        NSDate *date = [[NSDate alloc] initWithTimeIntervalSinceNow:3];\\n        if ([lock lockBeforeDate:date]) {//尝试在未来的3s内获取锁，并阻塞该线程，如果3s内获取不到恢复线程, 返回NO,不会阻塞该线程\\n            NSLog(@\"没有超时，获得锁\");\\n            [lock unlock];\\n        }else{\\n            NSLog(@\"超时，没有获得锁\");\\n        }\\n        \\n    });\\n\\n')])])]),o(\"p\",[t._v(\"tryLock 和 lockBeforeDate :两个方法，前一个方法会尝试加锁，如果锁不可用(已经被锁住)，刚并不会阻塞线程，并返回 NO。 lockBeforeDate: 方法会在所指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回 NO。\")]),t._v(\" \"),o(\"h2\",{attrs:{id:\"nsconditionlock\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#nsconditionlock\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" NSConditionLock\")]),t._v(\" \"),o(\"p\",[t._v(\"NSConditionLock 和 NSLock 类似，都遵循 NSLocking 协议，方法都类似，只是多了一个 condition 属性，以及每个操作都多了一个关于 condition 属性的方法，例如 tryLock，tryLockWhenCondition:，NSConditionLock 可以称为条件锁，只有 condition 参数与初始化时候的 condition 相等，lock 才能正确进行加锁操作。而 unlockWithCondition: 并不是当 Condition 符合条件时才解锁，而是解锁之后，修改 Condition 的值，这个结论可以从下面的例子中得出。\")]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v('//主线程中\\n    NSConditionLock *lock = [[NSConditionLock alloc] initWithCondition:0];\\n    \\n    //线程1\\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\\n        [lock lockWhenCondition:1];\\n        NSLog(@\"线程1\");\\n        sleep(2);\\n        [lock unlock];\\n    });\\n    \\n    //线程2\\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\\n        sleep(1);//以保证让线程2的代码后执行\\n        if ([lock tryLockWhenCondition:0]) {\\n            NSLog(@\"线程2\");\\n            [lock unlockWithCondition:2];\\n            NSLog(@\"线程2解锁成功\");\\n        } else {\\n            NSLog(@\"线程2尝试加锁失败\");\\n        }\\n    });\\n    \\n    //线程3\\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\\n        sleep(2);//以保证让线程2的代码后执行\\n        if ([lock tryLockWhenCondition:2]) {\\n            NSLog(@\"线程3\");\\n            [lock unlock];\\n            NSLog(@\"线程3解锁成功\");\\n        } else {\\n            NSLog(@\"线程3尝试加锁失败\");\\n        }\\n    });\\n    \\n    //线程4\\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\\n        sleep(3);//以保证让线程2的代码后执行\\n        if ([lock tryLockWhenCondition:2]) {\\n            NSLog(@\"线程4\");\\n            [lock unlockWithCondition:1];    \\n            NSLog(@\"线程4解锁成功\");\\n        } else {\\n            NSLog(@\"线程4尝试加锁失败\");\\n        }\\n    });\\n    \\n2016-08-19 13:51:15.353 ThreadLockControlDemo[1614:110697] 线程2\\n2016-08-19 13:51:15.354 ThreadLockControlDemo[1614:110697] 线程2解锁成功\\n2016-08-19 13:51:16.353 ThreadLockControlDemo[1614:110689] 线程3\\n2016-08-19 13:51:16.353 ThreadLockControlDemo[1614:110689] 线程3解锁成功\\n2016-08-19 13:51:17.354 ThreadLockControlDemo[1614:110884] 线程4\\n2016-08-19 13:51:17.355 ThreadLockControlDemo[1614:110884] 线程4解锁成功\\n2016-08-19 13:51:17.355 ThreadLockControlDemo[1614:110884] 线程1\\n\\n')])])]),o(\"p\",[t._v(\"上面代码先输出了 ”线程 2“，因为线程 1 的加锁条件不满足，初始化时候的 condition 参数为 0，而加锁条件是 condition 为 1，所以加锁失败。locakWhenCondition 与 lock 方法类似，加锁失败会阻塞线程，所以线程 1 会被阻塞着，而 tryLockWhenCondition 方法就算条件不满足，也会返回 NO，不会阻塞当前线程。\")]),t._v(\" \"),o(\"p\",[t._v(\"回到上面的代码，线程 2 执行了 [lock unlockWithCondition:2]; 所以 Condition 被修改成了 2。\")]),t._v(\" \"),o(\"p\",[t._v(\"而线程 3 的加锁条件是 Condition 为 2， 所以线程 3 才能加锁成功，线程 3 执行了 [lock unlock]; 解锁成功且不改变 Condition 值。\")]),t._v(\" \"),o(\"p\",[t._v(\"线程 4 的条件也是 2，所以也加锁成功，解锁时将 Condition 改成 1。这个时候线程 1 终于可以加锁成功，解除了阻塞。\")]),t._v(\" \"),o(\"p\",[t._v(\"从上面可以得出，NSConditionLock 还可以实现任务之间的依赖。\")]),t._v(\" \"),o(\"h2\",{attrs:{id:\"nsrecursivelock\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#nsrecursivelock\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" NSRecursiveLock\")]),t._v(\" \"),o(\"p\",[t._v(\"NSRecursiveLock 是递归锁，他和 NSLock 的区别在于，NSRecursiveLock 可以在一个线程中重复加锁，NSRecursiveLock 会记录上锁和解锁的次数，当二者平衡的时候，才会释放锁，其它线程才可以上锁成功。\")]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v('NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];\\n    \\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\\n        \\n        static void (^RecursiveBlock)(int);\\n        RecursiveBlock = ^(int value) {\\n            [lock lock];\\n            if (value > 0) {\\n                NSLog(@\"value:%d\", value);\\n                RecursiveBlock(value - 1);\\n            }\\n            [lock unlock];\\n        };\\n        RecursiveBlock(2);\\n    });\\n\\n2016-08-19 14:43:12.327 ThreadLockControlDemo[1878:145003] value:2\\n2016-08-19 14:43:12.327 ThreadLockControlDemo[1878:145003] value:1\\n\\n')])])]),o(\"p\",[t._v(\"如上面的示例，如果用 NSLock 的话，lock 先锁上了，但未执行解锁的时候，就会进入递归的下一层，而再次请求上锁，阻塞了该线程，线程被阻塞了，自然后面的解锁代码不会执行，而形成了死锁。而 NSRecursiveLock 递归锁就是为了解决这个问题。\")]),t._v(\" \"),o(\"h2\",{attrs:{id:\"nscondition\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#nscondition\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" NSCondition\")]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v('NSCondition *condition = [[NSCondition alloc] init];\\n    \\n    NSMutableArray *products = [NSMutableArray array];\\n    \\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\\n        while (1) {\\n            [condition lock];\\n            if ([products count] == 0) {\\n                NSLog(@\"wait for product\");\\n                [condition wait];\\n            }\\n            [products removeObjectAtIndex:0];\\n            NSLog(@\"custome a product\");\\n            [condition unlock];\\n        }\\n\\n    });\\n    \\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\\n        while (1) {\\n            [condition lock];\\n            [products addObject:[[NSObject alloc] init]];\\n            NSLog(@\"produce a product,总量:%zi\",products.count);\\n            [condition signal];\\n            [condition unlock];\\n            sleep(1);\\n        }\\n\\n    });\\n\\n')])])]),o(\"p\",[t._v(\"一种最基本的条件锁。手动控制线程wait和signal。\")]),t._v(\" \"),o(\"p\",[t._v(\"[condition lock];一般用于多线程同时访问、修改同一个数据源，保证在同一时间内数据源只被访问、修改一次，其他线程的命令需要在lock 外等待，只到unlock ，才可访问\")]),t._v(\" \"),o(\"p\",[t._v(\"[condition unlock];与lock 同时使用\")]),t._v(\" \"),o(\"p\",[t._v(\"[condition wait];让当前线程处于等待状态\")]),t._v(\" \"),o(\"p\",[t._v(\"[condition signal];CPU发信号告诉线程不用在等待，可以继续执行\")]),t._v(\" \"),o(\"h2\",{attrs:{id:\"osspinlock\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#osspinlock\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" OSSpinLock\")]),t._v(\" \"),o(\"p\",[t._v(\"OSSpinLock 表示自旋锁，效率最高，但是现在的iOS因为优先级反转的问题，已经不安全。\")]),t._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[t._v('__block OSSpinLock theLock = OS_SPINLOCK_INIT;\\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\\n    OSSpinLockLock(&theLock);\\n    NSLog(@\"需要线程同步的操作1 开始\");\\n    sleep(3);\\n    NSLog(@\"需要线程同步的操作1 结束\");\\n    OSSpinLockUnlock(&theLock);\\n    \\n});\\n\\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\\n    OSSpinLockLock(&theLock);\\n    sleep(1);\\n    NSLog(@\"需要线程同步的操作2\");\\n    OSSpinLockUnlock(&theLock);\\n    \\n});\\n\\n')])])]),o(\"h2\",{attrs:{id:\"性能\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#性能\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 性能\")]),t._v(\" \"),o(\"p\",[t._v(\"参考Y神的图\\n\"),o(\"img\",{attrs:{src:n(247),alt:\"\"}})]),t._v(\" \"),o(\"h2\",{attrs:{id:\"参考\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#参考\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 参考\")]),t._v(\" \"),o(\"ol\",{attrs:{start:\"0\"}},[o(\"li\",[o(\"a\",{attrs:{href:\"http://www.cnblogs.com/biyeymyhjob/archive/2012/07/21/2602015.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"信号量、互斥体和自旋锁\"),o(\"OutboundLink\")],1)]),t._v(\" \"),o(\"li\",[o(\"a\",{attrs:{href:\"https://github.com/bestswifter/blog/blob/master/articles/ios-lock.md\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"深入理解 iOS 开发中的锁\"),o(\"OutboundLink\")],1)]),t._v(\" \"),o(\"li\",[o(\"a\",{attrs:{href:\"https://www.jianshu.com/p/938d68ed832c\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"iOS中保证线程安全的几种方式与性能对比\"),o(\"OutboundLink\")],1)]),t._v(\" \"),o(\"li\",[o(\"a\",{attrs:{href:\"https://www.jianshu.com/p/ddbe44064ca4\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"iOS 常见知识点（三）：Lock\"),o(\"OutboundLink\")],1)]),t._v(\" \"),o(\"li\",[o(\"a\",{attrs:{href:\"https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"不再安全的 OSSpinLock\"),o(\"OutboundLink\")],1)]),t._v(\" \"),o(\"li\",[o(\"a\",{attrs:{href:\"https://www.jianshu.com/p/d69495dac8cb\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"iOS中自旋锁与互斥锁的区别\"),o(\"OutboundLink\")],1)]),t._v(\" \"),o(\"li\",[o(\"a\",{attrs:{href:\"http://cocoa-chen.github.io/2018/03/08/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAGCD%E4%B9%8Bdispatch_semaphore/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"深入浅出GCD之dispatch_semaphore\"),o(\"OutboundLink\")],1)])])])},[],!1,null,null,null);e.default=a.exports}}]);","extractedComments":[]}