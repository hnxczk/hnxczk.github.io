{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{317:function(t,n,e){t.exports=e.p+\"assets/img/obj-2.b5141953.png\"},318:function(t,n,e){t.exports=e.p+\"assets/img/obj-3.f5ea97a6.png\"},319:function(t,n,e){t.exports=e.p+\"assets/img/obj-4.a4144a76.png\"},320:function(t,n,e){t.exports=e.p+\"assets/img/obj-5.4aa546fe.png\"},412:function(t,n,e){\"use strict\";e.r(n);var a=e(0),o=Object(a.a)({},function(){var t=this,n=t.$createElement,a=t._self._c||n;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"对象\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#对象\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 对象\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"基于类和基于原型\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#基于类和基于原型\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 基于类和基于原型\")]),t._v(\" \"),a(\"p\",[t._v(\"我们都知道 JavaScript 是一个面向对象的语言，但是它却没有其他诸如 Java、C++ 这些面向对象的语言中都存在\"),a(\"strong\",[t._v(\"类\")]),t._v(\"的这个概念。取而代之的是\"),a(\"strong\",[t._v(\"原型\")]),t._v(\"的概念。这其实就是两种不同的编程范式。\")]),t._v(\" \"),a(\"ol\",[a(\"li\",[a(\"p\",[t._v(\"基于类的面向对象\")]),t._v(\" \"),a(\"p\",[t._v(\"在这种范式中，类定义了对象的结构和行为以及继承关系，所有基于该类的对象都有\"),a(\"strong\",[t._v(\"相同\")]),t._v(\"的行为和结构，不同的只是他们的状态。\")]),t._v(\" \"),a(\"p\",[t._v(\"创建新的对象通过类的构造器来创建。只有少数基于类的面向对象语言允许类在运行时进行修改。\")])]),t._v(\" \"),a(\"li\",[a(\"p\",[t._v(\"基于原型的面向对象\")]),t._v(\" \"),a(\"p\",[t._v(\"在这种范式中，关注的是一系列对象的行为，将拥有\"),a(\"strong\",[t._v(\"相似\")]),t._v(\"行为的对象通过原型链串联起来。\")]),t._v(\" \"),a(\"p\",[t._v(\"创建新的对象通过拓展原有对象创建。很多的基于原型的语言提倡运行时对原型进行修改。\")])])]),t._v(\" \"),a(\"p\",[t._v(\"我们可以看出来基于原型相对来说更加灵活。这也许是 JavaScript 选择基于原型构建面向对象的原因之一吧。\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"对象：无序属性的集合\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#对象：无序属性的集合\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 对象：无序属性的集合\")]),t._v(\" \"),a(\"p\",[t._v(\"ECMA262 把对象定义为：无序属性的集合，其属性可以包含基本值、对象或者函数。\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"var obj = {\\n    a: 5,\\n    b: function() {},\\n    c:{ d: 10 }\\n}\\n\")])])]),a(\"p\",[t._v(\"在上面这段代码中 基本类型 a，函数 b，对象 c 都是对象 obj 的属性。\")]),t._v(\" \"),a(\"p\",[t._v(\"实际上 JavaScript 中函数也可以添加属性。\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"var fun = function(){}\\nfun.a = 5\\nfun.b = function() {}\\nfun.c = { d: 10 }\\n\")])])]),a(\"p\",[t._v(\"因此我们可以推断出来函数也是属性的集合，它也是对象。\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"函数对象和普通对象\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#函数对象和普通对象\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 函数对象和普通对象\")]),t._v(\" \"),a(\"p\",[t._v(\"我们先看下面的代码。\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v('typeof obj // \"object\"\\ntypeof fun // \"function\"\\n\\nobj instanceof Object // true\\nfun instanceof Object // true\\n')])])]),a(\"p\",[t._v(\"我们可以得出以下结论：\")]),t._v(\" \"),a(\"ol\",[a(\"li\",[t._v(\"通过 instanceof 的结果我们确认了函数也是对象；\")]),t._v(\" \"),a(\"li\",[t._v(\"通过 typeof 的结果我们了解了函数与普通对象是有区别的。\")])]),t._v(\" \"),a(\"blockquote\",[a(\"p\",[t._v(\"注意：由于 typeof 的设计有局限性，并不能完全反应引用类型的类型。因此在实际应用中，因此值类型的类型判断用 typeof，引用类型的类型判断用 instanceof。但是下面为了探究函数对象和普通对象的区别依然使用 typeof。\")])]),t._v(\" \"),a(\"p\",[t._v(\"相信你一定很好奇函数对象和普通对象的区别，先别急。我们先看下面的一个例子。\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v('function Fun() {\\n    this.a = 5\\n}\\nvar fun = new Fun()\\n\\ntypeof Fun // \"function\"\\ntypeof fun // \"object\"\\n')])])]),a(\"p\",[t._v(\"我们可以看出来通过函数 \"),a(\"code\",[t._v(\"Fun\")]),t._v(\" 生成了对象 \"),a(\"code\",[t._v(\"fun\")]),t._v(\"。其实\"),a(\"strong\",[t._v(\"所有的对象都是通过函数生成的\")]),t._v(\"。你可能会提出反对意见：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"var obj = { a: 5, b: 10 }\\nvar fun = function(){}\\n\")])])]),a(\"p\",[t._v(\"你会说 obj 和 fun 都是对象，但他们都没有通过函数生成啊。\")]),t._v(\" \"),a(\"p\",[t._v(\"其实这是 JavaScript 提供的语法糖，本质上他们会分别调用 Object 和 Function （注意大写）这两个\"),a(\"strong\",[t._v(\"函数对象\")]),t._v(\"来生成。\"),a(\"strong\",[t._v(\"每个对象\")]),t._v(\"都有一个 constructor 的属性指向它的构建函数。\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"obj.constructor // ƒ Object() { [native code] }\\nfun.constructor // ƒ Function() { [native code] }\\n\")])])]),a(\"p\",[t._v(\"因此上面的代码等同于：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"// var obj = { a: 5, b: 10 }\\nvar obj = new Object()\\nobj.a = 5\\nobj.b = 10\\n\\n// var fun = function(){} \\nvar fun = new Function()\\n\")])])]),a(\"p\",[t._v(\"到了这里引出了两个重要的函数对象 Object 和 Function。\")]),t._v(\" \"),a(\"p\",[t._v(\"在解释他们之前需要再在了解两个容易混淆的东西：\"),a(\"code\",[t._v(\"__proto__\")]),t._v(\" 和 \"),a(\"code\",[t._v(\"prototype\")]),t._v(\"。\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[a(\"p\",[a(\"code\",[t._v(\"prototype\")]),t._v(\" 是每个\"),a(\"strong\",[t._v(\"函数\")]),t._v(\"都有的一个属性。它本身是一个对象，它的 constructor 指向函数本身。\")])]),t._v(\" \"),a(\"li\",[a(\"p\",[a(\"code\",[t._v(\"__proto__\")]),t._v(\" 是每个\"),a(\"strong\",[t._v(\"对象\")]),t._v(\"都有的一个属性。指向创建该对象的函数的prototype。它是个隐藏属性，早期低版本的浏览器甚至不支持这个属性。\")])])]),t._v(\" \"),a(\"p\",[t._v(\"我们先看一下 Object 和 Function 的类型。\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v('typeof Function // \"function\"\\ntypeof Object // \"function\"\\n')])])]),a(\"p\",[t._v(\"让人意外的是他们都是函数对象，我们按照上面的说明列出他们的内存布局。\")]),t._v(\" \"),a(\"p\",[t._v(\"因为它们都是对象因此它们都有 \"),a(\"code\",[t._v(\"constructor\")]),t._v(\"、\"),a(\"code\",[t._v(\"__proto__\")]),t._v(\" 属性，又因为他们是函数对象，因此它们都有 \"),a(\"code\",[t._v(\"prototype\")]),t._v(\" 属性。\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:e(317),alt:\"\"}})]),t._v(\" \"),a(\"p\",[t._v(\"对于 Function 来说\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v('// 虽然 Function.prototype 返回的类型是 function 但是它的 prototype 属性并不存在，因此它是一个对象而不是函数对象。\\n\\ntypeof Function.prototype // \"function\"\\ntypeof Function.prototype.prototype // \"undefined\"\\n\\n// Function.prototype 与 Function.__proto__ 指向同一个对象\\nFunction.prototype == Function.__proto__\\n\\n// Function.prototype 的 constructor 是 Function 函数\\nFunction.prototype.constructor // ƒ Function() { [native code] }\\n\\n// Function 的 constructor 是 Function 函数自己（特例）\\nFunction.constructor // ƒ Function() { [native code] }\\n')])])]),a(\"p\",[t._v(\"可以画出下面的图\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:e(318),alt:\"\"}})]),t._v(\" \"),a(\"p\",[t._v(\"对于 Object 来说\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v('// Object.prototype 是一个对象\\ntypeof Object.prototype // \"object\"\\n\\n// Object.__proto__ 与 Object.prototype 指向的不是同一个对象\\nObject.prototype == Object.__proto__ // false\\n// Object.__proto__ 指向 Function.prototype 的对象 （特例）\\nObject.__proto__ == Function.prototype // true\\n\\n// Object.prototype 的 constructor 是 Object 函数\\nObject.prototype.constructor // ƒ Object() { [native code] }\\n\\n// Object 的 constructor 是 Function 函数（特例）\\nObject.constructor // ƒ Function() { [native code] }\\n')])])]),a(\"p\",[t._v(\"可以画出下面的图\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:e(319),alt:\"\"}})]),t._v(\" \"),a(\"p\",[t._v(\"我们发现还有两个属性没确定分别是 \"),a(\"code\",[t._v(\"Object.prototype.__proto__\")]),t._v(\" 和 \"),a(\"code\",[t._v(\"Function.prototype.__proto__\")]),t._v(\"。我们通过代码在确认一下。\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"// Function.prototype 的 __proto__ 属性指向 Object.prototype\\nFunction.prototype.__proto__ == Object.prototype // true\\n\\n// Object.prototype 的 __proto__  属性指向 null\\nObject.prototype.__proto__ // null\\n\")])])]),a(\"p\",[t._v(\"最终得到这个图\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:e(320),alt:\"\"}})]),t._v(\" \"),a(\"h2\",{attrs:{id:\"原型链\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#原型链\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 原型链\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"与原型链相关的方法\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#与原型链相关的方法\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 与原型链相关的方法\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"es5-对象继承\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#es5-对象继承\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" ES5 对象继承\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"es6-实现继承\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#es6-实现继承\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" ES6 实现继承\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"参考\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#参考\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 参考\")]),t._v(\" \"),a(\"ol\",[a(\"li\",[a(\"a\",{attrs:{href:\"\"}})]),t._v(\" \"),a(\"li\",[a(\"a\",{attrs:{href:\"\"}})]),t._v(\" \"),a(\"li\",[a(\"a\",{attrs:{href:\"\"}})]),t._v(\" \"),a(\"li\",[a(\"a\",{attrs:{href:\"\"}})]),t._v(\" \"),a(\"li\",[a(\"a\",{attrs:{href:\"\"}})])])])},[],!1,null,null,null);n.default=o.exports}}]);","extractedComments":[]}