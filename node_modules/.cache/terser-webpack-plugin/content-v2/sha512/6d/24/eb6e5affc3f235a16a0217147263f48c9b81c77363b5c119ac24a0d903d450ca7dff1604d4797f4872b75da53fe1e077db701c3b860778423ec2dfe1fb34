{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[99],{503:function(_,v,n){\"use strict\";n.r(v);var l=n(0),i=Object(l.a)({},function(){var _=this,v=_.$createElement,n=_._self._c||v;return n(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":_.$parent.slotKey}},[n(\"h1\",{attrs:{id:\"递归树\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#递归树\",\"aria-hidden\":\"true\"}},[_._v(\"#\")]),_._v(\" 递归树\")]),_._v(\" \"),n(\"p\",[_._v(\"递归的思想就是将大的问题分解成小的问题，直到分解到递归基础。如果将分解的过程画出来就是一颗树型结构，称之为\"),n(\"strong\",[_._v(\"递归树\")]),_._v(\"。\")]),_._v(\" \"),n(\"h2\",{attrs:{id:\"使用递归树来分析递归的时间复杂度\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#使用递归树来分析递归的时间复杂度\",\"aria-hidden\":\"true\"}},[_._v(\"#\")]),_._v(\" 使用递归树来分析递归的时间复杂度\")]),_._v(\" \"),n(\"ol\",[n(\"li\",[_._v(\"根据递推公式画出分解过程\")]),_._v(\" \"),n(\"li\",[_._v(\"计算每一层的时间消耗\")]),_._v(\" \"),n(\"li\",[_._v(\"计算递归树的高度\")]),_._v(\" \"),n(\"li\",[_._v(\"整体时间复杂度就是每一层的时间消耗的和\")])]),_._v(\" \"),n(\"h2\",{attrs:{id:\"时间复杂度分析实例\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#时间复杂度分析实例\",\"aria-hidden\":\"true\"}},[_._v(\"#\")]),_._v(\" 时间复杂度分析实例\")]),_._v(\" \"),n(\"h3\",{attrs:{id:\"_1-归并排序\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-归并排序\",\"aria-hidden\":\"true\"}},[_._v(\"#\")]),_._v(\" 1. 归并排序\")]),_._v(\" \"),n(\"ol\",[n(\"li\",[n(\"p\",[_._v(\"递归树\")]),_._v(\" \"),n(\"pre\",[n(\"code\",[_._v(\"          m(n)\\n      ╱         ╲\\n  m(n/2)         m(n/2)\\n   ╱   ╲         ╱    ╲\\nm(n/4) m(n/4)  m(n/4) m(n/4) \\n ....\\n\")])])]),_._v(\" \"),n(\"li\",[n(\"p\",[_._v(\"每层时间消耗\")]),_._v(\" \"),n(\"p\",[_._v(\"由于归并排序最耗时的就是归并操作，因此每层的时间消耗就是归并操作的个数。由于每一层需要进行归并操作的个数都是一样的都记为 n\")])]),_._v(\" \"),n(\"li\",[n(\"p\",[_._v(\"递归树高度\")]),_._v(\" \"),n(\"p\",[_._v(\"归并排序的递归树是一颗满二叉树，其高度约为 log2n\")])]),_._v(\" \"),n(\"li\",[n(\"p\",[_._v(\"计算复杂度\")]),_._v(\" \"),n(\"p\",[_._v(\"由以上两步可以得出时间复杂度等于：O(nlogn)\")])])]),_._v(\" \"),n(\"h3\",{attrs:{id:\"_2-快速排序\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-快速排序\",\"aria-hidden\":\"true\"}},[_._v(\"#\")]),_._v(\" 2. 快速排序\")]),_._v(\" \"),n(\"ol\",[n(\"li\",[n(\"p\",[_._v(\"递归树\")]),_._v(\" \"),n(\"p\",[_._v(\"由于快速排序的时间复杂度与分区点的选择有很大关系。最好情况下每次分区都能一分为二，这样就类似于归并排序，时间复杂度就是 O(nlogn)。\")]),_._v(\" \"),n(\"p\",[_._v(\"我们假设平均情况下每次分区后分区的大小比例为 1：k， k = 9 的情况下\")]),_._v(\" \"),n(\"pre\",[n(\"code\",[_._v(\"                  q(n)\\n         ╱                     ╲\\n      q(n/10)                 q(9n/10)\\n    ╱         ╲              ╱        ╲\\nq(n/10^2)  q(9n/10^2)  q(9n/10^2)   q(9^2n/10^2)\\n ....\\n\")])])]),_._v(\" \"),n(\"li\",[n(\"p\",[_._v(\"每层时间消耗\")]),_._v(\" \"),n(\"p\",[_._v(\"由于快速排序中每层都需要遍历分区的所有数据，因此每层的时间消耗就是 n\")])]),_._v(\" \"),n(\"li\",[n(\"p\",[_._v(\"递归树高度\")]),_._v(\" \"),n(\"ul\",[n(\"li\",[_._v(\"最短路径：从根节点 n 到叶子节点 1，递归树每次乘以 1/10，因此最短路径 h = log10 n\")]),_._v(\" \"),n(\"li\",[_._v(\"最长路径：从根节点 n 到叶子节点 1，递归树每次乘以 9/10, 因此最长路径 h = log(10/9) n\")])]),_._v(\" \"),n(\"p\",[_._v(\"我们知道对于对数来说不管是多少为底都统一算做 logn，因此递归树的高度近似于 logn\")])]),_._v(\" \"),n(\"li\",[n(\"p\",[_._v(\"计算复杂度\")]),_._v(\" \"),n(\"p\",[_._v(\"由以上两步可以得出时间复杂度等于：O(nlogn)\")])])]),_._v(\" \"),n(\"h3\",{attrs:{id:\"_3-斐波那契数列\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-斐波那契数列\",\"aria-hidden\":\"true\"}},[_._v(\"#\")]),_._v(\" 3. 斐波那契数列\")]),_._v(\" \"),n(\"pre\",[n(\"code\",[_._v(\"f(n) = f(n-1) + f(n-2)\\n\")])]),_._v(\" \"),n(\"ol\",[n(\"li\",[n(\"p\",[_._v(\"递归树\")]),_._v(\" \"),n(\"pre\",[n(\"code\",[_._v(\"                  f(n)\\n         ╱                     ╲\\n      f(n-1)                   q(n-2)\\n    ╱         ╲              ╱        ╲\\nf(n-2)      f(n-3)       f(n-3)      f(n-4)\\n ....\\n\")])])]),_._v(\" \"),n(\"li\",[n(\"p\",[_._v(\"每层时间消耗\")]),_._v(\" \"),n(\"ul\",[n(\"li\",[_._v(\"第 1 层到第 2 层                1\")]),_._v(\" \"),n(\"li\",[_._v(\"第 2 层到第 3 层                2\")]),_._v(\" \"),n(\"li\",[_._v(\"第 3 层到第 4 层                4\")]),_._v(\" \"),n(\"li\",[_._v(\"...\")]),_._v(\" \"),n(\"li\",[_._v(\"第 n-1 层到第 n 层              2^(n-1)\")])])]),_._v(\" \"),n(\"li\",[n(\"p\",[_._v(\"递归树高度\")]),_._v(\" \"),n(\"ul\",[n(\"li\",[_._v(\"最长路径：从根节点 n 到叶子节点 1，递归树每次 -1，因此最短路径 h = n\")]),_._v(\" \"),n(\"li\",[_._v(\"最短路径：从根节点 n 到叶子节点 1，递归树每次 -2, 因此最长路径 h = n/2\")])])]),_._v(\" \"),n(\"li\",[n(\"p\",[_._v(\"计算复杂度\")]),_._v(\" \"),n(\"ul\",[n(\"li\",[_._v(\"所有路径都是最长路径，则根据等比数列求和公式，时间复杂度就是 2^n - 1\")]),_._v(\" \"),n(\"li\",[_._v(\"所有路径都是最短路径，则根据等比数列求和公式，时间复杂度就是 2^(n/2) - 1\")])]),_._v(\" \"),n(\"p\",[_._v(\"这个算法的时间复杂度就介于 O(2n) 到 O(2^(n/2) - 1) 之间。是指数级的。\")])])]),_._v(\" \"),n(\"h3\",{attrs:{id:\"_4-完全排列（如何把-n-个数据的所有排列都找出来）\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-完全排列（如何把-n-个数据的所有排列都找出来）\",\"aria-hidden\":\"true\"}},[_._v(\"#\")]),_._v(\" 4. 完全排列（如何把 n 个数据的所有排列都找出来）\")]),_._v(\" \"),n(\"ol\",[n(\"li\",[n(\"p\",[_._v(\"递归树\")]),_._v(\" \"),n(\"p\",[_._v(\"f(n) = n * f(n-1)\")]),_._v(\" \"),n(\"pre\",[n(\"code\",[_._v(\"                   f(n)\\n         ╱          ...          ╲\\n      f(n-1)        ...         q(n-1)\\n    ╱        ╲      ...       ╱        ╲\\nf(n-2)      f(n-2)  ...   f(n-2)      f(n-2)\\n ....\\n\")])])]),_._v(\" \"),n(\"li\",[n(\"p\",[_._v(\"每层时间消耗\")]),_._v(\" \"),n(\"ul\",[n(\"li\",[_._v(\"第 1 层到第 2 层                n\")]),_._v(\" \"),n(\"li\",[_._v(\"第 2 层到第 3 层                n(n-1)\")]),_._v(\" \"),n(\"li\",[_._v(\"第 3 层到第 4 层                n(n-1)(n-2)\")]),_._v(\" \"),n(\"li\",[_._v(\"...\")]),_._v(\" \"),n(\"li\",[_._v(\"第 n-1 层到第 n 层              (n)!\")])])]),_._v(\" \"),n(\"li\",[n(\"p\",[_._v(\"递归树高度\")]),_._v(\" \"),n(\"ul\",[n(\"li\",[_._v(\"最长路径：从根节点 n 到叶子节点 1，递归树每次 -1，因此最短路径 h = n\")]),_._v(\" \"),n(\"li\",[_._v(\"最短路径：从根节点 n 到叶子节点 1，递归树每次 -2, 因此最长路径 h = n/2\")])])]),_._v(\" \"),n(\"li\",[n(\"p\",[_._v(\"计算复杂度\")]),_._v(\" \"),n(\"ul\",[n(\"li\",[_._v(\"所有路径都是最长路径，则根据等比数列求和公式，时间复杂度就是 2^n - 1\")]),_._v(\" \"),n(\"li\",[_._v(\"所有路径都是最短路径，则根据等比数列求和公式，时间复杂度就是 2^(n/2) - 1\")])]),_._v(\" \"),n(\"p\",[_._v(\"这个算法的时间复杂度就介于 O(2n) 到 O(2^(n/2) - 1) 之间。是指数级的。\")])])]),_._v(\" \"),n(\"h3\",{attrs:{id:\"_5-细胞分裂：1-个细胞的生命周期是-3-个小时，-1-小时分裂一次。求-n-小时后容器内有多少细胞\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5-细胞分裂：1-个细胞的生命周期是-3-个小时，-1-小时分裂一次。求-n-小时后容器内有多少细胞\",\"aria-hidden\":\"true\"}},[_._v(\"#\")]),_._v(\" 5. 细胞分裂：1 个细胞的生命周期是 3 个小时， 1 小时分裂一次。求 n 小时后容器内有多少细胞\")]),_._v(\" \"),n(\"ol\",[n(\"li\",[n(\"p\",[_._v(\"递归树\")]),_._v(\" \"),n(\"p\",[_._v(\"f(n) = 2 * f(n-1) - f(n-3)\")]),_._v(\" \"),n(\"pre\",[n(\"code\",[_._v(\"                   f(n)\\n         ╱          |          ╲\\n       f(n-1)     f(n-1)        f(n-3)\\n    ╱    |    ╲      ...       \\nf(n-2) f(n-2) f(n-4) ...  \\n ....\\n\")])])]),_._v(\" \"),n(\"li\",[n(\"p\",[_._v(\"每层时间消耗\")]),_._v(\" \"),n(\"ul\",[n(\"li\",[_._v(\"第 1 层到第 2 层                1\")]),_._v(\" \"),n(\"li\",[_._v(\"第 2 层到第 3 层                3\")]),_._v(\" \"),n(\"li\",[_._v(\"第 3 层到第 4 层                9\")]),_._v(\" \"),n(\"li\",[_._v(\"...\")]),_._v(\" \"),n(\"li\",[_._v(\"第 n-1 层到第 n 层              3^(n-1)\")])])]),_._v(\" \"),n(\"li\",[n(\"p\",[_._v(\"递归树高度\")]),_._v(\" \"),n(\"ul\",[n(\"li\",[_._v(\"从根节点 n 到叶子节点 1，递归树每次 -1，因此路径 h = n\")])])]),_._v(\" \"),n(\"li\",[n(\"p\",[_._v(\"计算复杂度\")]),_._v(\" \"),n(\"p\",[_._v(\"根据等比数列求和公式可以得出其时间复杂度为 O(3^n) 简化为 O(2^n)\")])])])])},[],!1,null,null,null);v.default=i.exports}}]);","extractedComments":[]}