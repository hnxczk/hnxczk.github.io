{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{427:function(a,t,r){\"use strict\";r.r(t);var e=r(0),s=Object(e.a)({},function(){var a=this,t=a.$createElement,r=a._self._c||t;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":a.$parent.slotKey}},[r(\"h1\",{attrs:{id:\"递归\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#递归\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 递归\")]),a._v(\" \"),r(\"h2\",{attrs:{id:\"_10-递归\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_10-递归\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 10 递归\")]),a._v(\" \"),r(\"h3\",{attrs:{id:\"递归需要满足的三个条件\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#递归需要满足的三个条件\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 递归需要满足的三个条件\")]),a._v(\" \"),r(\"ul\",[r(\"li\",[a._v(\"一个问题的解可以分解为几个四问题的解\")]),a._v(\" \"),r(\"li\",[a._v(\"这个问题已分解后的子问题，除了数据规模一样，求解思路完全一样\")]),a._v(\" \"),r(\"li\",[a._v(\"存在递归终止条件\")])]),a._v(\" \"),r(\"h3\",{attrs:{id:\"如何编写递归代码\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何编写递归代码\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 如何编写递归代码\")]),a._v(\" \"),r(\"ul\",[r(\"li\",[r(\"p\",[r(\"strong\",[a._v(\"写递归代码的关键就是找到如何将大问题分解为小问题的规律，并基于此写出递推公式，然后找到终止条件，最后将他们翻译成代码\")])])]),a._v(\" \"),r(\"li\",[r(\"p\",[r(\"strong\",[a._v(\"编写递归代码的关键是，只要遇到递归，我们就把它抽象成一盒递推公式，不用想一层层的调用用关系，不要试图用人脑分解递归的每个步骤\")])])])]),a._v(\" \"),r(\"h3\",{attrs:{id:\"需要注意的问题\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#需要注意的问题\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 需要注意的问题\")]),a._v(\" \"),r(\"h4\",{attrs:{id:\"堆栈溢出\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#堆栈溢出\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 堆栈溢出\")]),a._v(\" \"),r(\"p\",[a._v(\"由于函数调用会使用栈来保存临时变量，每调用一个函数都会将临时变量封装为栈帧\\b压入内存栈，等函数执行完成后返回再出栈。这样以来当递归求解数据规模很大，调用层级很深，就会出现堆栈溢出的风险。\")]),a._v(\" \"),r(\"h4\",{attrs:{id:\"警惕重复的计算\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#警惕重复的计算\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 警惕重复的计算\")]),a._v(\" \"),r(\"p\",[a._v(\"求解递归的过程中可能会出现重复计算的问题，这时候可以通过散列表等数据结构来保存计算结果。如果已经求解过了就直接返回，不需要重复计算。\")]),a._v(\" \"),r(\"h4\",{attrs:{id:\"注意空间复杂度\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#注意空间复杂度\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 注意空间复杂度\")]),a._v(\" \"),r(\"p\",[a._v(\"由于递归每调用一次就会在内存堆栈中保存一次现场数据，因此计算递归代码的空间复杂的时候需要考虑着些额外内存开销。\")]),a._v(\" \"),r(\"h3\",{attrs:{id:\"递归代码改写成飞递归代码\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#递归代码改写成飞递归代码\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 递归代码改写成飞递归代码\")]),a._v(\" \"),r(\"p\",[a._v(\"理论上递归代码都可以改写为非递归代码，但是这样会增加实现的复杂度。\")]),a._v(\" \"),r(\"p\",[a._v(\"如何做？抽象出递推公式、初始值和边界条件，然后用迭代循环实现。\")])])},[],!1,null,null,null);t.default=s.exports}}]);","extractedComments":[]}