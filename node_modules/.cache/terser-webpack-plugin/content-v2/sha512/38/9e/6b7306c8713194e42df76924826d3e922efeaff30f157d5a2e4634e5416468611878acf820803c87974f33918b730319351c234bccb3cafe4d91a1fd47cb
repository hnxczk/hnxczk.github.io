{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{410:function(a,_,v){\"use strict\";v.r(_);var t=v(0),r=Object(t.a)({},function(){var a=this,_=a.$createElement,v=a._self._c||_;return v(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":a.$parent.slotKey}},[v(\"h1\",{attrs:{id:\"堆和堆排序\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#堆和堆排序\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 堆和堆排序\")]),a._v(\" \"),v(\"h2\",{attrs:{id:\"堆\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#堆\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 堆\")]),a._v(\" \"),v(\"h3\",{attrs:{id:\"定义\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#定义\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 定义\")]),a._v(\" \"),v(\"ul\",[v(\"li\",[a._v(\"堆是一种特殊的树\")]),a._v(\" \"),v(\"li\",[v(\"strong\",[a._v(\"堆是一个完全二叉树\")])]),a._v(\" \"),v(\"li\",[v(\"strong\",[a._v(\"堆中的每个节点的值必须大于（小于）等于其子树中每个节点的值\")])]),a._v(\" \"),v(\"li\",[a._v(\"大顶堆：每个节点的值大于等于其子节点的值\")]),a._v(\" \"),v(\"li\",[a._v(\"小顶堆：每个节点的值小于等于其子节点的值\")])]),a._v(\" \"),v(\"h3\",{attrs:{id:\"堆的实现\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#堆的实现\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 堆的实现\")]),a._v(\" \"),v(\"p\",[a._v(\"由于堆是完全二叉树因此适合用数组来存储\")]),a._v(\" \"),v(\"p\",[a._v(\"数组中下标为 i 的节点的左子节点就是下标为 ix2 的节点，右子节点就是下标为 ix2 + 1 的节点，父节点就是下标为 i/2 的节点。\")]),a._v(\" \"),v(\"h3\",{attrs:{id:\"堆的操作\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#堆的操作\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 堆的操作\")]),a._v(\" \"),v(\"h4\",{attrs:{id:\"插入（大顶堆）\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#插入（大顶堆）\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 插入（大顶堆）\")]),a._v(\" \"),v(\"ol\",[v(\"li\",[a._v(\"将要插入的元素放到存储堆的数组的末尾\")]),a._v(\" \"),v(\"li\",[a._v(\"进行堆化（从下往上）\\n\"),v(\"ol\",[v(\"li\",[a._v(\"将插入的 i 节点与其父节点 i/2 对比大小\")]),a._v(\" \"),v(\"li\",[a._v(\"如果 i 节点大于父节点的值就交换两个节点\")]),a._v(\" \"),v(\"li\",[a._v(\"重复上面的比较操作直到父子关系满足大顶堆的要求\")])])])]),a._v(\" \"),v(\"h4\",{attrs:{id:\"删除堆顶元素（大顶堆）\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#删除堆顶元素（大顶堆）\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 删除堆顶元素（大顶堆）\")]),a._v(\" \"),v(\"ol\",[v(\"li\",[a._v(\"删除堆顶元素\")]),a._v(\" \"),v(\"li\",[a._v(\"将最后一个节点放到堆顶\")]),a._v(\" \"),v(\"li\",[a._v(\"进行堆化（从上到下）\\n\"),v(\"ol\",[v(\"li\",[a._v(\"定义 i = 1，表明是堆顶\")]),a._v(\" \"),v(\"li\",[a._v(\"比较 i 节点与子节点的大小，如果子节点全都小于 i 节点，说明堆化完成\")]),a._v(\" \"),v(\"li\",[a._v(\"否则将 i 节点与其子节点中较大的那个交换\")]),a._v(\" \"),v(\"li\",[a._v(\"让 i 等于子节点中较大的那个，继续 2，3 操作\")])])])]),a._v(\" \"),v(\"h4\",{attrs:{id:\"复杂度分析\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#复杂度分析\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 复杂度分析\")]),a._v(\" \"),v(\"p\",[a._v(\"由于上面主要的操作就在于堆化，而堆化就是顺着节点的路径进行比较和替换，因此堆化的复杂度取决于树的高度，因此插入和删除堆顶元素的时间复杂度就是 O(logn)。\")]),a._v(\" \"),v(\"h2\",{attrs:{id:\"堆排序\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#堆排序\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 堆排序\")]),a._v(\" \"),v(\"p\",[a._v(\"堆排序不是稳定排序算法，时间复杂度是 O(nlogn)，并且是原地算法。\")]),a._v(\" \"),v(\"h3\",{attrs:{id:\"步骤\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#步骤\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 步骤\")]),a._v(\" \"),v(\"h4\",{attrs:{id:\"_1-建堆\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-建堆\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 1. 建堆\")]),a._v(\" \"),v(\"ul\",[v(\"li\",[a._v(\"思路 1 ：在堆中插入元素\\n\"),v(\"ol\",[v(\"li\",[a._v(\"起始的时候将数组中的第一个元素看成是一个起始堆\")]),a._v(\" \"),v(\"li\",[a._v(\"将下标从 2 到 n 的数据依次插入堆中\")])])]),a._v(\" \"),v(\"li\",[a._v(\"思路 2 ：从后往前处理数据，挨个进行堆化\\n\"),v(\"ol\",[v(\"li\",[a._v(\"由于叶子节点不能往下堆化，因此略过\")]),a._v(\" \"),v(\"li\",[a._v(\"从第一个非叶子节点 n/2（也就是最后一个元素 n 的父节点）开始堆化\")]),a._v(\" \"),v(\"li\",[a._v(\"然后依次对 n/2 到 1 的数据进行堆化\")])])])]),a._v(\" \"),v(\"h5\",{attrs:{id:\"思路-2-的时间复杂度\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#思路-2-的时间复杂度\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 思路 2 的时间复杂度\")]),a._v(\" \"),v(\"ol\",[v(\"li\",[v(\"p\",[a._v(\"每个节点堆化的过程跟需要比较和交换的节点个数相关，而这个个数又跟节点的高度 k 成正比\")])]),a._v(\" \"),v(\"li\",[v(\"p\",[a._v(\"对于堆来说\")]),a._v(\" \"),v(\"ul\",[v(\"li\",[a._v(\"第 1 层节点个数为 1， 高度为 k\")]),a._v(\" \"),v(\"li\",[a._v(\"第 2 层节点个数为 2， 高度为 k-1\")]),a._v(\" \"),v(\"li\",[a._v(\"第 3 层节点个数为 2^2， 高度为 k-2\")]),a._v(\" \"),v(\"li\",[a._v(\"...\")]),a._v(\" \"),v(\"li\",[a._v(\"第 i-1 层节点个数为 2^i， 高度为 k-i\")]),a._v(\" \"),v(\"li\",[a._v(\"...\")]),a._v(\" \"),v(\"li\",[a._v(\"第 k 层节点个数为 2^k-1， 高度为 1\")])]),a._v(\" \"),v(\"p\",[a._v(\"综上可以看出所有堆化需要进行的比较和交换个数就是\")]),a._v(\" \"),v(\"div\",{staticClass:\"language- extra-class\"},[v(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[v(\"code\",[a._v(\"s = 1*k + 2*(k-1) + 2^2*(k-2) + ... + 2^i*(k-i) + ... + 2^(k-1)*1\\n\")])])])]),a._v(\" \"),v(\"li\",[v(\"p\",[a._v(\"经过求解上面的公式得出\")]),a._v(\" \"),v(\"div\",{staticClass:\"language- extra-class\"},[v(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[v(\"code\",[a._v(\"s = 2^(k+1) - k - 2\\n\")])])])]),a._v(\" \"),v(\"li\",[v(\"p\",[a._v(\"高度 k = log2n， 因此可以看出 s = O(n)\")])]),a._v(\" \"),v(\"li\",[v(\"p\",[a._v(\"因此建堆的复杂度就是 O（n）\")])])]),a._v(\" \"),v(\"h4\",{attrs:{id:\"排序\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#排序\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 排序\")]),a._v(\" \"),v(\"ol\",[v(\"li\",[a._v(\"建堆结束后，数组中的数据就是大顶堆了，堆顶元素就是最大值\")]),a._v(\" \"),v(\"li\",[a._v(\"将堆顶元素与最后一个元素交换，代表已经排好一个位置\")]),a._v(\" \"),v(\"li\",[a._v(\"对剩余的元素进行堆化，然后继续 2 操作\")]),a._v(\" \"),v(\"li\",[a._v(\"当堆中元素个数为 1，代表已经完成排序\")])]),a._v(\" \"),v(\"h5\",{attrs:{id:\"复杂度分析-2\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#复杂度分析-2\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 复杂度分析\")]),a._v(\" \"),v(\"p\",[a._v(\"我们可以看出耗时的操作主要是进行堆化的操作，因此每次堆化的复杂度就是 O(logn)，又由于需要每个元素排好后都需要进行堆化，因此整体复杂度就是 O(nlogn).\")]),a._v(\" \"),v(\"h3\",{attrs:{id:\"堆排序复杂度\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#堆排序复杂度\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 堆排序复杂度\")]),a._v(\" \"),v(\"p\",[a._v(\"由上可以看出堆排序主要分为两步：建堆（复杂度为 O(n)）、排序（复杂度为 O(nlogn)）。因此排序整体复杂度就是 O(nlogn)。\")]),a._v(\" \"),v(\"h2\",{attrs:{id:\"qa\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#qa\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" QA\")]),a._v(\" \"),v(\"ol\",[v(\"li\",[v(\"p\",[a._v(\"堆排序性能为什么低于快排\")]),a._v(\" \"),v(\"ol\",[v(\"li\",[a._v(\"堆排序的数据是跳动访问的，相较于快排中局部顺序访问的情况，不利于 CPU 的缓存。\")]),a._v(\" \"),v(\"li\",[a._v(\"同样的数据，堆排序交换次数要多于快排，尤其是当要排序的数据的有序度较高的情况下。\")])])]),a._v(\" \"),v(\"li\",[v(\"p\",[a._v(\"为什么对于完全二叉树，下标从 n/2+1 到 n 都是叶子节点\")]),a._v(\" \"),v(\"p\",[a._v(\"如果最后一个元素的下标是 n ，则其父节点的下标就是 n/2。因此 n/2+1 到 n 都是叶子节点。\")])])]),a._v(\" \"),v(\"h1\",{attrs:{id:\"堆的应用\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#堆的应用\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 堆的应用\")]),a._v(\" \"),v(\"h2\",{attrs:{id:\"优先级队列\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#优先级队列\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 优先级队列\")]),a._v(\" \"),v(\"h3\",{attrs:{id:\"定义-2\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#定义-2\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 定义\")]),a._v(\" \"),v(\"p\",[a._v(\"优先级队列也是一个队列，出队的时候，优先级高的先出队，低的后出队。\")]),a._v(\" \"),v(\"p\",[a._v(\"利用堆来实现优先队列是最直接和高效的。\")]),a._v(\" \"),v(\"h3\",{attrs:{id:\"应用\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#应用\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 应用\")]),a._v(\" \"),v(\"h4\",{attrs:{id:\"_1-合并有序小文件\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-合并有序小文件\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 1. 合并有序小文件\")]),a._v(\" \"),v(\"p\",[a._v(\"假设有 100 个小文件，每个文件都是存储着 100MB 大小的有序字符串，如何合并。\")]),a._v(\" \"),v(\"ol\",[v(\"li\",[a._v(\"每个文件取首个字符串，构建一个小顶堆\")]),a._v(\" \"),v(\"li\",[a._v(\"小顶堆的堆顶元素就是最小元素，取出将其存入数组\")]),a._v(\" \"),v(\"li\",[a._v(\"将堆顶删除后，把它所在的文件中的下一个字符串取出，放入堆中\")]),a._v(\" \"),v(\"li\",[a._v(\"堆化后继续 2、3 操作，直到所有的处理完成\")])]),a._v(\" \"),v(\"h4\",{attrs:{id:\"_2-高性能定时器\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-高性能定时器\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 2. 高性能定时器\")]),a._v(\" \"),v(\"p\",[a._v(\"一个定时器维护了很多定时任务，每个任务都设定了触发的时间点。如何高效实现定时器的功能\")]),a._v(\" \"),v(\"ol\",[v(\"li\",[a._v(\"按照任务的触发时间，将任务置于优先队列中，这样以来小顶堆的堆顶就是最先要执行的任务\")]),a._v(\" \"),v(\"li\",[a._v(\"根据当前时间与堆顶任务触发时间的间隔，间隔时间到了就去执行堆顶任务\")]),a._v(\" \"),v(\"li\",[a._v(\"执行任务后删除堆顶元素，从新堆化\")]),a._v(\" \"),v(\"li\",[a._v(\"继续 2、3 操作\")])]),a._v(\" \"),v(\"h2\",{attrs:{id:\"利用堆求-top-k\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#利用堆求-top-k\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 利用堆求 Top K\")]),a._v(\" \"),v(\"h3\",{attrs:{id:\"静态数据（已经给定，不会再添加）\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#静态数据（已经给定，不会再添加）\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 静态数据（已经给定，不会再添加）\")]),a._v(\" \"),v(\"ol\",[v(\"li\",[a._v(\"维护一个 K 大小的小顶堆\")]),a._v(\" \"),v(\"li\",[a._v(\"遍历数据\\n\"),v(\"ol\",[v(\"li\",[a._v(\"数据大于堆顶元素的时候，删除堆顶元素，将数据插入堆中\")]),a._v(\" \"),v(\"li\",[a._v(\"数据小于堆顶元素，不做处理\")])])]),a._v(\" \"),v(\"li\",[a._v(\"继续 2 的操作直到全部遍历完后，堆中的数据就是 Top K 的元素了\")])]),a._v(\" \"),v(\"h3\",{attrs:{id:\"动态数据（未确定，还会再添加）\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#动态数据（未确定，还会再添加）\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 动态数据（未确定，还会再添加）\")]),a._v(\" \"),v(\"ol\",[v(\"li\",[a._v(\"首先对已给定的数据进行上面的处理，得到其 Top K 的堆\")]),a._v(\" \"),v(\"li\",[a._v(\"插入数据的时候\\n\"),v(\"ol\",[v(\"li\",[a._v(\"数据大于堆顶元素的时候，删除堆顶元素，将数据插入堆中\")]),a._v(\" \"),v(\"li\",[a._v(\"数据小于堆顶元素，不做处理\")])])]),a._v(\" \"),v(\"li\",[a._v(\"每次插入都进行 2 操作，堆中的元素就一直是 Top K 的元素了\")])]),a._v(\" \"),v(\"h2\",{attrs:{id:\"利用堆求中位数\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#利用堆求中位数\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 利用堆求中位数\")]),a._v(\" \"),v(\"h3\",{attrs:{id:\"中位数\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#中位数\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 中位数\")]),a._v(\" \"),v(\"ul\",[v(\"li\",[a._v(\"数据数量是奇数：第 n/2+1 个数就是中位数\")]),a._v(\" \"),v(\"li\",[a._v(\"数据数量是偶数：第 n/2 和第 n/2+1 个数都是是中位数\")])]),a._v(\" \"),v(\"h3\",{attrs:{id:\"求中位数\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#求中位数\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 求中位数\")]),a._v(\" \"),v(\"ol\",[v(\"li\",[a._v(\"维护两个堆。\\n\"),v(\"ol\",[v(\"li\",[a._v(\"一个是大顶堆，存储前半部分数据。奇数情况下存储 n/2+1 个数据，偶数情况下存储 n/2 个数据\")]),a._v(\" \"),v(\"li\",[a._v(\"一个是小顶堆，存储后半部分数据。奇数偶数情况下都存储 n/2 个数据\")])])]),a._v(\" \"),v(\"li\",[a._v(\"插入数据的时候\\n\"),v(\"ol\",[v(\"li\",[a._v(\"数据小于等于大顶堆堆顶元素的大小的时候，将其插入到大顶堆\")]),a._v(\" \"),v(\"li\",[a._v(\"数据大于等于小顶堆堆顶元素的大小的时候，将其插入到小顶堆\")])])]),a._v(\" \"),v(\"li\",[a._v(\"插入结束后检查是否满足条件 1 ，不满足的情况下移动堆顶元素使其满足\")]),a._v(\" \"),v(\"li\",[a._v(\"这样的话中位数就是两个堆的堆顶元素\")])]),a._v(\" \"),v(\"h3\",{attrs:{id:\"求-99-相应时间\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#求-99-相应时间\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 求 99% 相应时间\")]),a._v(\" \"),v(\"p\",[a._v(\"与求中位数的操作相同，不同的就是两个堆存储数据的多少。\")]),a._v(\" \"),v(\"p\",[a._v(\"大顶堆存储前 99% 的数据\\n小顶堆存储后 1% 的数据\")]),a._v(\" \"),v(\"h2\",{attrs:{id:\"qa-假设现在有包含-10-亿个搜索关键词的日志文件，快速获取热门榜-top-10-的关键词\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#qa-假设现在有包含-10-亿个搜索关键词的日志文件，快速获取热门榜-top-10-的关键词\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" QA 假设现在有包含 10 亿个搜索关键词的日志文件，快速获取热门榜 Top 10 的关键词\")]),a._v(\" \"),v(\"ol\",[v(\"li\",[a._v(\"通过散列表存储搜索关键词的出现次数\")]),a._v(\" \"),v(\"li\",[a._v(\"建一个大小为 10 的小顶堆\")]),a._v(\" \"),v(\"li\",[a._v(\"遍历散列表\\n\"),v(\"ol\",[v(\"li\",[a._v(\"如果关键词的次数大于堆顶的次数，就删除堆顶元素，将关键词插入堆中\")]),a._v(\" \"),v(\"li\",[a._v(\"否则跳过\")])])]),a._v(\" \"),v(\"li\",[a._v(\"遍历完成后，堆中的数据就是所求数据\")])]),a._v(\" \"),v(\"h3\",{attrs:{id:\"优化\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#优化\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 优化\")]),a._v(\" \"),v(\"p\",[a._v(\"通过关键词的哈希值取模，将所有的关键词分片到小文件中，然后分别对小文件中的关键词求其 Top 10 。最后将所有的 Top 10 放到一起后取他们的 Top 10 就是所有关键词的 Top 10了。\")])])},[],!1,null,null,null);_.default=r.exports}}]);","extractedComments":[]}